# FreeCodeCamp Full Stack Curriculum

This document contains lecture content from the FreeCodeCamp Full Stack curriculum.


# Chapter: Html


## Module: Basic Html


### Lecture Block: Lecture Welcome To Freecodecamp


## Welcome Message from Quincy

### Description

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/freeCodeCamp_team.jpeg" alt="the freeCodeCamp team">

I'm Quincy Larson, teacher and founder of freeCodeCamp.org.

Our charity's mission is to create free learning resources to help people learn math, programming, and computer science. And that's precisely what we've done for you here.

This free, verified certification includes thousands of hours of lectures, interactive labs, and projects. You're going to build dozens of apps from scratch.

This is real coding. Everything's fully interactive. You'll immediately apply concepts as you learn them. And you'll get plenty of practice and spaced repetition along the way.

Over the past decade, tens of thousands of people who've learned to code using freeCodeCamp have gotten their first developer jobs. Many of these people don't even have a university degree.

But I'm not going to sugarcoat it: learning to code is hard. You're going to spend many nights and weekends sharpening your skills by building projects.

The good news is that the freeCodeCamp community is with you all the way. You can get help anytime you get stuck. Just use the freeCodeCamp forum or the freeCodeCamp Discord. Or you can use the search bar and search through thousands of reference articles created by the community.

In the next lecture, I'll explain how the freeCodeCamp curriculum and how the certifications work.


## How Does the Certification Process Work?

### Description

freeCodeCamp offers free, verified certifications. We've structured our curriculum to give you tons of practice with each tool and each concept, to help you prepare for your certification exams.

You'll read short lectures and answer comprehension-check questions about them.

You'll code your way through step-by-step interactive workshops.

And you'll build dozens of projects from scratch.

Along the way, you'll pass dozens of quizzes and exams. And you'll prove to us — and you'll prove to yourself — that you've mastered these tools and concepts.

Toward the end of the curriculum, you'll build your own unique capstone project that we'll review and give you feedback on. This will be a project worthy of adding to your professional portfolio.

After you've completed the curriculum, passed the final exam, and built your capstone project, you can claim your free verified certification.

Your certification will have its own unique verification URL, unique serial number, and unique QR code. You can add your certification to your résumé, LinkedIn, CV, and portfolio website.

At freeCodeCamp, we take developer education seriously. There are no shortcuts. You'll spend thousands of hours completing the curriculum.

Even if life gets in the way, and you have to stop for a while, we'll be here, ready to help you push forward with your skills.

You need to work hard, yes. But you also need to work smart.

Before we dive into the curriculum, I'm going to share some insight into how most people learn effectively, and how most people work smart.


## How do Most People Learn Effectively?

### Description

Learning is a skill all its own. And I'm going to quickly introduce you to key observations that scientists have made about learning.

These come from engineering professor Barbara Oakley's book, *Learning how to Learn.*

Concept number 1: spaced repetition. Learning for half an hour each day for a week is much more effective than learning for three and a half hours all in one day. This is because of the role that sleep plays in memory. When you sleep, your brain builds and reinforces neural structures. With spaced repetition, you review concepts regularly — first every few days, then every few weeks, then every few months. Each time, your retention of those concepts improves. freeCodeCamp has spaced repetition baked right into the curriculum.

Concept number 2: interleaving practice. Rather than just studying one concept for an entire study session, it's better to get a little exposure to lots of concepts. This shakes up your brain, and forces you to continually reframe what you know. Through interleaving practice, you train yourself to be more agile in your thinking. For this reason, the freeCodeCamp curriculum covers a ton of ground quickly, then circles back to reinforce everything over and over.

Concept number 3: active recall. It's easy to trick yourself into thinking you're much better at a skill than you actually are. Almost all beginners experience what scientists call an "illusion of competence". But, the best way to shatter that illusion is to actively recall and apply what you're learning. The freeCodeCamp curriculum does this through quizzes, coding exercises, and full-blown projects.

Again, we've incorporated all of these concepts into the freeCodeCamp curriculum. You're welcome to customize your learning as you see fit. But when in doubt, just keep going through the curriculum, from top to bottom, and you'll be fine.

In the next lecture, we will discuss some strategies for building effective learning habits.


## How Can You Build Effective Learning Habits and Work Smarter?

### Description

To make it through something as rigorous as the freeCodeCamp curriculum, you'll need to not only work hard – you'll need to work smart.

Over the years, I've talked with thousands of people who've learned to code and gotten developer jobs. Here are some tips that have worked for them.

Tip number 1: pace yourself. Learning to code is a marathon, not a sprint. Remember that it's better to code 30 minutes every day of the week, than to try and cram all your learning into one day. This is thanks to the important role that sleep plays in learning.

The freeCodeCamp curriculum already incorporates all those learning concepts I mentioned earlier: spaced repetition, interleaving practice, active recall. All you need to do is sit down and work through the curriculum consistently every day.

This is easier said than done. Most people who start this curriculum will at some point stop. Hopefully, some of those people will come back and finish in the future. But let's talk about you. We want you to finish what you start. And the best advice I have is to remember to pace yourself.

Tip number 2: routine is your friend. If you make a habit of waking up 30 minutes earlier every day, you can get in a coding session before you go to work. After a few weeks of doing this, it just becomes part of your routine. You don't really have to think too much about it, or expend any additional willpower. It's just something that you do.

Now, I understand that you're probably busy. I wish I could tell you that there was just some magic book that you could buy, and that would be enough. The reason buying a book feels so good is that it feels like you're also buying the time to read it. But there's no magic involved in learning to code. You've got to put in the time. You've got to put in the reps at the keyboard. 

I'll tell you this: if you can code for even 30 minutes a day, you're going to make serious gains over the course of a year.

Tip number 3: Use the Pomodoro technique. Pomodoro is the Italian word for tomato. In Italy they have these tomato shaped clocks that you set for 25 minutes.

Sitting down to code isn't easy. It takes willpower. So to make it easier to sit down and start that coding, just tell yourself that you're going to code for 25 minutes. Set a timer. Then, once you've finished 25 minutes, you can take a break. But by this point, you may be so deep into your coding session, that you don't even need to take a break.

The Pomodoro technique makes it a lot easier to get started.

Final tip: remember to get plenty of sleep. You'll learn best when you're at your best. Sleep plays a vital role in how your brain learns. I encourage you to try to sleep at least 8 hours each night.

And with that, you're ready to dive into the curriculum and start working toward earning your freeCodeCamp verified certification. Happy coding!


### Lecture Block: Lecture Understanding Html Attributes


## What Role Does HTML Play on the Web?

### Description

HTML, which stands for Hypertext Markup Language, is a markup language for creating web pages. When you visit a website and see content like paragraphs, headings, links, images, and videos; that's HTML. HTML represents the content and structure of a webpage through the use of elements. Here's an example of a paragraph element:

```html
<p>Hello</p>
```

Most elements will have an opening tag and a closing tag. Sometimes those tags are referred to as start and end tags. In between those two tags, you will have the content. This content can be text or other HTML elements. Both opening and closing tags start with a left angle bracket (`<`), and end with a right angle bracket (`>`), with the tag name placed between these angle brackets. Here is a closer look at just the opening and closing paragraph tags:

```html
<p>
```

```html
</p>
```

What distinguishes an opening tag from a closing tag is the forward slash (`/`) placed immediately after the left angle bracket in a closing tag. Some HTML elements do not have a closing tag. These are known as void elements. Here is an example of an image element which is a void element:

```html
<img>
```

Notice that this image element does not have the closing tag and it does not have any content. Void elements cannot have any content and only have a start tag.

Sometimes you will see void elements that use a `/` before the `>` like this:

```html
<img />
```

While many code formatters like Prettier, will choose to include the `/` in void elements, the HTML spec states that the presence of the `/` "does not mark the start tag as self-closing but instead is unnecessary and has no effect of any kind".

In real world development, you will see both forms so it is important to be familiar with both.

If you wanted to display an image, you will need to include a couple of attributes inside your image element. An attribute is a special value used to adjust the behavior for an HTML element. Here is an example of an image element with a `src`, or source, attribute:

```html
<img src="image location" />
```

The `src` attribute is used to specify the location for that image. For image elements, it's good practice to include another attribute called the `alt` attribute. Here's an example of an image element with the `src` and `alt` attributes:

```html
<img src="example-cat-img-url" alt="Cat sleeping in the grass">
```

The `alt` attribute is used to provide short, descriptive text for the images. In this case, the descriptive text is a "Cat sleeping in the grass".

So, you might be wondering if HTML by itself is enough to build a website. Well, the answer is: it depends. If you're building a small practice project that only displays text and images, HTML alone might be sufficient. However, if you're creating a modern professional website, you will need to have HTML, CSS, and JavaScript.

HTML is for the content and structure. CSS is for styling. JavaScript is for adding interactivity to your web pages. A good analogy for this is to compare HTML, CSS, and JavaScript with a complete building. HTML represents the blocks, concrete, and irons that make up the walls. It's the foundation that makes the building strong. CSS represents the interior and exterior design that makes the house look beautiful. JavaScript represents the electrical and water system that ensures uninterrupted access to water and electricity.


## What Are Attributes, and How Do They Work?

### Description

An attribute is a value placed inside the opening tag of an HTML element. Attributes provide additional information about the element or specify how the element should behave. Here is the basic syntax for an attribute:

```html
<element attribute="value"></element>
```

The attribute name is followed by an equal sign (`=`) and a value in quotes. The value can be a string or a number, depending on the attribute.

Let's take a look at a few examples of common HTML attributes. The first example is the `href` attribute, which is used to specify the URL of a link:

```html
<a href="https://www.example-website.com">Visit our website</a>
```

Without this attribute, the link would not work because there would be no destination URL. So you must include this `href` attribute to make the link functional. Other common attributes are the `src`, or source, and `alt`, or alternative, attribute - which is used to specify the source of an image and provide alternative descriptive text for the image, respectively: 

```html
<img src="image.jpg" alt="A beautiful image" />
```

Similar to the `href` attribute, the `src` attribute is required because it specifies the image file to be displayed. The `alt` attribute is not required, but it is recommended for accessibility purposes. Accessibility means making sure that everyone, including those with disabilities, can use and understand things like websites, apps, and physical spaces. You will learn more about accessibility in the upcoming lectures.

Some attributes are a little unique with their syntax like the `checked` attribute shown here:

```html
<input type="checkbox" checked />
```

In the following example, we have an `input` element with the `type` attribute set to `checkbox`. Inputs are used to collect data from users, and the `type` attribute specifies the type of input. In this case, this input is a checkbox. You will learn more about how inputs work in the upcoming lectures. The `checked` attribute is used to specify that the checkbox should be checked by default. The `checked` attribute does not require a value. If it is present, the checkbox will be checked by default. If the attribute is not present, the checkbox will be unchecked. This is known as a boolean attribute. You will learn more about booleans in general when you get to the JavaScript section. There are several common boolean attributes you will encounter in HTML, such as `disabled`, `readonly`, and `required`. These attributes are used to specify the state of an element, such as whether it is disabled, read-only, or required.

HTML has many attributes that can be used to customize the behavior and appearance of elements on a webpage. Understanding how to use attributes is essential for creating interactive and accessible web content. Over the next few lectures, you will learn about more HTML attributes and how to use them effectively in your web development projects.


### Lecture Block: Lecture Understanding The Html Boilerplate


## What Is the Role of the Link Element in HTML, and How Can It Be Used to Link to External Stylesheets?

### Description

Let's learn about the `link` element, and how to use it to link to external stylesheets.

The `link` element is used to link to external resources like stylesheets and site icons. Here is the basic syntax for using the `link` element for an external CSS file:

```html
<link rel="stylesheet" href="./styles.css" />
```

The `rel` attribute is used to specify the relationship between the linked resource and the HTML document. In this situation, we need to specify that this linked resource is a `stylesheet`.

It is considered best practice to separate your HTML and CSS in different files. Developers will use the `link` element for their external CSS file instead of writing everything in the HTML document.

The `href` attribute is used to specify the location of the URL for the external resource. 

The `dot` followed by a forward slash in the example tells the computer to look in the current folder, or directory, for the `styles.css` file.

The `link` element should be placed inside the `head` element as seen in the following example:

```html
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Examples of the link element</title>
  <link rel="stylesheet" href="./styles.css" />
</head>
```

Often times you will see multiple `link` elements inside a professional codebase that link to different stylesheets, fonts, and icons. Here is an example of using the `link` element to link to an external Google Font called *Playwright Cuba*:

```html
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
  href="https://fonts.googleapis.com/css2?family=Playwrite+CU:wght@100..400&display=swap"
  rel="stylesheet"
/>
```

Google Fonts are a set of free and open source custom fonts that you can use inside any project. You can choose which fonts you would like to use and Google will provide you with the necessary HTML and CSS code. In this example, the `preconnect` value for the `rel` attribute tells the browser to create an early connection to the value specified in the `href` attribute. This is done to speed up loading times for these external resources.

Another common use case for the `link` element is to link to icons. Here is an example of linking to a favicon:

```html
<link rel="icon" href="favicon.ico" />
```

A favicon, which is short for favorite icon, is a small icon typically displayed in the browser tab next the site title. A lot of websites will use a favicon to display their brand icon.


## What Is an HTML Boilerplate, and Why Is It Important?

### Description

Let's learn about the HTML boilerplate.

What is the HTML boilerplate, you ask? It's like a ready-made template for your webpages. Think of it as the foundations of a house. A boilerplate includes the basic structure and essential elements every HTML document needs. It saves you time and helps ensure your pages are set up properly. Here is an example:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
       name="viewport"
       content="width=device-width, initial-scale=1.0" />
    <title>freeCodeCamp</title>
    <link rel="stylesheet" href="./styles.css" />
  </head>
  <body>
  </body>
</html>
```

Let's break down the key parts of this boilerplate. First, there is the `DOCTYPE` declaration:

```html
<!DOCTYPE html>
```

It tells browsers which version of HTML you're using. Next, comes the `html` tag:

```html
<!DOCTYPE html>
<html lang="en">
  <!--All other elements go inside here-->
</html>
```

This wraps around all your content, and can specify the language of your page. Inside the `html` tag, you'll find two main sections - a `head`, and a `body`:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <!--Important metadata goes here-->
  </head>
  <body>
    <!--Headings, paragraphs, images, etc. go inside here-->
  </body>
</html>
```

The `head` section contains important behind-the-scenes information:

```html
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document Title Goes Here</title>
  <link rel="stylesheet" href="./styles.css" />
</head>
```

Your site's metadata, contained in `meta` elements, has details about things like character encoding, and how websites like Twitter should preview your page's link. Your site's title, found in the `title` element, determines the text that appears in the browser tab or window. Finally, you'll typically link your page's external stylesheets in the `head` section using `link` elements.

The `body` section is where all your content goes:

```html
<body>
  <h1>I am a main title</h1>
  <p>Example paragraph text</p>
</body>
```

Now, why is a boilerplate important? It ensures your pages are structured correctly and work well across different browsers. Using a boilerplate helps you avoid common mistakes and follow best practices. It's a great starting point for any web project. Remember, you can customize your own boilerplate to fit your needs. As you gain experience, you might add your own preferred elements or `meta` tags. As you continue to improve your personal boilerplate, you'll find that it saves you time when starting new projects.

Next time you start a new HTML file, consider using a boilerplate. It will definitely give you a solid foundation to build on.


## What Is UTF-8 Character Encoding, and Why Is It Needed?

### Description

What is UTF-8 character encoding, and why is it needed?

UTF-8, or UCS Transformation Format 8, is a standardized character encoding widely used on the web. Character encoding is the method computers use to store characters as data. Essentially, all text on a web page is a sequence of characters stored as one or more bytes. In computing, a byte is a unit of data consisting of 8 bits, or binary digits. UTF-8 supports every character in the Unicode character set - and this includes characters and symbols from all writing systems, languages, and technical symbols. Here is an example of using the `meta` element with the `charset` attribute to set the character encoding to `UTF-8`:

```html
<meta charset="UTF-8" />
```

By setting the character encoding to UTF-8, it will ensure that the accented `"e"` character (`é`) is displayed correctly on the page. Here is an extended code example of using the UTF-8 character encoding:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Examples of the UTF-8 encoding</title>
  </head>
  <body>
    <p>Café</p>
  </body>
</html>
```

For each new project you create, you should include this `meta` element with the `charset` attribute set to `UTF-8`.


### Lecture Block: Lecture Html Fundamentals


## What are Div Elements and When Should You Use Them?

### Description

Now that we understand what HTML is, let's move onto the fun stuff! I am going to look at the Content Division Element - or in other words, the *div*:

```html
<div></div>
```

I like to think of the `div` as a beautiful being that can be anything you want it to be. We can give a `div` a `height`, we can give it a `width`, and we can give it a background color using CSS - or in other words styling, which we will cover in lectures coming up.

We can also use it in a very basic form without styling, to hold other elements together. So for example, we can create a `div` and put a heading in it, and put a paragraph in it, and now these two elements will be grouped together:

```html
<div>
  <h1>I am a heading</h1>
  <p>I am a paragraph</p>
</div>
```

Just be aware that there might be better elements to use when grouping these together. You might choose a `section` element, for example:

```html
<section>
  <h1>I am a heading</h1>
  <p>I am a paragraph</p>
</section>
```

This is because the `section` element has semantic meaning. Semantics are the meaning of words or phrases in a language. In HTML, which is a language, elements have their own semantic meaning too. So, this means if you use a `section` element, the browser will pick up its semantic meaning and understand to treat this as a section - on desktops, mobiles, you name it. 

We will dive into this topic further later on. For now, just know that the `div`, does not have this. It's like a mysterious ghost. Let's see what else we can do to a `div`, in the next lecture.


## What Are IDs and Classes, and When Should You Use Them?

### Description

The `id` attribute adds a unique identifier to an HTML element. In this example, there is an `h1` element with an `id` of `title`:

```html
<h1 id="title">Movie Review Page</h1>
```

You can reference the `id` name of `title` within your JavaScript or CSS. Here's a CSS example referencing the `id` of `title` to change the text `color` to `red`:

```css
#title {
  color: red;
}
```

The hash symbol (`#`) in front of `title`, tells the computer you want to target an `id` with that value. `id` names should not be used more than once, and they should always be unique. Another thing to note about `id` values, is that they cannot have spaces in them. Here is an example of applying the words `main` and `heading` to an `id` attribute value:

```html
<h1 id="main heading">Main heading</h1>
```

Browsers will see this space as part of the `id` which will lead to unwanted issues when it comes to styling and scripting. `id` attribute values should only contain letters, digits, underscores, and dashes.

In contrast to the `id` attribute, the `class` attribute value does not need to be unique and can contain spaces. Here is an example of applying a class called `box` to a `div` element:

```html
<div class="box"></div>
```

If you wanted to add multiple class names to an element, you can do so by separating the names by a space. Here is an updated example applying multiple classes to a `div` element:

```html
<div class="box red-box"></div>
```

To apply a set of styles to that `box` class, you can reference that class inside your CSS. Here is an example of setting `width`, `height`, and `border` properties to the element with the `class` name of `box`:

```css
.box {
  width: 200px;
  height: 200px;
  border: 2px solid black;
}
```

The dot symbol (`.`) in front of `box`, tells the computer you want to target a `class` with that value. When the code runs, it will search through all of your HTML document to find all elements with that class name and apply those styles.

So, to recap, when should you use an `id` versus a `class`? Classes are best used when you want to apply a set of styles to many elements. If you want to target a specific element, it is best to use `id` because those values need to be unique.


## What Are HTML Entities, and What Are Some Common Examples?

### Description

An HTML entity, or character reference, is a set of characters used to represent a reserved character in HTML. In this example, there is a paragraph element with an image element nested inside:

```html
<p>This is an <img /> element</p>
```

The text on the screen should say `This is an <img/> element`. However, the text currently says `This is an element.` This is happening because when the HTML parser sees the less than (`<`) symbol followed by an HTML tag name, it interprets that as an HTML element.

To fix this issue, you can use HTML entities. Here is an updated example using the correct HTML entities for the less than and greater than (`>`) symbols.

```html
<p>This is an &lt;img /&gt; element</p>
```

These types of character references are known as named character references. Named references start with an ampersand sign (`&`) and end with a semicolon (`;`). By using a named character reference, the HTML parser will not confuse this with an actual HTML element. Here is what the updated paragraph element looks like on the page: `This is an <img/> element`. Now, users will be able to see the entire image element syntax as you intended it.

Another type of character reference would be the decimal numeric reference. Here is an example of using the decimal numeric reference for the less than symbol:

```html
&#60;
```

This character reference starts with an ampersand sign and hash symbol (`#`), followed by one or more decimal digits, followed by a semicolon.

The last type of character reference would be the hexadecimal numeric reference. Here is an example of using the hexadecimal numeric reference for the less than symbol:

```html
&#x3C;
```

This character reference starts with an ampersand sign, hash symbol, and the letter `x`. Then it is followed by one or more ASCII hex digits and ends with a semicolon.

So what are some other examples of using HTML entities? Well, you often see them used for symbols like the copyright symbol (`©`), quotes (`"`), trademark symbol (`™`), and the ampersand sign.


## What Is the Role of the Script Element in HTML, and How Can It Be Used to Link to External JavaScript Files?

### Description

The `script` element is used to embed executable code. Most developers will use this to execute JavaScript code. JavaScript is used to add interactivity to your web pages. Common examples of using JavaScript include interactive games, image sliders, and dynamic forms that validate user input in real-time. Here is an example of using the `script` element in an HTML document:

```html
<body>
  <script>
    alert("Welcome to freeCodeCamp");
  </script>
</body>
```

In this example, we have an `alert` to display the message `Welcome to freeCodeCamp.` When the page first loads, the alert will pop up. Then the user can click on the OK button to dismiss the message.

While you can technically write all of your JavaScript code inside the `script` tags, it is considered best practice to link to an external JavaScript file instead. Here is an example of using the `script` element to link to an external JavaScript file:

```html
<script src="path-to-javascript-file.js"></script>
```

The `src` attribute is used here to specify the location for that external JavaScript file. `src` stands for "source". The reason why it is not encouraged to place all of your JavaScript inside the HTML document is because of separation of concerns. Separation of concerns is a design principle where you separate your programs into distinct sections and have each section address a separate concern. In this case, we want to separate our JavaScript code from our HTML code.


## What Is the Role of the Meta Description, and How Does It Affect SEO?

### Description

SEO, or Search Engine Optimization, is a practice that optimizes web pages so they become more visible and rank higher on search engines. One way to improve your site's SEO, is to provide a short description for the web page using the `meta` element. Here is an example of using the meta element to set a page description for a gardening site:

```html
<meta
  name="description"
  content="Discover expert tips and techniques for gardening in small spaces, choosing the right plants, and maintaining a thriving garden."
/>
```

By setting the `name` attribute to `description`, it ensures that browsers, search engines, and other web tools correctly interpret this metadata. The `content` attribute is where you will place your description. It is recommended that you keep your descriptions short and concise. This is because search engines will often truncate the description based on the results page layout.

Similar to other types of `meta` elements, the `meta` description will not be visible on the web page itself. One place where the page description can be found is in the search engine results page snippet. Here are some examples of page result snippets for freeCodeCamp's subreddit and GitHub repositories:

```sh
r\FreeCodeCamp: This is the official subreddit for the freeCodeCamp.org community. Learn to
code for free together with millions of other people...
```

```sh
Our full-stack web development and machine learning curriculum is completely free and self-
paced. We have thousands of interactive coding challenges to help you...
```

In the examples, each of the page descriptions are located just beneath the site links. Within a couple of seconds, users can get a general sense of what the page is about and decide to click on the links for more information.

Even though `meta` descriptions won't directly affect a site's ranking on search engine, having a strong description could result in more traffic to your website.


## What Is the Role of Open Graph Tags, and How Do They Affect SEO?

### Description

The open graph protocol enables you to control how your website's content appears across various social media platforms, such as Facebook, LinkedIn, and many more. By setting these open graph properties, you can entice users to want to click and engage with your content. You can set these properties through a collection of `meta` elements inside your HTML `head` section.

The first important OG property to include would be the `title`. Here is an example of setting the OG `title` for the freeCodeCamp homepage:

```html
<meta content="freeCodeCamp.org" property="og:title" />
```

For the `property` attribute, you will need to specify that it is `og:title`. The `content` attribute is where you will write the title you want displayed for social media sites.

The next important OG property would be the `type`. Here is an example of using the OG `type` for the freeCodeCamp homepage:

```html
<meta property="og:type" content="website" />
```

The `type` property is used to represent the type of content being shared on social media. Examples of this content include articles, websites, videos, or music.

The third important OG property would be the `image`. Here is an example of setting the OG `image` for the freeCodeCamp homepage:

```html
<meta
  content="https://cdn.freecodecamp.org/platform/universal/fcc_meta_1920X1080-indigo.png"
  property="og:image"
/>
```

In this example, the open graph image is pointing to the freeCodeCamp logo. All of these images should be high quality with good dimensions and ratios. Most social media platforms will include criteria for image requirements to help you ensure that your content displays well on their site. For example, the developers.facebook.com documentation page states:

"use images that are at least 1200 by 630 pixels for the best display on high resolution devices. At the minimum, you should use images that are 600 by 315 pixels to display link page posts with larger images."

The fourth important OG property would be the `url`. Here is an example of setting the OG `url` for the freeCodeCamp homepage:

```html
<meta property="og:url" content="https://www.freecodecamp.org" />
```

There are many more OG properties that you can set, like `description`, `audio`, `video` and `locale`. However, the open graph `url`, `image`, `type`, and `title` are the most important ones to include.

So how do these open graph properties affect Search Engine Optimization? When your content is shared on social media, well-crafted OG properties can enhance the appearance for your content in users' feeds. This can lead to higher click-through rates which could signal to search engines that your content is relevant and engaging.


### Lecture Block: Lecture Working With Audio And Video Elements


## What Are the Roles of the HTML Audio and Video Elements, and How Do They Work?

### Description

The `audio` and `video` elements allow you to add sound and video content to your HTML documents. The `audio` element supports popular audio formats like mp3, wav, and ogg.
The `video` element supports mp4, ogg, and webm formats.

To include audio content on your web page, you can use the `audio` element with the `src` attribute pointing to the location of your audio file:

```html
<audio src="CrystalizeThatInnerChild.mp3"></audio>
```

If you try to run this example, you'll see that nothing shows up on the page. However, if you inspect the page with the developer tools, you'll see the `audio` element is indeed on the page. If you want to see the audio player on the page, then you can add the `audio` element with the `controls` attribute:

```html
<audio src="CrystalizeThatInnerChild.mp3" controls></audio>
```

The `controls` attribute enables users to manage audio playback, including adjusting volume, and pausing, or resuming playback. The `controls` attribute is a boolean attribute that can be added to an element to enable built-in playback controls. If omitted, no controls will be shown.

Apart from the `src` and `controls` attributes, there are several other attributes that enhance the functionality of the `audio` element. The `loop` attribute is a boolean attribute that makes the audio replay continuously. Here's an example of using the `loop` attribute to play one of Quincy Larson's songs titled "Can't stay down":

```html
<audio
  src="https://cdn.freecodecamp.org/curriculum/js-music-player/can't-stay-down.mp3"
  loop
  controls
></audio>
```

When the song reaches the end, it will loop back around and play it again from the beginning. Another attribute you can use is the `muted` attribute. When present in the `audio` element, this boolean attribute will start the audio in a muted state. Here's an example of using the `muted` attribute:

```html
<audio
  src="https://cdn.freecodecamp.org/curriculum/js-music-player/can't-stay-down.mp3"
  loop
  controls
  muted
></audio>
```

When you start the song in the browser, you'll not hear anything. To hear the music you will need to click on the volume icon.

When it comes to audio file types, there are differences in which browsers support which type. To accommodate this, you can use `source` elements inside the `audio` element and the browser will select the first source that it understands. Here's an example of using multiple `source` elements for an `audio` element:

```html
<audio controls>
  <source src="audio.ogg" type="audio/ogg" />
  <source src="audio.wav" type="audio/wav" />
  <source src="audio.mp3" type="audio/mpeg" />
</audio>
```

The browser will first start with the ogg type, and if it can't play the audio, then it'll move down to the next type in the list.

All the attributes we have learned so far are also supported in the `video` element. Here's an example of using a `video` element with the `loop`, `controls`, and `muted` attributes:

```html
<video
  src="https://archive.org/download/BigBuckBunny_124/Content/big_buck_bunny_720p_surround.mp4"
  loop
  controls
  muted
></video>
```

For the `src`, or source attribute, we are using a video called "Big Buck Bunny" from archive.org. If you wanted to display an image while the video is downloading, you can use the `poster` attribute. This attribute is not available for `audio` elements and is unique to the `video` element. Here's an example of using the `poster` attribute with content provided by peach.blender.org:

```html
<video
  src="https://archive.org/download/BigBuckBunny_124/Content/big_buck_bunny_720p_surround.mp4"
  loop
  controls
  muted
  poster="https://peach.blender.org/wp-content/uploads/title_anouncement.jpg?x11217"
  width="620"
></video>
```

This example is also using the `width` attribute to set the width to 620 pixels so the video fits better on the screen.


### Lecture Block: Lecture Working With Images And Svgs


## What Are Common Ways to Optimize Media Assets?

### Description

There are three tools to consider when using media, such as images, on your web pages: the size, the format, and the compression.

Let's talk about the size of your images first. When you are building a website, you'll often style images to display in a specific size. For example, you might have an image display at a 640x480 resolution. 640 represents the width while 480 represents the height in pixels. When preparing your image you want to scale it to a 640x480 size to match that styling. If you serve an image that is 1920x1080 but you are styling it to be much smaller, you're requiring your users to download unnecessary data. A smaller resolution results in a smaller file size.

The next thing to consider is your file format. Two of the most common file formats are PNG and JPG, but these are no longer the most ideal formats for serving images. Unless you need support for older browsers, you should consider using a more optimized format, like WEBP or AVIF.

Finally, you can run compression algorithms on your images. A compression algorithm is used to reduce the size for files or data. There are options like pngcrush to compress your images locally, or you can use online compression tools. However, it's worth noting that specific file formats, such as JPG, are not lossless. Lossless means that the original data can be perfectly reconstructed from the compressed data. If you try to compress a JPG image, it will result in a degraded quality. You should keep all these things in mind when selecting images for your web pages.


## What Are the Different Types of Image Licenses, and How Do They Work?

### Description

Images are considered intellectual property, this means that they are protected by copyright regulations, most often belonging to the creator. By default, images are released as all rights reserved. The creator, or publisher sometimes, holds all copyright for the image.

This means that you cannot use them in your web page unless you do one of three things: obtain written permission from the copyright holder, purchase a license from the copyright holder, or incorporate the image in a way that falls under fair use.

That third point is a bit tricky. Fair use requires that your use of the image is both limited and transformative. Some examples of fair use would be to comment on or review the art or create a parody of the image.

Some images might be released under a permissive license, like a Creative Commons license, or the BSD license that freeCodeCamp uses. These images are available for use in your website, but you'll need to read the license to understand the rules you need to follow when using these images. For example, you might be required to make your website open source, or you may not be permitted to modify the image in any way.

Finally, some images may be released to the public domain. An image under the public domain has no copyright attached to it and is free to be used without any restrictions. Images licensed specifically under the Creative Commons 0 license are considered public domain.

Most search engines will allow you to filter image results by a license. There are also sites like Pixabay and Unsplash, which offer free-to-use images. Always be mindful of the copyright and licensing when you use an image in your website.


## What Are SVGs, and When Should You Use Them?

### Description

First, you need to understand how images work. Common image formats like PNG and JPG are classified as raster formats. This essentially means that they are pixel-based, with the data tracking the color value in each pixel.

A large downside of raster based images is that they do not upscale well. If you've ever tried to make a PNG larger, you may have seen that it becomes pixelated, or blurry.

An SVG is a different kind of image. SVG stands for a scalable vector graphic. A vector graphic tracks data based on paths and equations to plot points, lines, and curves. What this really means is that a vector graphic, like an SVG, can be scaled to any size without impacting the quality.

SVGs specifically have the added benefit of storing data in XML. This means you can use them directly in your code as raw HTML with the `svg` element. It also means you can programmatically change the color of the image.

So when would you want to use an SVG? A great use case is for icons. If you want to create custom bullet points, or add icons to your links to represent social media platforms, using SVGs is the best approach. One of the most popular icon libraries, Font Awesome, uses SVG images for their icons. SVGs are also great for webpage logos, because they scale perfectly. They allow you to adapt your layout to any responsive design you need. Next time you have an SVG locally, try opening it with a text editor and playing with the code.


### Lecture Block: Lecture Working With Media


## What Are Replaced Elements, and What Are Some Examples?

### Description

A replaced element is an element whose content is determined by an external resource rather than by CSS itself. CSS, or cascading stylesheets, is used to add styles to a web page. Common examples of replaced elements include the image, iframe, and video elements.

With replaced elements, you can control the position, or layout of an element. But your CSS cannot directly modify the content of that element. This might be easier to explain with some examples. Consider the image element, which embeds an image on your web page:

```html
<img src="example-img-url" alt="Descriptive text goes here">
```

The element itself is replaced with the external object: the image. Your CSS can control things like the positioning of the image, or apply a filter to it, but you cannot actually modify the image itself. A more robust example might be the `iframe` element, which embeds an external site on your web page:

```html
<iframe src="https://www.example.com" title="Example Site"></iframe>
```

Common examples for using the `iframe` element would be to embed Maps or YouTube videos onto the page. The element itself is replaced with the external object: the site. Your CSS can change the positioning of the embedded site, but you cannot modify the site's contents. To dive a bit further, if the embedded site has an `h1` element, your CSS would not be able to style that `h1` element. You cannot change the size, font color, and so on.

There are some other replaced elements, such as `video`, and `embed`. And some elements behave as replaced elements under specific circumstances. Here's an example of an `input` element with the `type` attribute set to `image`:

```html
<input type="image" alt="Descriptive text goes here" src="example-img-url">
```

This type of `input` is considered to be a replaced element, but other `input` types like `text`, or `email` are not replaced elements.


## How Do You Embed Videos onto Your Page Using the iframe Element?

### Description

First, what exactly is the `iframe` element? `iframe` stands for inline frame. It's an inline element used to embed other HTML content directly within the HTML page. That HTML content could be a video, map, another HTML element, or even other web pages. Here's what the syntax of the `iframe` element looks like:

```html
<iframe
  src="video-url"
  width="width-value"
  height="height-value"
  allowfullscreen
></iframe>
```

The `src` attribute specifies the URL of the page you want to embed. The `width` attribute specifies the width of the `iframe`. The `height` attribute specifies the height of the `iframe`. The `allowfullscreen` attribute allows the user to display the `iframe` in full screen mode. It's also a good practice to specify a `title` attribute for the `iframe`, as it's important for accessibility.

To embed a video within an `iframe` you can copy it directly from popular video services like YouTube and Vimeo, or define it yourself with the `src` attribute pointing to the URL of that video. Here's an example of embedding a popular freeCodeCamp course from YouTube:

```html
<h1>A freeCodeCamp YouTube Video Embedded with the iframe Element</h1>

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/PkZNo7MFNFg?si=-UBVIUNM3csdeiWF"
  title="YouTube video player"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  referrerpolicy="strict-origin-when-cross-origin"
  allowfullscreen
></iframe>
```

You can then customize the `iframe` to your needs or even define your own by copying the link to the YouTube video and pasting it in as the URL value. The caveat is that you must replace https://youtu.be with https://youtube.com/embed/.

youtu.be is the domain when you copy the share link and youtube.com/embed/ is the domain required for embedding videos with the `iframe` element. Here's an example of that:

```html
<iframe
  src="https://youtube.com/embed/gp5H0Vw39yw?si=Rb_2nDK6abv1iIAM"
  title="freeCodeCamp Typescript Course"
  width="500"
  height="285"
  allowfullscreen
></iframe>
```

Note that the video can come from anywhere. It doesn't have to come from video services like YouTube and Vimeo. Here's a video from Pixabay embedded with the `iframe` element:

```html
<h1>A Video from Pixabay Embedded with the iframe Element</h1>

<iframe
  src="https://cdn.pixabay.com/video/2022/07/24/125310-733046613_large.mp4"
  width="500"
  height="285"
></iframe>
```

Don't forget you can also embed a map, another web page, or direct HTML within the `iframe` element. Here's a map I was able to embed with the `iframe` element:

```html
<h1>A Map from Openstreetmap.org Embedded with the iframe Element</h1>

<iframe
  width="425"
  height="350"
  src="https://www.openstreetmap.org/export/embed.html?bbox=3.006134033203125%2C6.150112578753815%2C3.6357879638671875%2C6.749850810550778&amp;layer=mapnik"
  style="border: 1px solid black"
>
</iframe>
<br />
<small>
  <a href="https://www.openstreetmap.org/#map=11/6.4501/3.3210">
    View Larger Map
  </a>
</small>
```

If you want to embed direct HTML within the `iframe` element you have to use the `srcdoc` attribute instead of `src`.


### Lecture Block: Lecture Working With Links


## What Are the Different Target Attribute Types, and How Do They Work?

### Description

You may have seen the `target` attribute on anchor elements, or links. This important attribute tells the browser where to open the URL for the anchor element:

```html
<a href="https://freecodecamp.org" target="_blank">Visit freeCodeCamp</a>
```

There are four important possible values for this attribute. Note that each value is preceded by an underscore.

The first value is `_self`, which is the default value. This opens the link in the current browsing context. In most cases, this will be the current tab or window.

The second value is `_blank`, which opens the link in a new browsing context. Typically, this will open in a new tab. But some users might configure their browsers to open a new window instead.

The third value is `_parent`, which opens the link in the parent of the current context. For example, if your website has an `iframe`, a `_parent` value in that `iframe` would open in your website's tab/window, not in the embedded frame.

The fourth value is `_top`, which opens the link in the top-most browsing context - think "the parent of the parent". This is similar to `_parent`, but the link will always open in the full browser tab/window, even for nested embedded frames.

There is a fifth value, called `_unfencedTop`, which is currently used for the experimental FencedFrame API. At the time of this lecture, you probably won't have a reason to use this one yet.

Selecting the right `target` value to control where your users end up is an important consideration when creating a website.


## What Is the Difference Between Absolute and Relative Paths?

### Description

A path is a string that specifies the location of a file or directory in a file system. In web development, paths let developers link to resources like images, stylesheets, scripts, and other web pages. There are absolute and relative paths - both are essential when specifying file locations within a file system. Let's look at the two so you can decide which one of them to use and when.

An absolute path is a complete link to a resource. It starts from the root directory, includes every other directory, and finally the filename and extension. The "root directory" refers to the top-level directory or folder in a hierarchy.

An absolute path also includes the protocol - which could be `http`, `https`, and `file` and the domain name if the resource is on the web. Here's an example of an absolute path that links to the freeCodeCamp logo:

```html
<a href="https://design-style-guide.freecodecamp.org/img/fcc_secondary_small.svg">
  View fCC Logo
</a>
```

In this example, the protocol is `https`, the domain name is `design-style-guide.freecodecamp.org`, and the filename is `fcc_secondary_small.svg`.

Now, what if the resource you want to link to using an absolute path is on your local machine? Here's how to link to the `about.html` file with an absolute path:

```html
<p>
  Read more on the
  <a
    href="/Users/user/Desktop/fCC/script-code/absolute-vs-relative-paths/pages/about.html"
    >About Page</a
    >
</p>
```

It looks like this because we are going into a folder called `Users`, then into a folder called `user`, then into a folder called `Desktop`, then into a folder called `fCC`, then into a folder called `script-code`, then into a folder called `absolute-vs-relative-paths`, then into a folder called `pages` to finally get the `about.html` file.

Here's what the absolute URL looks like in the browser address bar:

```sh
file:///Users/user/Desktop/fCC/script-code/absolute-vs-relative-paths/pages/about.html
```

The URL includes the protocol, `file://`. It also include the path, which looks like this: `/Users/user/Desktop/fCC/script-code/absolute-vs-relative-paths/pages/`, and represents the series of folders that lead to the file. And finally, it also includes the `about.html`, which is the filename and the extension.

Now, lets look at the relative path. A relative path specifies the location of a file relative to the directory of the current file. It does not include the protocol or the domain name, making it shorter and more flexible for internal links within the same website. Here's an example of linking to the `about.html` page from the `contact.html` page, both of which are in the same folder:

```html
<p>
  Read more on the
  <a href="about.html">About Page</a>
</p>
```

So imagine you are on the `contact.html` page, and because the `about.html` page is in the same place, you simply get the filename. This is an example of using a relative file path.

So, which should you use and when; an absolute path or a relative path? Here are the rules you should follow:

- Use absolute paths when linking to a resource hosted on an external website.

- Use absolute paths when you need the link to a page or resource to work consistently regardless of the document location within the site.

- Use relative paths when linking to resources within the same website.

- Use relative paths if you want to keep your code cleaner and easier to maintain during development.

- Use relative paths during local testing to ensure links work without an internet connection.


## What Is the Difference Between Slashes, a Single Dot, and Double Dot in Path Syntax?

### Description

You may have seen links like `/public/logo.png`, `./script.js`, or `../styles.css` before. But what do these special types of links mean? These are called file paths. There are three key syntaxes to know. First is the slash, which can be a backslash (`\`) or forward slash (`/`) depending on your operating system. The second is the single dot (`.`). And finally, we have the double dot (`..`).

The slash is known as the "path separator". It is used to indicate a break in the text between folder or file names. This is how your computer knows that `naomis-files/` points to a directory of that same name, while `naomis/files/` points to a `files` directory in the `naomis` directory.

A single dot points to the current directory, and two dots point to the parent directory. You will typically see a single dot used to ensure that the path is recognized as a relative path. Remember that you learned in a previous lecture about relative versus absolute paths before.

Double dots, however, are much more common to access files outside of the current working directory.

For example, given this file tree:

```sh
my-app/
├─ public/
│  ├─ favicon.ico
│  ├─ index.html
├─ src/
│  ├─ index.css
│  ├─ index.js
```

If your `public/index.html` file needed to load the `favicon.ico` file, you would use a relative path with a single dot to access the current directory: `./favicon.ico`. If your `public/index.html` file needed to load the `index.css` file, you would use a relative path with double dots to navigate to the parent `my-app` directory first, then to the `src` directory, and finally to your file: `../src/index.css`.


## What Are the Different Link States, and Why Are They Important?

### Description

You may have seen a link on a web page become purple after you click it. This is because the state of the link has changed, so different styling gets applied. There are five different states a link can be in.

The first is the default state, which is `:link`. This state represents a link which the user has not visited, clicked, or interacted with yet. You can think of this state as providing the base styles for all links on your page. The other states build on top of it.

The second state is `:visited`, which applies when a user has already visited the page being linked to. By default, this turns the link purple - but you can leverage CSS to provide a different visual indication to the user. This is helpful to let someone know they have already read a portion of your documentation. Or, that the site is one they can trust because they have used it before.

The third state is `:hover`. This state applies when a user is hovering their cursor over a link. This state is helpful for providing extra attention to a link, to ensure a user actually intends to click it.

Then we have `:focus`. This state applies when we focus on a link.

And finally, we have `:active`. This state applies to links that are being activated by the user. This typically means clicking on the link with the primary mouse button by left clicking, in most cases. This state can be helpful for showing a user that the element they clicked on is interactive.

When you use these states to style your links, there is a specific order you need to write your CSS in: `link`, `visited`, `hover`, `focus`, then `active`.

You should now know how to give links in your page your own personal flair, while still providing the important information a user needs about the state of each link.


## Module: Semantic Html


### Lecture Block: Lecture Importance Of Semantic Html


## Why Should You Care About Semantic HTML?

### Description

Semantics are the meaning of words, or phrases, in a language. In HTML, which is a language, elements have their own semantic meaning too. In fact, you can think of your HTML document like you would a text document. And much like a text document, you might have headings, images, bold text, and other formatting.

The semantic meaning of an element refers to what special information that element conveys. The semantic meaning of a `p` element, for example, is a paragraph of text:

```html
<p>
  Let me tell you about my fantastic holiday in Paris.
  I saw the impressive Eiffel Tower up close!
</p>
```

Most elements have semantic meaning. The `div` element is one of the very few that does not. But why is this important?

First and foremost, using proper semantic HTML will ensure the best experience for users with assistive technology like screen readers. But also, semantic HTML can improve your search rankings. This is referred to as search engine optimization, or SEO.

Finally, using correct semantic elements can improve your development experience. Rather than having to sift through a bunch of developments to find your navigation bar, you can edit the `nav` element directly and know what you're changing. Throughout this section, you will learn more about these topics, how to use semantic elements, and why semantic HTML is so important.


## Why is it Important to Have Good Structural Hierarchy?

### Description

The most important aspect of creating a structural hierarchy is the proper use of heading elements. Heading elements are numbered as `h1`, `h2`, `h3`, and so on. These numbers represent the heading level for that element.

Much like a text document, you do not want to use heading levels in the incorrect order. Your `h1` element is your top-level heading. You will rarely have more than one of these on a page, and it should typically come before all of your content.

Your `h2` element is your subheading. It should always come after your `h1` and might come after some introductory text. Unlike an `h1` element, you can have multiple `h2` elements on your page. You'll often do this to delineate different sections of content. 

Following the pattern, your `h3` element should always come after an `h2` element. That is, you should never skip directly from `h1` to `h3`. You can, however, have multiple heading elements at the same level. For example, this code is correct:

```html
<div>
  <section>
    <h1>freeCodeCamp</h1>
    <h2>Learn Front-End Development</h2>
    <h2>Learn Back-End Development</h2>
  </section>
</div>
```

But this code would not be correct, because `h3` comes before `h2`:

```html
<div>
  <section>
    <h1>freeCodeCamp</h1>
    <h3>Learn Front-End Development</h3>
    <h2>Learn Back-End Development</h2>
  </section>
</div>
```

It may be tempting to use a specific heading element because of its styling, such as `h1` for large text:

```html
<article>
  <p>
    Here is some
    <h1>Large Text</h1>
  </p>
</article>
```

Instead, you should choose the appropriate element for your document structure and use CSS to achieve the styling you'd like.

Using the right hierarchy is important for accessibility. Assistive technologies, like screen readers, rely on the structure of a web page to determine how to parse and announce that web page to the user. Using an `h3` element after an `h1` might cause a screen reader user to believe they have accidentally skipped over important content, due to the lack of an `h2` element.

Proper structure is also important for SEO. Search engines use automation to parse the content of your web page and determine when and where it should show up in results. If your structure is malformed, search engines may not be able to rank you very well in the relevant search results.

Finally, depending on how incorrect your structure is, your HTML may not even be technically valid. When this happens, the web browser has to effectively guess what you meant to do. And what it guesses might not even be what you want at all. 

As you have learned today, there are many reasons to use the proper structural hierarchy for your page. Keep this in mind as you build new projects.


## What Is the Difference Between Presentational and Semantic HTML?

### Description

Presentational HTML focuses on the appearance and style of the content. In the early days of HTML, developers would use elements like the `center`, `big`, and `font` elements. But in modern web development you shouldn't use these types of elements, because of their limitations and negative impact on accessibility and maintainability.

Many presentational HTML elements are deprecated, which means that they are outdated and no longer recommended. There are better ways to get the same results. However, it is helpful to know that they exist, so we'll take a look at some examples.

The `font` element is a deprecated element used to set the font size and color of the text. Here's an example of a `font` element:

```html
<font size="5" color="blue">This text is blue and large.</font>
```

This example sets the color of the text to `blue` and the size to a value of `5`. The range for the `size` attribute is from `1` to `7`, with `1` being the smallest and `7` being the largest. The default value is `3`, if you don't set the value explicitly.

While this element still works, you should not use it because the font size and color should always be set in CSS, not in HTML. 

The `center` element is another deprecated element that is used to center the content horizontally within its container. Here's an example of the `center` element that contains text and a paragraph element:

```html
<center>
  This text is centered.
  <p>HTML is awesome.</p>
</center>
```

In the browser, you would see all of the content within the `center` element centered horizontally.

And next, we have the `big` element. This is another deprecated presentational HTML element that makes the enclosed text one level bigger than its surrounding text. Here we have an example that defines a paragraph with two parts:

```html
<p>
  This text has a normal font size.
  <big>This text is larger.</big>
</p>
```

The first part has normal sized text, while the second part enclosed within the `big` element will be displayed in a larger font size. In the browser, you would see the text within the `big` element looks larger compared to the surrounding text.

However, remember that font size should always be set with CSS, so you should not use this element in modern HTML.

These were examples of presentational HTML elements. But all of them are deprecated and no longer recommended. So what should you use instead? Let's see.

Semantic HTML is now the recommended practice. It describes the content of the elements, so it's much easier to read, understand, and maintain.

Search engines can easily understand your website when you use semantic HTML. It's also helpful for accessibility purposes, because screen readers need semantic information to describe what's on the web page.

Examples of semantic HTML elements include:

- The `header` element for defining the header of the document, or section.
- The navigation section element, `nav`, for sections with navigation links.
- The `section` element for grouping related information.
- The `figure` element for illustrations and diagrams.

This is an example of a `header` element that contains a navigation section element:

```html
<header>
  <nav>
    <a href="#">Home</a>
    <a href="#">About</a>
    <a href="#">Contact</a>
  </nav>
</header>
```

The semantic elements clearly show their purpose within the HTML structure. There are many different semantic HTML elements. You will definitely find one that fits the needs of your project.

Great work. Now you know the difference between presentational and semantic HTML: semantic HTML describes the content, while presentational HTML focuses on the appearance.


### Lecture Block: Lecture Understanding Nuanced Semantic Elements


## When Should You Use the Emphasis Element Over the Idiomatic Text Element?

### Description

These elements are very closely related to the concepts of presentational and semantic HTML. The idiomatic text element, `i`, was originally used for presentational purposes to display the text in italics. But now, it is frequently used for highlighting alternative voice or mood, idiomatic terms from another language, technical terms, and thoughts.

Here is example from the official HTML spec, using the `i` element to show an idiomatic phrase in French:

```html
<p>There is a certain <i lang="fr">je ne sais quoi</i> in the air.</p>
```

The `lang` attribute inside the open `<i>` tag is used to specify the language of the content. In this case, the language would be French. The `i` element does not indicate if the text is important or not, it only shows that it's somehow different from the surrounding text.

If you do need to emphasize the importance of the text, you can use a similar semantic element called the emphasis element, `em`. This is usually recommended if you need to provide more context. You should use this element for parts of the text that require a special emphasis compared to surrounding text. It's usually limited to only a few words, because it can alter the meaning of the sentence.

This is an example of the emphasis element within a paragraph:

```html
<p>
  Never give up on <em>your</em> dreams.
</p>
```

You can see the sentence `Never give up on your dreams`. Notice that the word `your` will be emphasized, because it's inside this element. In the browser you would see the word `your` is italicized to tell readers that this is an important word in the sentence.

Even if it looks the same when the text was inside the idiomatic text element, the semantic emphasis element conveys its meaning and importance behind the scenes.

It's important to know that these elements should not be used for presentational purposes only. If you need to display the text in italics, but the text doesn't have a special purpose, style, or meaning in the paragraph, you should use CSS instead.


## When Should You Use the Strong Element Over the Bring Attention To Element?

### Description

The "bring attention to" element, `b`, is commonly used to highlight keywords in summaries, or product names in reviews. Usually, browsers display this text in boldface. Here's an example using the `b` element to highlight product names in this review:

```html
<p>
  We tested several products, including the <b>SuperSound 3000</b> for audio
  quality, the <b>QuickCharge Pro</b> for fast charging, and the
  <b>EcoClean Vacuum</b> for cleaning. The first two performed well, but the
  <b>EcoClean Vacuum</b> did not meet expectations.
</p>
```

The browser renders these parts of the text as bold text. This visual emphasis will draw readers attention to the product names.

If you need to emphasize the importance of the text, you should use the `strong` element instead of the `b` element.

`strong` is a semantic HTML element that emphasizes text that is crucial, or urgent. This is an example where the `strong` element is used to label a very important warning about the potential allergic reactions that customers may have to a product:

```html
<p>
  <strong>Warning:</strong> This product may cause allergic reactions.
</p>
```

The `strong` element communicates that sense of urgency.

Visually both are very similar, because they are both rendered as bold by default. But their meanings are quite different. While the "bring attention to" element only draws attention to the text, without indicating the higher level of importance, the `strong` element does more than that. It conveys a sense of importance, or urgency. This is their main difference. 

To choose between them, consider the purpose of the text and its importance within the surrounding content.


## What Are Description Lists, and When Should You Use Them?

### Description

Description lists are perfect for presenting terms and definitions in an organized and easy-to-read format, like in a glossary, or real dictionary, where you can find words with their corresponding definitions.

This is an example of a description list in HTML with two terms and their corresponding details:

```html
<dl>
  <dt>HTML</dt>
  <dd>HyperText Markup Language</dd>
  <dt>CSS</dt>
  <dd>Cascading Style Sheets</dd>
</dl>
```

In this case the terms are the acronyms HTML and CSS, and the details are their expansions. The details could also be definitions, or other information related to the terms.

You will need three HTML elements to define a description list. First, the description list element, `dl`, which is the container for the entire list. You can see it wraps around all the other elements of the description list in the example.

Then, one description term element, `dt`,  for each term. In this case the description list has two terms, HTML and CSS, so it has two of these elements.

And finally, after each term you will find a description details element, `dd`, for the description, or details associated with that term. In this example, they are Hypertext Markup Language and Cascading Style Sheets.

In the browser, you would see each term followed by its corresponding description. By default, the descriptions are slightly more indented towards the right to distinguish them visually.

But description lists are not limited to only terms and definitions. They are much more versatile than that. Here we have a recipe with two ingredients.

```html
<dl>
  <dt>Flour</dt>
  <dd>2 cups</dd>
  <dt>Sugar</dt>
  <dd>1/2 cup</dd>
</dl>
```

The entire description list is within a description list element. The first ingredient, `Flour`, is within a description term element. Then, you can see how much of this ingredient you will need: `2 cups`. This is within a description details element directly after its corresponding ingredients.

And the same structure is repeated for `Sugar`. In this case, the recipe has only two ingredients, but if there were more the same structure could be repeated throughout the description list.

In the browser, you would see the ingredients aligned to the left, and the measurements indented to separate them visually.

Other use cases for description lists include product specifications, frequently asked questions, contact information, and metadata. Essentially, when you have two related pieces of information in a key-value pair format, where one acts as a label, the key, and the other acts as additional related information, the value, you can use a description list.


### Lecture Block: Lecture Working With Text And Time Semantic Elements


## How Do Block and Inline Quotes Work in HTML?

### Description

In HTML, quoted elements are used to distinguish quoted text from the surrounding content. This gives the quoted text a format that is easy to identify.

You should use the block quotation element for representing a section quoted from another source. It's mainly used for extended quotations. If the source of the quote has an address, you can cite it with the `cite` attribute. The value of this attribute should be a valid URL. This is an example of a quote within a block quotation element:

```html
<blockquote cite="https://www.freecodecamp.org/news/learn-to-code-book/">
  "Can you imagine what it would be like to be a successful developer? To have built software systems that people rely upon?"
</blockquote>
```

This element has a `cite` attribute. The value of the `cite` attribute is the URL of the source. While this attribute doesn't change the presentation of the block quote, it's very helpful for giving screen readers and search engines more information about the quote. In the browser, you'll see that the text is slightly indented.

If you want to start and end the block quote with quotation marks, you may need to write them explicitly within the text. You can write the text directly within the block quotation element, like I just did, or wrap it within one or more paragraph elements. This is helpful when the text has multiple paragraphs, but you want to keep them within the same block quote. Here's an example with four paragraphs:

```html
<blockquote cite="https://www.freecodecamp.org/news/learn-to-code-book/">
  <p>Build your projects. Show them to your friends. Build projects for your friends.</p>
  <p>Build your network. Help the people you meet along the way. What goes around comes around. You'll get what's coming to you.</p>   
  <p>It is not too late. Life is long.</p>
  <p>You will look back on this moment years from now and be glad you made a move.</p>
</blockquote>
```

All the paragraphs are contained within the same block quotation element, so they are part of the same quotation. You can see that the element has a `cite` attribute with the URL of the source. In the browser, you'll see that the four paragraphs are aligned relative to each other, but they are indented relative to their container.

So far I've been using the `cite` attribute to attribute the source of the quotation, but the attribute doesn't really show the source to the user. It only works behind the scenes.

If you want to attribute the source visually, you can add a citation element, `cite`, outside of the block quotation element. This is different from the `cite` attribute. The citation element is an HTML element that you can use to mark up the title of a referenced creative work like a book article, song, film, website, or research paper. Here's an example:

```html
<div>
  <blockquote cite="https://www.freecodecamp.org/news/learn-to-code-book/">
    Can you imagine what it would be like to be a successful developer? To have built software systems that people rely upon?
  </blockquote>
  <p>—Quincy Larson, <cite>How to Learn to Code and Get a Developer Job [Full Book].</cite></p>
</div>
```

The block quotation element contains quoted text. Below the element you can see a paragraph element with the name of the author, followed by a citation element. The citation element contains the title of the book where the quotation came from.

If you go to the browser, now the source will be clearly visible and see that the quote comes from a book written by Quincy Larson. The title of this book is `How to Learn to Code and Get a Developer Job`.

You should use block quotes like these for long quotations from other sources. But sometimes you will only need to quote a few words within a larger paragraph.

That's exactly what the inline quotation element is for. It's for short inline quotations from other sources. Most modern browsers will add quotation marks around the inline quote automatically when you use this element. This is an example:

```html
<p>
  As Quincy Larson said,
  <q cite="https://www.freecodecamp.org/news/learn-to-code-book/">
    Momentum is everything.
  </q>
</p>
```

You can see a paragraph element that contains text. Part of the text is an inline quote, because it's within the inline quotation element. You can also add a `cite` attribute to attribute the source.

This works exactly the same as it did with the block quotation element. There won't be any visual changes, but it will give screen readers and search engines more information about the quote.

In the browser, you'll see that the quoted text is part of the paragraph and it's surrounded by quotation marks. Most modern browsers will add these quotation marks automatically. 

What's the difference between block quotes and inline quotes? You should use block quotes for extended quotations from other sources and inline quotes for short quotations from other sources that should be part of existing paragraphs.


## How Do You Display Abbreviations and Acronyms in HTML?

### Description

An abbreviation is a shortened form of a word. For example, "Dr" followed by a period, is an abbreviation for the word "doctor".

An acronym is a word formed from the initial letters of a phrase, with each letter representing the first letter of a word in that phrase. HTML is an example of an acronym. It stands for HyperText Markup Language.

By taking the first letters of each word H, T, M, and L, you get the acronym HTML. They are both very helpful for writing more concise text, especially when they are well-known and easy to understand in a given context. 

If you need to display abbreviations and acronyms in HTML, the abbreviation element is exactly what you're looking for. You should always explain their full meaning when you use them for the first time. Then you can use the abbreviation element to highlight them and provide more details. 

Here's an example where you can see a paragraph with the sentence `HTML is the foundation of the web`: 

```html
<p><abbr>HTML</abbr> is the foundation of the web.</p>
```

The acronym HTML is within an abbreviation element. In the browser, you'll see that nothing has really changed. It still looks like normal text. The abbreviation element is providing helpful context behind the scenes, but users will still see the acronym as normal text. 

If you want to help users understand what this acronym means, you can show its full form with the `title` attribute.

The `title` attribute is optional, but if you decide to include it, it must be a human readable description of the abbreviation, or acronym.

Let's take the same example as before, but add the `title` attribute. It will be `HyperText Markup Language`, the expanded form of the acronym:

```html
<p><abbr title="HyperText Markup Language">HTML</abbr> is the foundation of the web.</p>
```

Usually, the style of the abbreviation element will change when you add this attribute. The specific style will depend on the browser. Some browsers may display a dotted underline, while others may convert the contents to small caps, or even assign certain default styles, such as a dotted underline. When the user hovers over the acronym with the mouse, the full form is displayed as a tooltip.

While you don't necessarily need to use the abbreviation element for every abbreviation, or acronym on your web page, it's recommended for those that might be unclear and those that might need additional context.

You should use your best judgment to find the right balance between information and presentation to avoid cluttering the text while being clear and concise.


## How Do You Display Addresses in HTML?

### Description

The contact address element is used to represent contact information for a section on a web page. The `address` element is versatile and can be used for business pages, author pages, personal sites, and more.

When it comes to building out your website's contact sections, you should use the semantic `address` element over a generic element like a `div`.

Here is an example of using the `address` element for a company contact page:

```html
<address>
  <h2>Company Name</h2>
  <p>
    1234 Elm Street<br />
    Springfield, IL 62701<br />
    United States
  </p>
  <p>Phone: <a href="tel:+15555555555">+1 (555) 555-5555</a></p>
  <p>Email: <a href="mailto:contact@company.com">contact@company.com</a></p>
</address>
```

In this example, there is the company name, physical address, phone, and email information. For the physical address, the line break element, `br`, is used to show the division between the street name, city, and country.

For the phone number, we have an anchor element with the `href` value set for telephone numbers. The `tel:+` value inside the `href` attribute creates a clickable link to initiate a phone call on certain devices that support that.

For the email address, another anchor element is used with the `href` value set to a `mailto` link. `mailto` links are used in HTML documents to allow users to open a new email within their preferred email client.

One of the downsides of using a `mailto` link is that users often perceive it as spam. Unfortunately, a lot of spammers will use this option to send emails to users. So just keep that in mind when you're using it.


## How Do You Display Times and Dates in HTML?

### Description

The `time` element is used to represent a specific moment in time.

Here is an example using the `time` element to represent twenty hundred hours, or eight PM in the evening.

```html
<p>The reservations are for <time datetime="20:00">20:00 </time></p>
```

The `datetime` attribute is used to translate dates and times into a machine-readable format.

This is important, because it helps with search engine results and helps the browser process date and time information more effectively.

The value for the `datetime` attribute must be either a valid year, valid month, valid time, local date, global date, or valid duration string.

Here is another example of using the time element to represent a particular date:

```html
<p>
  The graduation will be on <time datetime="2024-06-15T15:00">June 15</time>
</p>
```

The value for the `datetime` attribute is in the ISO 8601 format. ISO 8601 is an international standard to represent dates and times.

The first part of that value is the year, month and day. The capital T in the value is a separator between the date and time.

The fifteen hundred hours would be three PM in the afternoon.

Whenever you need to represent events, publication dates, or appointments, it is best to use the `time` element.


### Lecture Block: Lecture Working With Specialized Semantic Elements


## How Do You Display Mathematical Equations and Chemical Formulas in HTML?

### Description

The superscript element is used to display a piece of text as a superscript. A superscript is a symbol or letter printed above the normal line of text.

Here is an example using the superscript element to illustrate exponents:

```html
<p>2<sup>2</sup> (2 squared) is 4.</p>
```

In this example, the number 2 is wrapped in `sup` tags to represent the superscript inside the paragraph. In the browser, you would see that the second number 2 is smaller and slightly higher than the first number 2.

Common use cases for the superscript element would include exponents, superior lettering, and ordinal numbers. Here is an example using the superscript element for superior lettering:

```html
<p>
  Monseigneur is often written as <strong>M<sup>gr</sup></strong>.
</p>
```

Superior lettering refers to letters written in superscript, usually to indicate abbreviations. The letters `g` and `r` are wrapped inside superscript tags to illustrate the abbreviation in this example.

It is important to note that the superscript element should only be used for typographical reasons. If you want style a piece of text with a raised baseline, then you should use CSS instead of the superscript element.

To represent chemical equations inside HTML, you would use the subscript element. This element uses a subscript which displays a lowered baseline using smaller text.

Here is an example of using the subscript element to show the chemical representation for carbon dioxide.

```html
<p>CO<sub>2</sub></p>
```

The number two is wrapped inside `sub` tags to illustrate that the character should be a subscript.

Common use cases for the subscript element include chemical formulas, footnotes, and variable subscripts.


## How Do You Represent Computer Code in HTML?

### Description

The inline code element is used to represent short snippets of code inside text. Common use cases for the code element would be for technical articles and documentation pages.

Here is an example of using the `code` element to show a CSS code snippet:

```html
<p>
  To set the text color to blue in CSS, use the following code:
  <code>color: blue;</code>
</p>
```

In this example, the CSS `color` property is used to set the text color to `blue`. By wrapping this code snippet inside `<code>` tags, it communicates to the browser that the text is a piece of inline code.

The browser will apply default styles for content inside of the `code` element. The default styling is a monospaced font.

The `code` element is meant to represent a single line of code. If you want to represent multiple lines of code, you will need to place a `code` element inside a preformatted text element.

The preformatted text element is used to represent preformatted text. Here is an example of using the preformatted text element to show a CSS declaration:

```html
<pre>
  <code>
    body {
      color: red;
    }
  </code>
</pre>
```

When using the `pre` element, you will need to be mindful of spacing because it will display exactly as written inside the HTML document.

In the browser, you will see that the code is indented several spaces to the right. If you were to change the indentation in the code example, then you will see a difference in indentation on the screen.

When it comes to including code examples inside your HTML document, you should use the `code` element for short inline examples. 

If you need to display longer code snippets, then you will need to use the `pre` and `code` elements.


## What Are the U, S, and Ruby Elements Used For, and How Do They Work?

### Description

The unarticulated annotation element, or `u` element for short, is used to represent inline text that has non-textual annotation applied.

Here is an example of using the `u` element to highlight various spelling errors:

```html
<p>
  You can use the unarticulated annotation element to highlight
  <u>inccccort</u> <u>spling</u> <u>issses</u>.
</p>
```

In the example, the words `incorrect`, `spelling`, and `issues` are misspelled. The default styling for the `u` element is a black underline underneath the text.

In HTML4, the `u` element was used for styling purposes. But in HTML5, the `u` element should only be used to indicate that text has non-textual annotation applied.

If you want to style a piece of text with an underline, you should use CSS instead of HTML.

The strikethrough element, or `s` element for short, should be used to represent when text is no longer accurate or relevant. Here is an example of using the `s` element to show the cancellation of an activity:

```html
<p><s>Tomorrow's hike will be meeting at noon.</s></p>

<p>Due to unforeseen weather conditions, the hike has been canceled.</p>
```

In this example, the first sentence is crossed out because the hike was canceled due to weather reasons.

The `s` element should never be used to just to show changes to a document. More appropriate elements in that case would be the deleted text element and the inserted text element.

The `ruby` element represents small text shown above or below the main text. It is typically used to show the pronunciation of East Asian characters. Here is the `ruby` element example from the MDN web docs page:

```html
<ruby> 明日 <rp>(</rp><rt>Ashita</rt><rp>)</rp> </ruby>
```

The `rp` element, or ruby fallback parenthesis element, is used as a fallback for browsers lacking support for displaying ruby annotations.

The `rt` element, or ruby text element, is used to indicate text for the ruby annotation. This text is usually used for pronunciation, or translation details in East Asian typography.

While the `ruby` element can be used for other types of annotations, the most common use case is for East Asian typography.


## Module: Html Forms And Tables


### Lecture Block: Lecture Working With Forms


## How Do Forms, Labels, and Inputs Work in HTML?

### Description

The `form` element in HTML is used to gather user information, such as names and email addresses. Here is an example of a `form` element:

```html
<form action="url-goes-here">
  <!-- input elements go here -->
</form>
```

The `action` attribute specifies where the form data will be sent upon submission. To collect specific information, like names and email addresses, you would use the `input` element. Here is an example of using an `input` element:

```html
<form action="">
  <input type="text" />
</form>
```

`input` elements are void elements and do not have closing tags. The `type` attribute defines the data type expected from the user. In this case, the data would be plaintext. To add a label for the input, you would use a `label` element. Here is an example of using a `label` element with the text of `Full Name:`:

```html
<form action="">
  <label>
    Full Name:
    <input type="text" />
  </label>
</form>
```

By nesting an `input` inside a `label` element, you create an implicit association between the `label` and the `input` field. The term "implicit" refers to something that is understood or inferred without needing to be explicitly stated or defined with additional attributes or elements. To explicitly associate a `label` with an `input`, you can use the `for` attribute. Here is an example of using the `for` attribute for an email address label:

```html
<form action="">
  <label for="email"> Email Address: </label>
  <input type="email" id="email" />
</form>
```

When using an explicit association, the values for the `for` attribute and `id` need to be the same. In this case, the values are both set to `email`. The `email` type in the input provides basic validation for correctly formatted email addresses. If you want to show additional hints to the users about the expected input, you can use the `placeholder` attribute. Here is an example using the `placeholder` attribute inside the email input:

```html
<form action="">
  <label for="email"> Email Address: </label>
  <input type="email" id="email" placeholder="Ex. example@email.com" />
</form>
```

For the placeholder text, you want to provide helpful short text to show the format and type of data you expect from your users. In this case, the placeholder text, `Ex. example@email.com`, shows the user that they must enter a correctly formatted email address.


## What Are the Different Types of Buttons, and When Should You Use Them?

### Description

The `button` element is used to perform a particular action when it is activated. Here is an example of a `button` element with the button text of `Start Game`.

```html
<button>Start Game</button>
```

Other examples of using the `button` element include submitting a form, showing a modal, or toggling a side menu open and closed. The `button` element has a `type` attribute which controls the behavior of the button when it is activated. The first possible value for the `type` attribute would be the `button` type. Here is an example of using the `button` element with the `button` type and a text of `Show Alert`:

```html
<button type="button">Show Alert</button>
```

By default, the button will not do anything when activated. However, you can add some JavaScript code to make the button interactive, such as showing an alert in this case. Another possible value for the `type` attribute is the `submit` value. Here is an example of using a `button` element with the `submit` type:

```html
<form action="">
  <label for="email">Email address:</label>
  <input type="email" id="email" name="email" />
  <button type="submit">Submit form</button>
</form>
```

Inside this `form` element, there is a `label` and `input` element for the user's email address. When the user clicks on the submit button, their data will be sent to the server and will be processed. The third possible value for the `type` attribute is the `reset` value. Here is an example of a `form` element with reset and submit buttons:

```html
<form action="">
  <label for="email">Email address:</label>
  <input type="email" id="email" name="email" />
  <button type="reset">Reset form</button>
  <button type="submit">Submit form</button>
</form>
```

In this modified example, a `label` and `input` element are used to collect the user's email address. When the user clicks on the reset button, then it will clear out all of their input data. It is important to note that reset buttons are usually not the best idea because they could lead to users accidentally resetting their data. Also, multiple buttons in your form could clutter up the user interface.

Another way to create buttons in HTML is to use the `input` element. The `input` element also has a `type` attribute with the possible values of `submit`, `reset`, and `button`. Here is an example of using the `input` element with the `type` set to `button`:

```html
<input type="button" value="Show Alert" />
```

The `value` attribute is used to show the button text. So, what is the difference between using the `input` and `button` elements? `input` elements are void elements, which means they cannot have child nodes, such as text, and can only have a start tag. On the other hand, the `button` element offers more flexibility because you can nest text, images, and icons inside it.


## What Is Client-Side Form Validation in HTML Forms, and What Are Some Examples?

### Description

When a user fills out a form on your website, it is important that they fill out all of the necessary information in the correct format. HTML form controls, like inputs, have a lot of built-in validation that you can use to check for invalid data. This will help ensure that the user fixes these mistakes before the information is submitted and processed by the server.

The term "client-side" refers to everything that happens on the user's computer or device, like the part of a website or app you interact with directly. This includes the layout, design, and any interactive features.

The term "server-side" refers to everything that happens on the server, the computer, or system, that hosts the website or app. This includes processing data, running applications, and handling requests that come from the user's device.

While client-side validation is important, you also need server-side validation for added security. Malicious users can bypass client-side checks, so robust server-side measures are essential. You'll learn more about this in a later module. For now, let's take a look at some examples of client-side form validation.

One common example of built-in form validation is to use the `required` attribute in inputs. The `required` attribute specifies that the user needs to fill out that portion of the form before it gets submitted. Here is an example of using the `required` attribute in an email input:

```html
<form action="">
  <label for="email">Email Address (Required field):</label>
  <input required type="email" name="email" id="email" />
  <button type="submit">Submit Form</button>
</form>
```

When the user clicks on the `Submit Form` button without supplying an email address, they will be alerted that the field is required and the form will not be submitted. Each browser will have its own set of styles for showing this alert message.

Another advantage of using the email input, is that email inputs have some basic validation to ensure correctly formatted email addresses. For example, if you type in random words and click submit, then the browser will show an alert that an `@` sign is missing. It is important to note that browsers only check for basic validation for standard email addresses. It is up to you to add additional layers of validation, which you will learn about in later modules.

Other forms of validation for email inputs are to use the `minlength` and `maxlength` attributes. Here is an example using the extra validation:

```html
<form action="">
  <label for="email">Email Address (Required field):</label>
  <input
    required
    type="email"
    name="email"
    id="email"
    minlength="4"
    maxlength="64"
  />
  <button type="submit">Submit Form</button>
</form>
```

The `minlength` and `maxlength` attributes are used to set the minimum and maximum length in characters for the email input. If you don't include the minimum length or exceed the max length of characters, the browser will show an alert message.


## What Are the Different Form States, and Why Are They Important?

### Description

In HTML, form controls, like inputs, can be in different stages or conditions like a `focused` state, `readonly` state, or `disabled` state.

The first state would be considered the `default` state. The default state of an email address input is a blank input. That is what the email input looks like when it is first rendered on the page. At this point, the user has not input any information.

When the user clicks on a form control or selects it with the keyboard's tab key, then that means it is in the `focused` state. When an input is in the `focused` state, most browsers will show a blue highlighted border around the input. But you can choose to add additional styles in CSS.

Another form state is the `disabled` state. This state shows users that an input cannot be focused or activated. To disable an input, you can add the `disabled` boolean attribute to the element like this:

```html
<input disabled type="email" name="email" id="email" />
```

If the user tries to click on the input, then the focus will not be enabled. Similar to the `focused` state, you can choose to add additional styles for the `disabled` state using CSS.

Another type of form state is the `readonly` state. This is when a form control, like an input, is not editable by the user. Here is an example of setting an email input to read only:

```html
<input
  readonly
  type="email"
  name="email"
  id="email"
  value="example@email.com"
/>
```

The `value` attribute is used to set the value shown inside the input field. If you tried to click on the input, you would not be able to edit the existing value.

A key difference between the `disabled` state and `readonly` state is that `readonly` can be focused while the `disabled` state cannot.

Understanding the different form states is important because they ensure a smooth user experience by providing clear feedback and guidance while handling errors.


### Lecture Block: Lecture Working With Tables


## What Are HTML Tables Used For, and What Should They Not Be Used For?

### Description

HTML tables aren't used as much these days as they used to be. But, as a frontend developer, you should still be familiar with them. Tables are one of the earliest ways devs had for displaying data in a browser way back in the 1990s.

Here's an example of code used to generate a table from the U.S. Bureau of Labor Statistics:

```html
<table id="quickfacts">
  <thead>
    <tr>
      <th colspan="2">Quick Facts: Software Developers, Quality Assurance Analysts, and Testers</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2023 Median Pay</th>
      <td>
        $130,160 per year
        <br>$62.58 per hour
      </td>
    </tr>
    <tr>
      <th>Typical Entry-Level Education</th>
      <td>Bachelor's degree</td>
    </tr>
    <tr>
      <th>Work Experience in a Related Occupation</th>
      <td>None</td>
    </tr>
    <tr>
      <th>On-the-job Training</th>
      <td>None</td>
    </tr>
    <tr>
      <th>Number of Jobs, 2022</th>
      <td>1,795,300</td>
    </tr>
    <tr>
      <th>Job Outlook, 2022-32</th>
      <td>25% (Much faster than average)</td>
    </tr>
    <tr>
      <th>Employment Change, 2022-32</th>
      <td>451,200</td>
    </tr>
  </tbody>
  <tfoot>
    <tr>
      <th>If this table had a footer it would be here.</th>
    </tr>
  </tfoot>
</table>
```

As you can see, there's a main `table` element with an `id` set to `quickfacts`. Inside it, the table has a table head element, `thead`, table body element, `tbody`, and a table foot element, `tfoot`.

The table head, body, and foot elements can each contain some number of table rows, `tr`. And each table row can contain a table header `th` which labels the data in that row. It can also contain some number of individual data cells, called table data, `td`.

Now, that's a lot of HTML elements. But don't be intimidated – these follow a simple hierarchy.

Here's the simplest table we can create that includes all of these elements:

```html
<table>
  <thead>
    <tr>
      <th>The title of this table</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>First Row</th>
      <td>
        First Data Cell
      </td>
    </tr>
    <tr>
      <th>Second Row</th>
      <td>
        Second Data Cell
      </td>
    </tr>
  </tbody>
  <tfoot>
    <tr>
      <th>The footer of this table, which might contain date of publication, author credits, or other meta information.</th>
    </tr>
  </tfoot>
</table>
```

So as you can see, the data itself is always within a `tr` – and within that `tr` element is a `th` element with a header, and a `td` element with data.

Some websites will choose to use `div`s to build their own tables instead of using the more appropriate `table` element.

While it is possible to display tabular data using generic `div` elements, it is still better to use the `table` element instead.

Many years ago, developers might have used a `table` to position non-data elements on a webpage. This was never considered a best practice. But you may encounter some codebases where tables are still used like this.

Nowadays, developers use CSS flexbox and grid to layout their designs. freeCodeCamp will cover these tools in depth later.

For now, just use HTML tables for their original intended purpose: displaying tabular data.


### Lecture Block: Lecture Working With Html Tools


## What Is an HTML Validator, and How Can It Help You Debug Your Code?

### Description

HTML is a very forgiving language – elements still render even when you make mistakes, like forgetting to include a closing tag.

Let's say you have an `h2` element without a closing tag:

```html
<h1>Article Topic</h1>
<h2>Subheading 1 </h2>
<h2>Subheading 2 </h2>

<!-- This h2 does not have a closing tag -->
<h2>Subheading 3
```

The `h2` without a closing tag will still render fine. This happens because browsers use a parsing algorithm that handles common errors and tries to render HTML as closely as possible to the author's intention.

But this could backfire sometimes. Let's add a few paragraphs under the existing heading 2 tags in the code:

```html
<h1>Article Topic</h1>
<p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Maiores, nisi.</p>

<h2>Subheading 1 </h2>
<p>Lorem, ipsum dolor sit amet consectetur adipisicing elit. At, doloremque.</p>

<h2>Subheading 2 </h2>
<p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Unde, placeat.</p>

<!-- This h2 does not have a closing tag -->
<h2>Subheading 3
<p>Lorem ipsum dolor, sit amet consectetur adipisicing elit. Tempore, illum.</p>
```

As a result, the paragraph element under the `h2` without a closing `h2` tag renders as heading 2. This is why you need an HTML validator.

An HTML validator is a tool that checks the validity of your HTML code against the standard HTML specifications. It helps you identify errors and warnings in your HTML code, ensuring your web pages are correctly structured and compliant with web standards.

Using an HTML validator benefits not only you and your future code reviews, but also anybody else going through your code, such as your teammates and open-source contributors.

There are several HTML validators out there you can use. The most widely accepted one is the `w3.org` markup validation service.

When you visit the site [`validator.w3.org`](https://validator.w3.org/), you can click on the `Validate by Direct Input` button and paste in your HTML code.

When you click on the `Check` button, then a list of results will display with the errors that need to be fixed.

Another HTML validator that you can use is [`jsonformatter.org`](https://jsonformatter.org/).

You can copy and paste your HTML code inside the first editor, and when you click on the `Validate` button, it will show you any errors you have in your code.


## How to Use the DOM Inspector and DevTools to Debug and Build Your Projects

### Description

When you are building out your projects, you will frequently run into issues where your programs are not working as expected.

Programmers often refer to issues as bugs. The process of finding and fixing these bugs is known as debugging.

To debug your code, you will need to use some tools provided by your browser.

Two important tools to use would be the DOM inspector and developer tools.

The DOM inspector allows you to inspect the HTML structure of the page you are on.

The DOM stands for Document Object Model. It is a tree-like structure that represents the elements on a page. You will learn more about the DOM in later modules.

The developer tools allow you to inspect the HTML, CSS, and JavaScript of the page you are on.

Let's take a look at an HTML example that contains a small bug in the anchor element:

```html
<a href="https://www.freecodecamp.org/larn/">freeCodeCamp curriculum</a>
```

When you click on the link, it will lead to a 404 page. A 404 page is an error page that appears when a user tries to access a webpage that doesn't exist on the server.

The intent is for the link to lead to the freeCodeCamp curriculum.

To see what the issue might be, you can use the developer tools.

To open the developer tools in your browser, you can right-click on the page and select `Inspect`.

You can also use `Control Shift I` on your PC keyboard or `Command Option I` on your Mac.

When you open developer tools in Google Chrome, you'll see a number of tabs. The first tab is called the `Elements` tab. This tab shows you the HTML structure of the page you are on.

The second tab is called the `Console` tab. This tab shows you any errors that might be occurring on the page.

In the situation where you have a broken link, you can check the console to see the error messages for that broken link. The common message that continues to display for the broken link is the 404 error. The 404 error indicates that the page is not found.

This lets us know that the issue is with the URL in the anchor element. When you inspect the `href` value you will see there is a typo.

Right now the console message shows `/larn` against a 404, but the correct URL should be `/learn`. When the link is corrected, then it will work as expected.

You will learn more about working with the developer tools throughout the certification, but this is just a short example on how it can help you debug your code.


## Module: Html And Accessibility


### Lecture Block: Lecture Importance Of Accessibility And Good Html Structure


## What Is Accessibility?

### Description

Accessibility involves creating products and services that everyone can use. In the context of web development, it's making websites that everyone can understand and interact with, including people with visual, auditory, motor, and cognitive disabilities.

Some examples of disabilities that can impact users' online experience include:

- Blindness.
- Low vision.
- Color blindness.
- Deafness.
- Difficulty using keyboards, mice, or touchscreens.
- Attention disorders
- Memory issues.
- Difficulty speaking or understanding spoken language.
- Sensitivity to flashing lights.

These are just a few of many conditions that can impact users around the world.

To help you create accessible websites, the World Wide Web Consortium, known as W3C, developed a set of international standards that you can follow to make your websites more accessible and easier to use for people with disabilities.

These standards are known as "The Web Content Accessibility Guidelines" (WCAG).

These guidelines are designed with four core principles in mind, known as **POUR**.

- `P` stands for Perceivable. Users must be able to perceive the information that you are presenting. For example, you can provide alternative text for images, so users who access your website with a screen reader can understand them.
- `O` stands for Operable. Users must be able to interact with the user interface. For example, you can make sure that all functionality is accessible through the keyboard too, not just the mouse.
- `U` stands for Understandable. Users must be able to understand the information. For example, you can avoid complex sentences and use simple language as much as possible.
- `R` stands for Robust. A wide range of browsers and other tools, including assistive technologies, must be able to interpret the content. 

Using semantic HTML is very helpful for making your website compatible with different browsers and assistive technologies.

If your content doesn't follow any one of these core principles, not everyone will be able to use your website.

To check if you are following these guidelines correctly, you can access the Quick Reference of the World Wide Web Consortium. There, you will find a comprehensive list of criteria and techniques.

Accessibility is essential for web development. By developing with inclusivity in mind, you can ensure that everyone can access and engage with your content, promote equality and create a better user experience for everyone around the world.


## What Are Screen Readers, and Who Uses Them?

### Description

Screen readers are assistive technology programs that help blind and visually impaired people use computers and mobile devices.

Screen readers are not just tools for the blind and visually impaired to access computers and mobile devices.

They empower these individuals to access education, work opportunities, and social media. This ensures digital inclusion and enhances their ability to participate fully in society.

There's a common misconception that screen readers are text-to-speech devices.

However, text-to-speech is just one of the features of a screen reader. Some screen readers even render the text to braille output instead of speech.

Apart from text-to-speech and braille output, other notable features of screen readers are navigation aids and web browsing assistance.

Screen reader programs are also not only made for the blind and visually impaired. Dyslexic individuals and people with cognitive disabilities also use screen readers. All the popular operating systems out there have screen readers built into them.

macOS and iOS both have VoiceOver built-in. You can turn it on on your computer by pressing `CMD + F5`. You can access it on iPhones through Settings.

Windows computers have Narrator built-in. You can turn it on by pressing `WIN + CTRL + ENTER`. NonVisual Desktop Access (NVDA) and Job Access With Speech (JAWS) are also available for Windows computers. NVDA is free and open-source, while JAWS is paid.

Linux has _Orca_ for the desktop environment and _Speakup_ for the Linux terminal.

Android phones have TalkBack built-in. You can turn it on by accessing _Settings > Special Function > Accessibility > Talkback._

Some Android devices also have Ella and Select to Speak built in.

One major challenge for screen reader users is that many software developers don't design their products with screen-reader friendliness and accessibility in mind.

Even though accessibility is a broad topic, every developer needs to learn how to make their web software accessible for the blind and visually impaired, as well as other groups of people with disabilities.

This demonstrates empathy and a commitment to inclusivity, ensuring that all users can benefit from their work.


## What Are Large Text or Braille Keyboards, and Who Uses Them?

### Description

Large text and braille keyboards are designed for users with visual disabilities. In Large Text Keyboards, also called Large Print Keyboards, the letters, numbers, and symbols are larger compared to standard keyboards. This design is helpful for people who may find smaller text in the keys difficult to see. Most of them also have enhanced contrast and brightness.

A large print keyboard made by the brand MaxiAids has yellow keys with black, big, and bold letters, numbers, and symbols on them. This is helpful for people with low vision.

Another keyboard is the black large print keyboard with white print on the keys. This keyboard is also backlit, so users can adjust its brightness to different lighting conditions.

While large print keyboards provide visual cues for users with low vision, braille keyboards provide a completely tactile experience for people with more severe vision disabilities, including people who are blind.

Braille is a tactile reading and writing system. It consists of raised dots arranged in specific patterns to represent letters, numbers, and punctuation.

Braille keyboards use this system to help users find the right keys on the keyboard by feeling these patterns with their fingers. The keys have raised dots in patterns that represent letters, numbers and symbols.

And some keyboards combine both approaches- large fonts and braille patterns in the keys. This is helpful for people with visual disabilities and for people who are learning braille.

Large text and braille keyboards are tools that empower people with visual disabilities. By providing alternative input methods, these assistive technologies ensure that everyone can be part of the digital world.


## What Are Alternative Pointing Devices Such as Trackballs, Joysticks, and Touchpads Used For?

### Description

Alternative pointing devices are input devices that make good alternatives to the traditional mouse. They are essential for improving computer accessibility for those with disabilities, forelimb impairments, and limited mobility.

Common examples of alternative pointing devices are trackballs, joysticks, and touchpads.

A trackball is a stationary pointing device that consists of a large, movable ball within a socket. It also includes additional buttons for clicking and performing other functions.

Unlike the traditional mouse, which requires movement around a surface to control the cursor, a trackball remains in place. Users manipulate the ball directly with their fingers, thumb, or palm to move the cursor on the screen.

Some traditional mice also have a trackball on the top or side. These mice could make a good starting point if you want to gradually switch to a trackball.

Trackballs reduce the physical movement the user needs for navigation, making them ideal for users with mobility issues. 
Apart from that, if you need high precision and have limited desk space, a trackball is more ideal than a traditional mouse.

A joystick is a pointing device primarily designed for games and certain industrial applications like machinery control. It consists of a lever that pivots up, down, left, and right, and often includes additional buttons for various actions

Joysticks provide precise control over movement and actions within digital environments. This makes them popular for flight simulators, cranes, driving games, and other applications requiring precise directional input.

Because joysticks accommodate larger and more deliberate movements, they are beneficial for individuals with tremors and unsteady hands.

They also reduce the strain and pain that comes with repetitive movements, making them ideal for individuals with arthritis and carpal tunnel syndrome.

A touchpad is a flat, touch-sensitive device built into laptops and some keyboards. It allows users to control the cursor on the screen by sliding their fingers across its surface.

Apart from the surface for cursor control, touchpads also feature buttons that emulate the actions of a traditional mouse, such as right-click and left-click.

Most people see touchpads as a better alternative to a mouse because they significantly enhance navigation by supporting multi-touch gestures like pinch-to-zoom, two-finger scrolling, tap-to-click, and three-finger swipes.

Touchpad is ideal for individuals with low arm or hand movement because the forelimb is almost always stationary while using it. It is also suitable for people with arthritis and joint pain because they don't get to move their arms too much.


## What Are Screen Magnifiers Used For?

### Description

Screen magnifiers are tools that help people with low vision and other visual impairments better access digital content and the web.

Let's delve deeper into what these tools are and the role they play in digital content accessibility.

Screen magnifiers work by enlarging texts, graphics, and other elements on a computer or mobile device screen. Many screen magnifiers allow users to enlarge the display by more than 200%. Users can then navigate the page using their pointing device or keyboard. Additionally, most magnifiers offer customizable zoom percentages and other features in their settings.

Screen magnifiers primarily help people with low vision read text, as small fonts in documents or applications can be challenging for them. By enlarging the text, they can read emails, articles, and other content without straining their eyes. Screen magnifiers also assist with web browsing. They help users locate and click on buttons, links, and other interactive elements that might be difficult to see. This improved visibility ensures that users can browse websites, fill out forms, and engage in online activities without difficulty.

Therefore, software developers need to make their digital products accessible to people with low vision. Some considerations include:

- Using scalable fonts so the user can resize the page without the layout breaking.
- Ensuring the user interface adapts to different screen sizes through responsive design.
- Using high-contrast color schemes and customizable colors.
- Implementing a non-sticky and tiny navbar so users can still see content when using magnifiers.
- Using regular HTML text instead of images of text.
- Providing feedback directly next to the element that triggers it, and more.

All the mainstay Operating Systems have at least one magnifier built into them by their manufacturers:

- macOS and iOS both have Zoom. You can turn it on on Mac by going to Settings, filter by Accessibility, and then click on "Zoom". Toggle the "Use keyboard shortcuts to zoom" option to enable it.
  - You can turn it on on iPhone through _Settings > Accessibility > Zoom_.
- Android devices have Magnification. To turn it on, go to _Settings > Special Function > Accessibility> Magnification_. Since this may vary from device to device, you can search for "Magnification" on the settings homepage to access it.
- Windows has Magnifier. You can use it by going to _Settings > Ease of Access > Magnifier_.
- The magnifiers for Linux operating systems vary. It is either Zoom or Magnifier.

Apart from the ones built into operating systems, some useful third party screen magnifiers are:

- ZoomText for Windows.
- ClaroView for both Mac and Windows.
- iZoom for Windows.
- Zoomify - Screen Magnifier for Mac.
- LunarPluse for Windows.
- Loupe for Mac.


## What Is Voice Recognition Software Used For?

### Description

Voice recognition software helps people with disabilities interact with computers and other digital devices. Let's discuss what voice recognition software is and the role it plays in digital inclusion.

In the context of accessibility, voice recognition tools let people with disabilities use their voice to pass commands to perform various tasks instead of using traditional input devices like keyboards and mice. This includes writing emails and other documents, surfing the net, and controlling smart home devices.

Because voice recognition software tools eliminate the need for physical interaction, they empower people with disabilities with significant independence and control over their environment. 

Here are the specific people who may find voice recognition software significantly helpful:

- People with visual impairments, including those with low-vision or blindness.
- Individuals with mobility impairments, such as limited use of hands and arms or conditions like arthritis and carpal tunnel syndrome.
- Those recovering from hand or arm injuries.
- Individuals with cognitive disorders, like memory issues or attention deficit disorders.
- Elderly individuals who might find it easier to use voice commands.

Note that people with disabilities are not the only ones who use voice recognition technology. Law enforcement agencies, gamers, drivers, and busy professionals also use voice recognition tools.

A few examples of voice recognition software that allows people to interact with their computer include Voice Control for macOS/iOS, Voice Access for Android, and Windows Speech Recognition for Windows (referred to as Voice Access in the most recent versions of Windows). Dragon by Nuance is a popular third-party voice recognition software for Windows.


## What Are Some Common Accessibility Auditing Tools to Use?

### Description

Accessibility is a crucial yet often overlooked aspect of digital content. When making your digital content accessible, it's important to ensure it meets accessibility standards.

An accessibility auditing tool is an application that helps you improve the accessibility of your digital content by reporting accessibility issues that can be easily found through automated testing. This content includes websites, web applications, and mobile apps.

It is important to note that while automated accessibility tools have a role in improving accessibility, they typically will only find about a third of all possible accessibility issues. Therefore, it is important not to rely on them entirely to evaluate the accessibility of your content. Manual testing, preferably by people with disabilities, will always be required to ensure that your content is as accessible as possible.

Let's look at some free tools that can help you improve the accessibility of your digital content.

Google Lighthouse is a popular web metric checker you can use directly within Chrome DevTools or online. This means you can check not only live websites but also locally-developed ones.

The metrics you can check include accessibility, SEO, best practices, and performance.

To use Lighthouse, open your DevTools by pressing `F12` and switching to the Lighthouse tab.
Select the metrics you want to check, choose the device you want to test on, and click the "Analyze page load" button.

An accessibility score will appear after the check is complete, along with a list of any issues that need fixing.

If you want more reliable metrics, consider using the web version. The downside is that it doesn't support testing local websites. You can access the web version on `pagespeed.web.dev`.

WAVE is another reliable accessibility checker you can use as a Chrome extension or on the web. All you need to do is enter the URL of your website and a comprehensive accessibility report will be generated for you. This report includes accessibility features implemented, ARIA, and contrasts.

The IBM Equal Accessibility Checker is another robust tool for improving digital content accessibility. With it, you can scan your websites for accessibility issues and generate a detailed report.

You can use it as a Chrome extension or Firefox add-on.

To use the IBM Accessibility Checker as a Chrome extension, download it from the Chrome web store. Open your Devtools by pressing `F12` and selecting the "Accessibility Checker" tab located in the Elements panel. Click the scan button to start the check and a report will be generated for you. You can export the report as a spreadsheet and an HTML file by clicking the "Export XLS" button.

Please keep in mind, while these automated tools help you make your content more accessible, a perfect score from any of them does not mean that your content is entirely accessible. The range of issues that these tools test for is limited, and manual testing will always be needed to ensure a more accessible experience for everyone.


## How Does Proper Heading Level Structure Affect Accessibility?

### Description

You previously learned about proper heading level structure. Now, you will learn how a good heading structure affects accessibility.

Proper use of headings creates a visual hierarchy for users to navigate and understand your web page. Using a logical heading hierarchy allows screen reader users to understand the structure of your content and navigate your content quickly. Creating appropriate heading text that accurately describes the content that follows helps everyone find the information they need on your site. As an additional benefit, well-formed headings may also improve the SEO of your site.

Think of headings as the foundation of your site. Without a good foundation, the accessibility of your content will suffer.

Let's look at how you can make your web projects friendly for people who use assistive technologies by using headings correctly.

Headings, ranging from `h1` to `h6`, create a navigational structure for screen reader users. Screen readers can list all headings on a page, allowing users to jump directly to the sections they need. So, correctly arranging headings is important for helping these users avoid unnecessary content and finding the information they are looking for quickly.

People with partial sight or cognitive disabilities need to process information quickly and easily to reduce cognitive load.

While proper arrangement of headings is important, it is also necessary to make heading texts clear and descriptive.

Here are some key practices to follow to use headings properly:

- Use headings in a hierarchy that reflects clear organization. For example, the page title should be an `h1`, major sections should be introduced with `h2` headings, subsections with `h3` , and so on, down to `h6`.
- Don't skip from `h1` to `h3`, or from `h2` to `h4`, and so on.
- Use clear and descriptive text that summarizes the content that follows each heading.
- Don't use a heading in isolation – some content must follow the heading.
- Use appropriate headings where necessary instead of formatting text to look like headings.
- Each page should have a single `h1` element representing the main topic or title.

Here's a basic markup that represents how you should use headings on a page:

```html
<!-- Page title -->
<h1>What is HTML</h1>

<!-- First section -->
<section>
  <h2>Introduction to HTML</h2>
  <p>
    HTML stands for HyperText Markup Language. It is the standard language for
    creating web pages.
  </p>
</section>
<!-- Second section -->
<section>
  <h2>History of HTML</h2>
  <p>HTML began to take shape in the early 90s</p>
  <h3>Origins</h3>
  <p>
    HTML was created by Tim Berners-Lee in 1991. It has evolved significantly
    over the years.
  </p>
</section>
```


### Lecture Block: Lecture Accessible Tables Forms


## What Are Best Practices for Tables and Accessibility?

### Description

When we see a table, we immediately start making visual associations between the data and the headers.

For example, let's say we have a table representing our pets. We have two dogs and two cats and the table is showing us their names and ages. While a sighted person may be able to understand the relationships in this table, making the connections between the values and the headers is much harder for people who use screen readers to navigate the table.

As a web developer, you are in charge of creating these associations and structuring your HTML markup in a way that is also easy for screen reader users to interpret.

So, let's see how you can create accessible tables that everyone can understand. The first best practice that we will cover is using table caption. With the `caption` element, you can write the caption (or title) of a table, so users, especially those who use assistive technologies, can quickly understand the table's purpose and content. You should place the `caption` element immediately after the opening tag of the `table` element. This way, screen readers and other assistive technologies can provide more context by announcing the caption before reading the content.

```html
<table>
  <caption>Our Pets</caption>
  <!-- Table Rows and Columns -->
</table>
```

Now let's talk about row and column headers. Headers are special cells, typically found at the start of a row or column, that describe the type of data stored in the row or column. You can define a row or column header with the table header element, `th`.

For example, the code below creates a table for two pets. Every row has a row header (the name of the pet) and every column has a column header, which describes what the data in the column represents (age and type).

```html
<table>
  <caption>Our Pets</caption>
  <thead>
    <tr>
      <!-- Column Headers -->
      <th>Name</th>
      <th>Age</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Nora</th> <!-- Row Header -->
      <td>5</td>
      <td>Dog</td>
    </tr>
    <tr>
      <th>Gino</th> <!-- Row Header -->
      <td>2</td>
      <td>Cat</td>
    </tr>
  </tbody>
</table>
```

Notice that the above code has a `caption` element immediately after the opening `table` element. Then, inside the table head (`thead`) element, it has the column headers (`Name`, `Age`, and `Type`). In the second and third rows, inside the table body (`tbody`) element, we find the data for each one of our pets. The names of the pets are the row headers because they are inside table header elements (`th`).

Associating the data cells with their corresponding headers is also very important for screen readers. The `scope` attribute determines if a header is a row header or a column header.
Screen readers may guess this correctly from the table's structure, but it's usually recommended to explicitly indicate the `scope` to ensure clarity.

The `scope` attribute has four possible values. The two you will use most often are `col` for column and `row` for row.
In the code below, you can see that we added the `scope` attribute to the column and row headers. The three column headers (`Name`, `Age`, and `Type`) have a `scope` of `col`, column.

The two row headers (`Nora` and `Gino`) have a `scope` of `row`.

```html
<table>
  <caption>Our Pets</caption>
  <thead>
    <tr>
      <!-- Now they have scope -->
      <th scope="col">Name</th>
      <th scope="col">Age</th>
      <th scope="col">Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th scope="row">Nora</th>
      <td>5</td>
      <td>Dog</td>
    </tr>
    <tr>
      <th scope="row">Gino</th>
      <td>2</td>
      <td>Cat</td>
    </tr>
  </tbody>
</table>
```

If a column or row header spans across multiple cells, the `scope` will also be applied to each one of the cells individually. Here's an example of that:

<table>
  <tbody>
    <tr>
      <td></td>
      <th scope="col">Name</th>
      <th scope="col">Age</th>
    </tr>
    <tr>
      <th rowspan="2" scope="row">Dogs</th>
      <th scope="row">Nora</th>
      <td>5</td>
    </tr>
    <tr>
      <th scope="row">Gino</th>
      <td>2</td>
    </tr>
    <tr>
      <th rowspan="2" scope="row">Cats</th>
      <th scope="row">Lulu</th>
      <td>10</td>
    </tr>
    <tr>
      <th scope="row">Elizabeth</th>
      <td>6</td>
    </tr>
  </tbody>
</table>

In this table, the cell with `Nora`'s age (`5`) will have one column header (`Age`) and two row headers (`Dogs` and `Nora`). `Gino`'s age (`2`) will also have one column header (`Age`) and two row headers (`Dogs` and `Gino`).

However, some screen readers may not be able to interpret tables with complex structures, so you should also try to flatten the table as much as possible to avoid row and column headers that span across multiple cells.

Your goal should always be to make sure users can access this information, even if their screen readers can handle complex table structures.

Now, for cell width, it's recommended to avoid using fixed values. You should use relative values instead, like percentages. Also, try to avoid defining cell height. This will allow users to adjust the text size to fit their needs.

And finally, you should let the browser determine the table width whenever possible, to reduce the need for horizontal scrolling.

HTML tables are essential for presenting structured data in an accessible and understandable format. By following these accessibility guidelines, you can create tables that are easy to understand for everyone.


## Why Is It Important for Inputs to Have an Associated Label?

### Description

Labels on input fields might seem like small details, but they play a crucial role in making forms easier for everyone to use.

Labels help people with disabilities, make forms more user-friendly for everyone, and ultimately improve form conversion rates.

Let's dive into why adding labels to input elements is important for accessibility and usability.

Screen readers often rely on labels to describe the purpose of input fields. In order for this to work properly, the label must be programmatically associated with the `input`. While there are several ways to do that, the most common is to use the HTML `label` element.

Here's how to associate a `label` with an `input`:

```html
<form>
   <label for="name">Your Name</label>
   <input type="text" id="name" />
</form>
```

In this example, the `for` attribute of the `label` element is associated with the `id` of the `input` element. This connection allows screen readers to announce the `label` when the `input` is in a focused state, allowing screen reader users to understand the purpose of the `input`.

Associating labels with all input fields also benefits SEO.  With proper labels, search engines will understand the page content better, leading to a positive impact on the page search rankings.

But it is important to understand that you're making content for humans, not search engines. So, you should make sure the labels are as clear and descriptive as possible.


### Lecture Block: Lecture Introduction To Aria


## What Is the Purpose of WAI-ARIA, and How Does It Work?

### Description

Making static content accessible can be relatively straightforward, but dynamic content can be more challenging. This is where WAI-ARIA comes in.

Let's look at what WAI-ARIA is, its purpose, how it works, and some examples.

WAI-ARIA stands for Web Accessibility Initiative - Accessible Rich Internet Applications. It's a specification that enhances accessibility for dynamic content and UI (User Interface) components.

Note that WCAG and WAI-ARIA are not the same. WCAG provides general guidelines for web accessibility, while WAI-ARIA offers specific rules for making dynamic and interactive content accessible for users of assistive technologies.

So, the primary purpose of WAI-ARIA is to improve accessibility for dynamic content and UI components that do not have native HTML equivalents.

WAI-ARIA works by introducing a set of attributes you can add to HTML elements to provide additional semantic information. These attributes are categorized into roles, states, and properties.

ARIA role defines the purpose of an element within a website or web app. Here is an example of setting the role to `button` for a `div` element.

```html
<div role="button">Click Me</div>
```

By doing this you are indicating to assistive technology that the element is a button. Roles do not provide any functionality however. Merely giving this `div` a `role` of `button` will not make it act like a button. To make it look and behave like a button you would need to use CSS and JavaScript to get the desired result. It is always better to use the native `button` or `input` element with `type="button"` instead.

ARIA properties provide additional details about elements. For example, the `aria-labelledby` property lets you connect an element to a specific label:

```html
<h2 id="header-id">About freeCodeCamp</h2>
<button id="button-id" aria-labelledby="header-id button-id">Learn More</button>
```

This will make the elements understandable and navigable for users of assistive technologies.

To get the best out of WAI-ARIA, try to stick with native HTML whenever possible since it generally provides more accessibility out of the box.

Use WAI-ARIA only when HTML falls short, and don’t forget to test with assistive technologies like screen readers, or have people with disabilities test your work. Also, make sure your WAI-ARIA states and properties update with the content in real time. Avoid overusing ARIA as it can be confusing many times.


## What Are ARIA Roles?

### Description

ARIA stands for Accessible Rich Internet Applications.

ARIA roles specify the semantic meaning of HTML elements. They're essential for making web content accessible to people who use assistive technologies, like screen readers.

HTML has semantic and non-semantic elements, based on whether they convey meaning about their content.

Many semantic HTML elements already have an ARIA role assigned by default. For example, the `button` element has a default ARIA role of `button`. 

But non-semantic elements don't have a role. For example, screen readers will not know how to interpret the purpose of a `div` if you don't specify its role explicitly.

To specify the ARIA role of an element, you just need to add the `role` attribute, like this `role="ARIA role"`, where value is the name of a role in the ARIA specification.

It is important to note that specifying a role on an element only does one thing: It informs assistive technology of the purpose of the element. It does not add any functionality or behavior to the element. If people expect a role to behave a certain way, it is up to you, the developer, to add that expected behavior. For example, adding a `role` of `button` to a `div` does not automatically make it clickable with a mouse or usable with a keyboard. It is the responsibility of the developer to add the expected behavior that allows the `div` to act like a button, and in most cases, it is just better to use the `button` element.

There are six main categories of ARIA roles:

- Document structure roles
- Widget roles
- Landmark roles
- Live region roles
- Window roles
- And Abstract roles

Let's take a look at them in more detail.

Document structure roles define the overall structure of the web page. With these roles, assistive technologies can understand the relationships between different sections and help users navigate the content.

However, most of the document structure roles are not used in modern web development because browsers already support equivalent semantic HTML elements, which should be prioritized whenever possible.

You should specify the roles that don't have an equivalent semantic element. For example: `toolbar`, `tooltip`, `feed`, `math`, `presentation`, `none`, and `note`.

There are other similar roles but these are the most commonly used ones. This is an example of a `div` with the `math` ARIA role. The `div` contains a mathematical equation.

```html
<div role="math" aria-label="x squared + y squared = 3">
  x<sup>2</sup> + y<sup>2</sup> = 3
</div>
```

You'll also notice that the `div` has an `aria-label` attribute. The value of this attribute should be a string that represents the expression.

Widget roles define the purpose and functionality of interactive elements, like scrollbars.

Examples of widget roles include `scrollbar`, `searchbox`, `separator` (when focusable), `slider`, `spinbutton`, `switch`, `tab`, `tabpanel`, and `treeitem`.

Some of these roles have equivalent semantic elements. You should prioritize the semantic element over the role if there is one. For example, you should favor using the HTML `button` element over adding a `role` of `button` to a `div`.

Landmark roles classify and label the primary sections of a web page. Screen readers use them to provide convenient navigation to important sections of a page. You should use them sparingly to keep the overall layout simple and easy to understand. Examples of landmark roles are `banner`, `complementary`, `contentinfo`, `form`, `main`, `navigation`, `region`, and `search`. Each of these roles has a corresponding HTML equivalent, such as `header`, `footer`, `aside`, `form`, `main`, `nav`, `section`, and `search`. If you use the proper HTML elements to define the sections of your page then it is not necessary to explicitly add the `role` attribute to these elements.

Live region roles define elements with content that will change dynamically. This way, screen readers and other assistive technologies can announce changes to users with visual disabilities. These roles include: `alert`, `log`, `marquee`, `status`, and `timer`.

Window roles define sub-windows, like pop up modal dialogues. These roles include `alertdialog` and `dialog`. Please note that it is now considered a best practice to use the HTML `dialog` element and its associated JavaScript methods instead of manually creating a dialog.

And finally, we have abstract roles. These roles help organize the document. They're only meant to be used internally by the browser, not by developers, so you should know that they exist but you shouldn't use them on your websites or web applications.

With ARIA roles, you can create accessible and inclusive websites and web applications. They provide semantic information about the purpose and function of HTML elements.

Screen readers and other assistive technologies use this information to help users understand the content of your page and set expectations for how to use it, which helps ensure  that everyone can have a great user experience.


## What Are the Roles of the aria-label and aria-labelledby Attributes?

### Description

It is important to make sure that all users, including those living with disabilities, can access websites without issues.

For people using screen readers, the `aria-label` and `aria-labelledby` attributes provide crucial information about page elements that might be unclear or invisible.

Let's look at what the `aria-label` and `aria-labelledby` attributes are and the roles they play in making the web accessible to people with visual impairments and related disabilities.

You'll notice both `aria-label` and `aria-labelledby` are prefixed with aria. So what does that mean? ARIA stands for Accessible Rich Internet Applications. It's a set of attributes prefixed with `aria-`, which lets developers communicate the purpose of elements to assistive technologies. The `aria-label` attribute is an invisible label for interactive elements. It adds a text label to an element that screen readers can read.

`aria-label` is especially useful for elements that do not have visible text but still need to be described by screen readers. For example, buttons with only icons often need `aria-label` to convey their purpose.

Here is an example:

```html
<button aria-label="Search">
  <i class="fas fa-search"></i>
</button>
```

In this case, a screen reader may announce this button as `Search, button`, even though the button only contains an icon. The `aria-label` attribute tells screen readers what text to use in place of the icon.

If the button contained the text "Search" instead of an icon, then there would be no need for the `aria-label` attribute as the text would provide the label for the button.

For input elements, the `aria-label` attribute provides a label directly if there isn't a visible label associated with the input.

The `aria-labelledby` attribute does the exact same thing as the `aria-label` attribute, but instead of defining the text directly in the attribute, you use a reference to text that already exists on the page. The existing text must have an `id` attribute, which will be used for the reference value in the `aria-labelledby` attribute.

Here's an example:

```html
<input type="text" aria-labelledby="search-btn">
<button type="button" id="search-btn">Search</button>
```

In this case, the text for the button is being used as the label for the search input. Screen readers will announce the input as something like `Search, edit`. If you later decide you want to change the button text to `Find`, the label for the input will automatically be updated to the new text since it is referencing the button text.
Combining multiple `id` values into a single `aria-labelledby` attribute value is also possible. Here's how that works:

```html
<div>
  <span id="volume-label">Volume</span>
  <span id="volume-details">Adjust the volume level</span>
  <input
    type="range"
    min="0"
    max="100"
    value="30"
    aria-labelledby="volume-label volume-details">
</div>
```

For the slider, the screen reader will look out for the content of the `volume-label` and `volume-details` elements and announce `Volume Adjust the volume level`.

You've seen that both `aria-label` and `aria-labelledby` attributes help screen readers understand what elements do. So, which one should you use? Since they both provide the same functionality, either can be used, but there may be a few advantages to using `aria-labelledby` over `aria-label`:

- If someone is using a translation service to translate the content on your page, the text in an `aria-label` attribute may not always be translated. 
- Using `aria-labelledby` can also help prevent a mismatch between the visible label text and the invisible label for screen reader users since updating the visible text will automatically update the invisible label. 
- `aria-labelledby` can make it much easier to programmatically create complex invisible labels consisting of multiple sources of text.

One last note, do not use `aria-label` and `aria-labelledby` on an element at the same time. In this case, the invisible label for screen readers will always be determined by `aria-labelledby` and `aria-label` will be completely ignored.


## What Is the aria-hidden Attribute, and How Does It Work?

### Description

If you ever need to display content while at the same time hiding it from people who use assistive technology, like screen readers, you can use the `aria-hidden` attribute.

You just need to add it to the HTML element that you want to hide and set its value to `true`, like you can see over here: `aria-hidden="true"`.

This attribute hides the element and all of its children from the accessibility tree, while keeping them visible on the page. Common use cases include:

- Icons and images that only have a decorative purpose.
- Duplicated content.

It is important to remember that `aria-hidden` only hides content from assistive technology, such as screen readers. If the content should be hidden from everyone, then you should not use `aria-hidden` to hide it. For example, a hamburger menu that is currently collapsed must be hidden from all keyboard users, not just screen reader users. In this case you could set the CSS `display` property to `none` on the menu to remove it from the DOM when it is collapsed.

You should never use `aria-hidden` to hide an element that is focusable with the keyboard. The `aria-hidden` attribute only removes the element from the accessibility tree. It does not remove it from the DOM. Thus, it will still be possible for screen reader users to tab to the element, but their screen reader will not announce the element, effectively causing them to focus on "nothing".

Here's an example where we hide an icon from the accessibility tree by adding the `aria-hidden` attribute with a value of `true`.

We only keep the text exposed to assistive technologies to avoid any confusion that may arise from the redundancy of having both an icon and text for the same purpose.

```html
<button>
  <i class="fa-solid fa-gear" aria-hidden="true"></i>
  <span class="label">Settings</span>
</button>
```

You do not need to use `aria-hidden` when:

- The HTML element already has a `hidden` attribute.
- The element or the element's ancestor is already hidden with `display: none`.
- The element or the element's ancestor is already hidden with `visibility: hidden`.

In these three cases, the element is already removed from the DOM and thus hidden from the accessibility tree, so the `aria-hidden` attribute is not necessary.

As with using any ARIA attributes, you should always test with assistive technologies, and preferably having people with disabilities test your work, to make sure that it's easy to understand, even with these hidden elements.

You should also know that setting `aria-hidden` to `false` will not expose the element to assistive technologies if any of its parents has this attribute set to `true`.

The `aria-hidden` attribute is used to hide elements from people who use assistive technology, such as screen reader users.

While it can be helpful for hiding purely decorative elements and duplicated content, it should be used sparingly to avoid hindering accessibility.

In general, all content and functionality available on the page should also be available to people using assistive technology. The use case for `aria-hidden` is very narrow and should be limited primarily to making the experience cleaner for screen reader users by removing purely decorative or duplicate information. Do not use `aria-hidden` to hide content that you don’t think screen reader users would be interested in. Screen reader users deserve to have access to all information on the page.

By following these best practices and testing the user experience, you can create inclusive online experiences for everyone.


## What Is the aria-describedby Attribute, and How Does It Work?

### Description

The `aria-describedby` attribute is used to provide additional information about an element to screen reader users by referencing existing content on the page. It creates a programmatic association between the element and the content (technically referred to as an accessible description), which screen readers can use to inform users of the additional information when they interact with the element. 

The most common use for `aria-describedby` is to associate instructions and error messages with form inputs. Due to the various methods screen reader users have for navigating a page, they may miss these messages when navigating between inputs. Using `aria-describedby` helps ensure that they will hear them.

Let's take a look at a few examples to understand how it works. In this first example, we have a `form` element that accepts a password:

```html
<form>
  <label for="password">Password:</label>
  <input type="password" id="password" aria-describedby="password-help" />
  <p id="password-help">Your password must be at least 8 characters long.</p>
</form>
```

We are using a `label` element for the `Password` text and associating that with the password `input` field.

We also have a paragraph element that describes the password requirements. We are using the `aria-describedby` attribute to associate the password `input` field with the password requirements in the paragraph element. When a screen reader user interacts with this `input`, their screen reader will announce the name of the `input` (`Password`) and may then also announce the password requirements. This is not an absolute guarantee however as some screen readers may not automatically announce the additional content, or may only announce it in specific circumstances. This is not uncommon. Each screen reader is different and handles ARIA attributes in their own way. This does not negate the use of `aria-describedby`, as it will benefit screen reader users in general.

Another good use case for the `aria-describedby` attribute is when you have a delete `button`. Here is an example of a delete `button` followed by a message describing what will happen when the button is clicked:

```html
<button aria-describedby="delete-message">Delete</button>

<p id="delete-message">Warning! All deletions are permanent.</p>
```

Just like in the earlier example, we associate the delete button with the message using the `aria-describedby` attribute. The `id` value and the value of the `aria-describedby` attribute must match. 

The `aria-describedby` attribute is a powerful attribute that can be used to help ensure that additional information about an element is provided to screen reader users when they interact with the element. It is most commonly used to associate instructions and error messages with form inputs in order to reduce the chance that screen reader users will miss these messages as they navigate the form.


### Lecture Block: Lecture Accessible Media Elements


## When Is the alt Attribute Needed, and What Are Some Examples of Good Alt Text?

### Description

Alternative text, often abbreviated as `alt` text, is a brief text description of an image. It provides essential information about the image for users who cannot see it, such as people who use screen readers and other assistive technologies.

It's essential for making websites accessible to people with visual disabilities.

Alternative text is also used by search engines to understand images. Some browsers may also display it when an image is not loaded properly. This can happen when the image file is missing or when the user has connectivity issues. So it's helpful for many different purposes.

A person with a visual disability will not be able to know what's in the image unless it's described in the alt text.  An example of bad alt text for an image of a puppy would be "A cute puppy." This text is not specific enough to convey the important details of the image, like what does the puppy look like? Where is the puppy? Are there any important objects around the puppy?

Let's improve this. An example of good alternative text would be: "A black and white puppy with an orange collar lies on its belly in the sand, looking off to the side. A bright orange ball rests near its front paws."

Here you can see this in HTML with an image element, the `alt` attribute, and a more detailed description:

```html
<img src="puppy.png" alt="A black and white puppy with an orange collar lies on its belly in the sand, looking off to the side. A bright orange ball rests near its front paws." />
```

It is important to note that there is no one correct way to write alt text for an image. What you include in your description will depend on the context the picture is used in. For example, if the puppy picture was on a website about dog breeds, you might want to include more specifics about the physical description of the puppy and possibly ignore the fact that the puppy is at the beach playing with an orange ball. Ultimately, the `alt` text you use for an image should reflect the primary purpose for including the image on the page, and the information you provide should give people who can't see the image the necessary details to understand that purpose.

Here we have another example of a beautiful tropical resort. Let's describe it.

An example of bad `alt` text for this image would be "Resort."

This is too short and it doesn't provide enough information about the image. To improve this description, you could expand it to include the most important elements of the image:

"Tropical resort featuring a swimming pool surrounded by palm trees and bungalows."

You can use the alt attribute in HTML like this:

```html
<img src="resort.png" alt="Tropical resort featuring a swimming pool surrounded by palm trees and bungalows." />
```

Now that you know what makes good and bad `alt` text, let's see some of the best practices.

- You should try to keep `alt` text short. It should be detailed enough to understand the image but not so long that it becomes confusing.
- You should not try to describe every little detail. Focus on the most important aspects of the image.
- Generally, you don't need to start with "image of" or "picture of." You can just start the description directly.
- Also, if there's similar text around the image, you don't need to write it again.
- It's usually recommended to end the alt text with a period for consistency.
- If the image is a link to another page, instead of describing the image itself, the `alt` text should describe what will happen if users click on it.

For example, if your website has a right arrow icon that takes the user to the next page, instead of writing an alt text that only says "right arrow", like in this example, where you can see the alt attribute with this description:

```html
<a href="about.html">
  <img src="arrow-right.png" alt="Right arrow." />
</a>
```

You should write something like this instead, where the `alt` text describes what will happen if users clicks on the image. They will go to the next page.

```html
<a href="about.html">
  <img src="arrow-right.png" alt="Go to next page." />
</a>
```

Only images that convey important information should have `alt` text. If an image is only used for decorative purposes, it should have `null` (empty) `alt` text, so it can be ignored by screen readers and other assistive technologies.

Here is an example of an empty `alt` attribute is empty:

```html
<img src="decorative_image.jpg" alt="" />
```

Every image on your website should have an `alt` attribute, even if it's empty. If you omit the `alt` attribute completely, some screen readers will read the file name instead, which can be distracting for people who use assistive technologies, so this is not recommended.

Finally, before your website is live, you should carefully test if screen readers can read the `alt` text correctly.

Writing effective `alt` text is essential for creating accessible web content. As a web developer, by providing clear descriptions of your images, you can make sure that everyone can engage with your website in an inclusive online experience.


## What Are the Accessibility Benefits for Good Link Text, and What Are Examples of Good Link Text?

### Description

Let's take a look at the benefits of writing good link texts in the context of accessibility, and some examples of good link texts.

The first visible benefit of a good link text is that it makes it easier for everyone to find information quickly. Descriptive links help users know where they're headed and what they'll access. This ensures the user doesn't feel lost and improves the overall user experience.

For those using screen readers, a clear and descriptive link text is a must. Screen readers read the link text aloud, so a text like "Read our accessibility guide" is way better than "Click here."

Making link text clear and descriptive isn't just beneficial for those living with visual impairments. Descriptive links also help people with cognitive disabilities by providing clear context.

Here are some best practices to keep in mind while writing link texts:

- Make sure links are visually distinct by using underlining and other visual cues, so users can easily identify and navigate them.
- Avoid generic link texts like "here", "click here", and "more-info" as they don't provide any useful information.
- Aim for concise and descriptive link texts, ideally between 2-5 words, that convey the link's purpose.
- Avoid jargon and abbreviations that users may not understand.
- Focus on the destination, not the action. For example, "user behavior results", instead of "click here to read more".
- Don’t repeat the same link text for different destinations.
- Place links in a way that they make sense within the surrounding text. For example, "for more details, visit our events page" instead of "Click here for more".

Here are some examples of good link texts for specific use cases, compared to less helpful ones.
Let's say you want to link to a page providing details about an event like this:

```html
<a href="webinar-details-link">Details</a>
```

`Details` is vague and doesn’t provide specific information about what the user will find if they click the link. Without additional context, users might not know if the link leads to details about a webinar, a product, a policy, or something else.

Now, here is an example of good link text:

```html
<a href="webinar-details-link">
  Get details about our upcoming webinar
</a>
```

This link text gives users context about the content they will find, making it easier to decide whether they want to click on it. It reduces ambiguity by specifying that the link is related to a webinar.

Here is an another example linking to a post in a blog:

```html
<a href="/blog-post-link">Read more</a>
```

The link text `Read more` is not ideal in terms of accessibility because it lacks context.

Here is a better link text example:

```html
<a href="/blog-post-link">
   Read our latest blog post on web accessibility
</a>
```

This updated link text provides users with a clearer idea of what to expect and why they might want to click the link, which is particularly important for those using screen readers.

Let's take a look at one more example. Let's say you want to provide more information about a certain topic:

```html
<a href="/link-to-topic">More info</a>
```

`More info` is also vague and can be problematic for accessibility. It doesn't provide specific details about the link's destination, which can be confusing for users relying on screen readers or those who might be navigating the site in a non-linear way.

Here is a better example for link text:

```html
<a href="/link-to-topic">
   Learn more about our accessibility efforts
</a>
```

This updated link text is better because it clearly describes what the user will find if they click the link. Users can immediately understand that the link leads to information about your accessibility efforts.


## What Are Good Ways to Make Audio and Video Content Accessible?

### Description

Multimedia, especially video, has become the go-to format for sharing information online.

With this surge in content, there's a growing need to ensure everyone can access and enjoy video and audio content online, irrespective of their abilities or environment.

Making your audio and video content accessible isn't just a nice-to-have, it's essential for reaching a wider audience. Let's look at some inexpensive ways to make your video and audio content more accessible.

A video is not just about visuals but also audio, so the first thing you should consider doing is adding captions or subtitles to your video content.

Captions provide the text version of spoken words and important non-verbal sounds, like music or laughter, synchronized with the video. 

Subtitles on the other hand are essential for people who don't understand the language you're speaking. This helps not only people who are deaf or hard of hearing but also those watching videos in noisy or quiet environments.

To add captions or subtitles to your video or audio content, you can use the `track` element inside your `video` or `audio` element:

```html
<!-- Video -->
<video controls src="video.mp4">
  <track
    src="captions.vtt" 
    kind="captions"
    srclang="en"
    label="English" 
  />
</video>

<!-- Audio -->
<audio controls src="audio.mp3">
  <track
    src="captions.vtt"
    kind="captions"
    srclang="en"
    label="English"
  />
</audio>
```

The `kind` attribute is used to tell the track element how it should be used. Valid values for the `kind` attribute include `captions`, `subtitles`, `chapters`, and `metadata`.

The `srclang` attribute represents the language for the `track` content. The `label` attribute is a descriptive title for the text track that browsers use to identify and display it in the list of available text tracks.

Another important thing to consider is providing a transcript for your audio and video content. A transcript is a text version of all the spoken words in your audio or video. Unlike captions, transcripts don’t need to be synchronized with the media. Transcripts are useful for deaf people and those hard of hearing. They're also beneficial for people who prefer reading instead of watching or listening. Transcripts also make your content searchable, allowing users to quickly find specific parts of your audio or video. If you have a video or audio on a website, you can simply add the transcript below the audio or video:

```html
<audio controls>
  <source src="audio.mp3" />
  Your browser does not support the audio element.
</audio>

<!-- Transcript -->
<h3>Transcript</h3>
<p>
  [Speaker 1]: Welcome to the tutorial on making accessible content
</p>
<p>
  [Speaker 2]: Today, we'll cover captions, transcripts, and more.
</p>

<!-- Rest of transcript -->
```

If you're publishing videos on a video-sharing platform like YouTube or Vimeo, they have automatic captions and transcripts for videos. But if you're not satisfied, you can use services like veed.io, Rev, Amara, and Descript.

Other ways to make your video and audio content accessible include:

- Adding a sign language overlay for videos for deaf people and those hard of hearing.
- Providing volume and speed controls.
- Ensuring good contrast for on-screen text.
- Offering multiple formats.


## What Are Some Ways to Make Web Applications Keyboard Accessible?

### Description

Many users rely on keyboards instead of mice due to physical disabilities, repetitive strain injuries, or personal preference. This includes users of screen readers and those who may not have a working mouse.
Keyboard accessibility ensures these users can navigate web applications effectively without barriers.

Let's look at some practical techniques you can employ to make web applications keyboard accessible.

Many users rely on the `Tab` key to move through interactive elements on a webpage. By default, browsers let users tab through elements like links, buttons, and form fields in the order they appear in the HTML. This is called the natural tab order.

Sometimes, you may want to adjust which elements are focusable or change their focus order. The `tabindex` attribute allows you do this.

Here is the basic syntax:

```html
<element tabindex="number">Element Text</element>
```

The value of `tabindex` determines how the element behaves in keyboard navigation:

- `tabindex="0"`: Adds the element to the natural tab order. For example:

  ```html
  <button>First</button>
  <div tabindex="0">Second</div>
  <a href="#">Third</a>
  ```

  Tabbing will move focus from the `button` to the `div`, then to the link, following their order in the HTML.

- `tabindex="-1"`: Makes an element focusable programmatically. This is useful for managing focus in elements that are not normally focusable, such as headings, containers, dialogs, or error messages:

  ```html
  <p tabindex="-1">Sorry, there was an error with your submission.</p>
  ```

  In this example, the paragraph is not part of the normal tab order, so users cannot reach it by pressing the `Tab` key. However, if you set focus to this element via a script, the message will be brought to the user's attention. You'll learn more about this technique in JavaScript lectures.

- `tabindex` greater than `0`: Sets a custom tab order, so elements with lower positive values are focused first:

  ```html
  <input tabindex="2">
  <input tabindex="1">
  <input tabindex="3">
  ```

  In this example, tabbing will focus the `input` with `tabindex="1"` first, then `2`, then `3`, regardless of their order in the HTML.

Custom positive values are sometimes used in complex widgets, such as a toolbar where you want a specific navigation order. However, this approach is discouraged because it can make navigation confusing and hard to maintain, especially as the page grows or changes.

`accesskey` is another attribute you can use to make your web project keyboard accessible. It allows you to define a key that focuses on or activates a particular element:

```html
<button accesskey="s">Save</button>
<button accesskey="c">Cancel</button>
<a href="index.html" accesskey="h">Home</a>
```

In the above code:

- `accesskey="s"` assigns the key `S` to the `Save` button. On most browsers, pressing `ALT + S` (on Windows) and `CTRL + Option + S` (on Mac) will activate this button.
- `accesskey="c"` sets the key `C` to the `Cancel` button, allowing users to activate it using `ALT + C` (Windows) and `CTRL + Option + C` (Mac).
- `accesskey="h"` assigns the key `H` to the `Home` link, allowing users to navigate to the homepage using `ALT + H` (Windows) and `CTRL + Option + H` (Mac).

Please note that the exact key combination to activate the accesskey might vary depending on the browser and operating system. It's typically `ALT + Specified Key` on Windows and `CTRL + Option + Specified Key` on Mac.

Another way to make the keyboard accessible in your apps is to make sure you provide clear focus indicators. If you feel the default browser focus indicator is not enough, you can override it by targeting the focus state of the element.

Here is an example of styling the focus state for an HTML element:

```css
element:focus {
  outline: 2px solid #005fcc;
}
```

The `outline` property is used to define the outline around the element. This example sets the outline to a solid blue line with 2 pixels set for the thickness. The focus indicator should be styled in a way that makes it obvious which element currently has focus. In order to be accessible, the indicator must have a minimum color contrast of at least 3:1 with the background color it covers. 

You should also avoid keyboard traps, which occur when a user cannot move focus away from a certain element in components like modals and popups.


## Module: Review Html


# Chapter: Css


## Module: Computer Basics


### Lecture Block: Lecture Understanding Computer Internet And Tooling Basics


## What Are the Basic Parts of a Computer?

### Description

Computers are very powerful machines that perform a variety of tasks like writing documents, playing games, and browsing the internet.

As a developer, it is important to understand the basic inner workings of a computer.

The first major component of a computer would be the motherboard. The motherboard holds all the memory and connectors that are needed to run the computer. It serves as the main circuit board for the computer.

Inside the computer case of the motherboard, you will find the CPU which stands for Central Processing Unit. The CPU is a processor that is responsible for executing instructions and performing calculations. It is often referred to as the brain of the computer.

The CPU is a small square with a chip that goes into the motherboard's CPU socket. The CPU processor speed is measured in gigahertz (GHz) and mega-hertz (MHz). Gigahertz is a billion cycles per second and mega-hertz is a million cycles per second.

The next critical component of a computer would be the system's short term memory. This is known as RAM or Random Access Memory. RAM is a temporary storage location for the computer's CPU. Anytime the computer needs to access data quickly, it will use RAM.

The more RAM you have on your computer, the faster it will run and the more programs you can run at the same time. If you are running low on RAM, your computer will run slower and you will notice the difference in performance.

It is important to note that RAM is volatile memory. This means that it is lost when the computer is turned off. This is why it is important to save your work on your computer.

When you do save your files, they are stored on the hard drive. The hard disk drive, or HDD, is a permanent storage location that is used to store data even when the computer is turned off. This is where all your files and software are stored.

The hard drive is made up of a spinning platter and an arm. The platter is where the data is stored and the arm is used to read and write data to the platter. When you have a faster hard drive, your computer will boot up faster and your programs will run faster.

Another type of data storage would be the Solid State Drive, or SSD for short. SSD is non volatile flash memory and can be used in place of a hard drive. SSDs are faster and smaller than hard drives but hard drives are cheaper and have more storage capacity.

Another key component of a computer is the power supply unit, or PSU. The PSU is responsible for converting the electricity from the wall outlet into a form that the computer can use. It sends the power from the outlet to the motherboard, CPU, and other components of the computer.

Another key component would be the expansion cards. These cards are inserted into the motherboard to add additional functionality to the computer. Examples of expansion cards would be the video card, sound card, and network card.

The video card, also known as the Graphics Processing Unit or GPU, is responsible for rendering visuals on the computer screen.

The sound card is responsible for playing sound on the computer speakers.

The network card is responsible for connecting the computer to the internet.

Even though there are many more parts to the computer, these are some basic parts that you should familiarize yourself with now.


## How Can You Effectively Work With Your Keyboard, Mouse, and Other Pointing Devices

### Description

Many of you have been used to working with your keyboard and mouse for years on end for a variety of activities like gaming, performing tasks for work, or surfing the web.

But prolonged misuse of these devices can lead to serious health problems down the road.

In this lecture, we will cover ways to work with your computer’s keyboard and mouse in healthy ways.

The first tip is to be mindful of the mouse grip. When working on serious tasks for work or during intense gaming moments, you may tend to grip the mouse too hard. However, this can lead to serious hand and wrist issues. To prevent this, you want to make sure to hold the mouse gently and keep your fingers nice and relaxed.

The second tip is to consider using an ergonomic keyboard and mouse. These tools are designed to reduce wrist strain by keeping your hands in a more natural position.

While prices for these devices can vary and may be a costly purchase for your current budget, they can be a good investment in your overall long-term health. So, you might consider starting to research an ergonomic keyboard and mouse to use.

Another tip is to keep your mouse the same height as your keyboard. You don't want to have to reach up or down to use the mouse, as this can strain your wrist and arm muscles over time.

You also want to be mindful of your overall posture when sitting at the computer for hours on end. Being slouched over your computer and putting your wrist in an unnatural position at the keyboard will lead to long-term health issues. So, you want to make sure to sit up straight when working at your computer and maintain a healthy and natural wrist position.

The last tip would be to use keyboard shortcuts whenever possible to help minimize typing. There are dozens of shortcuts available for tasks such as navigating the web, navigating around your operating system, working within a code editor, and more. So, it’s best to research some of these keyboard shortcuts and and start incorporating them into your daily computer usage.

As you continue using your mouse and keyboard for upcoming coding projects and other activities, remember to keep these health tips in mind.


## What Are the Different Types of Internet Service Providers?

### Description

First, what is an internet service provider, or ISP? It’s a company that sells access to the global internet network, essentially. And they come in three different tiers.

The first tier are the giant conglomerate companies, which have the infrastructure to handle most (if not all) of their network traffic independently.

The second tier are the country-wide providers, which sometimes rent access to tier 1 networks but can stand fairly well on their own.

The third tier are the small companies that primarily focus on providing internet to local markets, and rely on larger ISPs to provide their infrastructure.

These providers will offer different types of connections as well.

Fibre optic connections rely on glass or plastic fibres to transmit data via light, resulting in very high connection speeds and data exchange.

Cable connections use the same infrastructure as a cable television provider, which often makes them readily available in many regions.

DSL connections use the infrastructure that landline phone services use. Because of the prevalence of this infrastructure, DSL is available in areas where cable might not be. But it is also frequently a slower option.

Dial-up also uses the phone lines, but requires exclusive connection (disabling the use of the line for phone purposes when connected to the internet). This is a much older technology that has fallen into disuse.

Satellite connections use an array of satellites orbiting the earth to connect various devices across the world. And finally, similar to that, a 5G home internet provider uses the cell tower infrastructure to keep you online.

And that should give you a basic rundown of what types of internet service providers and internet connections are out there!


## What Are Safe Ways to Sign Into Your Computer?

### Description

Many of you have being using computers for a while. But you might not have thought about the safest or most secure ways to sign into your computer.

Whether you are using a Mac or PC, there are many ways to safely sign into your computer.

The first thing you should do is to make sure that your computer is password protected.

For Windows users, start by opening the Start menu and selecting Settings. From there, go to Accounts and then Sign-in options. You can then set up a password for your computer.

*Note: If you encounter any difficulties or are using a different version of Windows, refer to the official Microsoft documentation or support resources for detailed instructions tailored to your specific version.*

When creating your password, make sure it is a long and complex password. You can use a combination of letters, numbers and special characters to make it more secure.

Choosing an easy password like `12345` or `password` is not a good idea. These are easy to guess and can be easily hacked.

Also, do not use passwords based on personal information like your name, birthday, or address. Those are also easy for hackers to guess.

When you create your password, it is also a good idea to setup two-factor authentication (2FA). 2FA serves as an extra layer of security and requires a second form of verification to ensure that the person trying to access the account is indeed the authorized user.

If you are a Mac user, you can click on the Apple menu and then go to system settings. From there you can go to Users & Groups and set up a password for your computer.

Some Mac computers come with a touch ID feature, which is often considered more secure than regular passwords. This feature allows you to sign into your computer using your fingerprint.

For Windows users, the Windows Hello feature offers a more secure way to sign in. It uses biometric methods such as facial recognition or fingerprints for authentication, providing an alternative to traditional passwords.

After you finish this lecture, I urge you to look into these additional security features and set them up on your computer so that you can keep your computer safe and secure.


## What Are the Different Types of Tools Professional Developers Use?

### Description

Professional developers rely on a variety of tools to increase productivity and code quality. Let's learn about those tools, including the ones that seem very obvious.

The first among the tools is computers. A computer is the primary development environment. It could be a heavy desktop or a portable laptop with either Windows, macOS, or Linux as the operating system.

Professional developers often go for computers with fast processing power and plenty of RAM to handle resource-intensive tasks.

After the computer is a program for writing and editing code right on that computer. That's a code editor or integrated development environment (IDE).

IDEs like Visual Studio, IntelliJ IDEA, JetBrains, and PyCharm provide powerful features like code completion, debugging, and integrated terminal support.

Visual Studio Code (VS Code) is essentially a code editor, but it also provides these functionalities with its rich extension library.

Other code editors are Sublime Text, Atom, Notepad++, and Brackets.

When you write code with code editors and IDEs, you need to track the changes you make to them. The tool that lets you track those changes is a version control system.

Git is the most widely used version control system in the development community.

Platforms like GitHub, GitLab, and Bitbucket provide cloud-based hosting services for your Git repositories. These platforms enable collaboration with other developers, allow you to work on multiple branches, and facilitate the merging of code changes.

Package managers are another critical tool. They help developers simplify the process of adding, updating, and removing libraries and project dependencies.

Examples of popular package managers are:

* NPM, Yarn, and PNPM for JavaScript
* PIP for Python
* Composer for PHP
* Maven for Java

After writing code with different tools, developers test that code to make sure it's working as expected.

For this, developers use testing frameworks like Cypress, Playwright, Selenium, and others. There are also language-specific testing frameworks. Examples are:

* Jest for JavaScript
* pytest for Python
* JUnit for Java
* PHPUnit for PHP

You don't only need to test the code to make sure it's working as expected. You also need to test what the code looks like visually to the end users. Developers use web browsers for this.

Modern browsers like Chrome, Firefox, Edge, and Safari offer developer tools for inspecting HTML, CSS, and JavaScript code. There are also tools for debugging and performance profiling.

These tools help developers test and optimize their web applications across different browsers for the end users.


### Lecture Block: Lecture Working With File Systems


## How Can You Use File Management Applications on Your Computer?

### Description

A file management application is a way to easily store, organize, and edit your files on your computer. Whether you use a Mac or Windows computer, there are built-in applications you can use to organize your files.

If you have a Windows computer, the default file manager is the File Explorer. This is used to browse, search, and manage files and folders, as well as perform file operations like copying, moving, and deleting.

To find the File Explorer, you can go to the Start menu or press the Windows logo key on your keyboard.

To pin a folder, you can right click with your mouse and select "Pin". To move a file or folder, you first need to select it, then select "Cut" and then navigate to the new location to paste it.

If you have a Mac computer, the default file manager is the Finder. This provides access to local and remote files, supports file previews, and offers a variety of organizational features like tags and Smart Folders.

To access the Finder on your Mac, go to the Dock at the bottom and click on the Finder icon.

You will notice a sidebar on the left-hand side where your favorite folders are located.

One way to organize your files, is to use tags. To tag a file or folder, you can select the item in the Finder and then right click with your mouse. You will see the "Tags..." option in the dropdown and you can apply a custom colored tag.

To search for tagged items, you can scroll to the bottom of the sidebar and click on the corresponding colored tag, or you can search for the tag by color name in the search field.

Another way to organize your files is to use smart folders. Smart folders are collections of files that are automatically organized based on criteria you set, such as file type, date, or keywords.

Whether you're using File Explorer on Windows or Finder on Mac, these applications provide flexibility to manage your files with features like tags, search, and Smart Folders.


## What Are Best Practices for Naming Files for Web Applications?

### Description

As you start to build out your own web applications, you will need to be mindful of what you name your files.

You will want to name your files in a way that is easy to understand and maintain.

Let's take a look at some examples of good and bad file names for HTML files. Note that the `.html` extension in these examples tells us that this is an HTML file.

Here is an example of a bad file name: 

```md
index1234.html
```

By the name alone, it is not clear what the file is about. This file could be for a products page, blog page, or any other type of page but we don't know that from the file name.

Here is an example of a better file name for an HTML file:

```md
about-us.html
```

By using a more descriptive name like `about-us.html`, it is clear what the file is about.

You will also notice in this file name that there are no spaces. Instead, you use a hyphen, `-`, to separate the words. 

Sometimes you might see a file name called `index.html`. This is a special file name that is used to represent the main page of a website. When you visit a website, the `index.html` file is the first file that is loaded.

Another important consideration when naming files is the use of special characters.

Using a mixture of special characters, numbers, and letters can make it difficult to understand what the file is about.

Here is an example of a bad file name:

```md
file-1!@.html
```

This name looks unnecessarily complicated and does not give us any information about what the file is about.

So it is best to stick with only using letters and dashes in your file names.

As you start to learn more languages, you will see that there are common conventions for naming files in those languages as well. 

In these situations, it is always best to consult with official documentation or other resources to understand the best practices for naming files in that language.

Also you will be in situations where you are working on a team and you will need to follow the conventions that the team has established for naming files. 

Always consult with the team's style guide to make sure your file names are consistent with the rest of the team.


## What Are Best Practices for File/Folder Organization in Web Applications?

### Description

When building out web applications, it is important to think about the organization of your files and folders. This will help keep your code organized and easier to maintain.

Let's take a look at an example folder structure for an HTML and CSS project:

```bash
.
├── /assets
│   ├── /images
│   │   ├── logo.png
│   │   ├── banner.jpg
│   │   └── icons.svg
│   ├── /fonts
│   │   ├── custom-font.woff
│   │   └── custom-font.woff2
├── /css
│   ├── main.css
│   ├── about.css
│   └── contact.css
├── index.html
├── about.html
├── contact.html
└── README.md
```

At the top of the example, there is a single dot, which represents the root directory.

The root directory is the top-level directory in a file system, serving as the starting point for all file paths and containing all other directories and files. A directory is another name for a folder.

Inside the root directory, the first directory shown is the `assets` directory. The term `assets` refers to any files that are used in the project, such as images, fonts, or other resources.

In this example, there are two directories inside the `assets` directory called `images` and `fonts`.

The next directory would be the `css` directory. Sometimes this is also referred to as a stylesheets directory. This is where you would store all of your CSS files.

Below the `css` directory are the HTML files. The `index.html` file represents the homepage, while `about.html` and `contact.html` represent the About and Contact pages, respectively.

Lastly, there is a `README.md` file. `README` files are commonly used to provide useful information about the project, such as what it does, how to use it, and any other relevant details.

The `.md` extension stands for Markdown, which is a lightweight markup language that is often used to write documentation.

By organizing your project into assets, CSS, and HTML files, it makes it easy to find what you are looking for. This also makes it easy for other developers to contribute to your project.

It is important to note that this is just one example of how you can organize your files and folders. There are many different ways to structure a project.


## How Can You Create, Move, and Delete Files and Folders Using Explorer/Finder?

### Description

To create a file on Windows using the Explorer, you can click on the "New" option at the top right. This will show you a list of the different types of files that you can create. 

You can also create files in their corresponding applications. Let's create a text file to show you the process.

When you click on "New" and select the file type, you will see a new text file in your current folder with a default name. You can rename it if you'd like.

The process of creating folders is exactly the same. Click the "New" button at the top right and then select the "Folder" option or right-click on an empty spot and go to "New." Then, select the "Folder" option. You'll see a new empty folder in your current location.

You can rename files and folders by selecting them and clicking on the "Rename" option at the top. When current name of the file is highlighted, you can start writing the new name of the file. Press Enter to confirm the changes.

Alternatively, you can right-click on the file or folder and select the "Rename" option or use the F2 keyboard shortcut. Write the new name and press Enter to confirm the changes. 

You can move a file or folder to another folder by dragging and dropping it into the destination folder, if you have it opened it as a tab. 

You can also select the file or folder and select the "Cut" option at the top.

Then, go to the destination folder and paste it by clicking the "Paste" button at the top. If you copied or cut the file previously, this button will be enabled.

You can also do this by right-clicking on an empty spot and then clicking on the paste icon. This will remove the file or folder from its original location.

To delete a file or folder, click on it and then click on the Trash icon at the top. You will also find a "Delete" option if you right-click on it.

Great. Now let's see how you can do this on macOS using Finder. 

Finder is the default file manager on macOS.

To create a file on macOS, you need to open an application that lets you create the type of document that you need to create. Currently, there isn't a built-in way to create a file directly on Finder.

For example, to create a simple plain text file, you can open TextEdit and save your file. The process works exactly the same for any type of file.

There are many ways to open TextEdit. One of them is to go to Launchpad. Then, search for an app where you can create the type of file that you're interested in. In this case, that would be "TextEdit." Click on the icon to open the app.

Once you are inside the app, you should see an option to save your file in the App menu. This menu is located at the top-right, next to the Apple menu icon.

In one of the App menu options, you should see a command to save the file. This is usually under the File menu.

Next to it, you will see the keyboard shortcut for saving your file. This is usually `Command + S` on macOS.

When you are saving the file for the first time, you should see a dialog window, where you can write the name of the file and choose a location.

Usually, the file extension is added by the application automatically but you can change it before saving the file.

After saving the file, you can open Finder by clicking on the Finder icon in the Dock. You should see your new file in the folder where you saved it.

To create a new folder, you should go to the location where you want to create that new folder and rick-click on an empty spot. You will see a list of options. The first option is "New Folder."

If you click on it, you can assign a name to your new folder. Write the name and press Enter to confirm.

There are multiple ways to move files and folders in Finder. If you need to move them to a folder listed in your Finder "Favorites" section, you can just drag and drop it.

If you need to move it to a different folder, you have two options. 

You can either open the destination folder as a tab and drag and drop the file or folder into the tab.

Or you can use keyboard shortcuts. First, copy the file with `Command + C`, go to the new folder, and then use `Command + Option + V` to paste the file or folder in that location. This will also remove it from the original folder.

To delete a file or folder, you can right-click on it and select "Move to trash."

You can also drag and drop them into the trash icon on the Dock. This is equivalent.

When the file or folder is in the trash can, you can right-click on it to delete it immediately or you can empty the trash to remove all the deleted files and folders permanently.

Knowing how to create, move, and delete files and folders on Windows and macOS is very important. By mastering these skills, you can organize your files, locate them quickly, and free up storage on your computer by deleting unnecessary files.


## How Can You Search for Files and Folders on Your Computer?

### Description

Let's learn how to search for files and folders on Windows and macOS.

We'll start with Windows. You can search from the Taskbar or from the File Explorer.

To search from the Taskbar, write the name of the file or folder that you are looking for. You can also search for keywords. You'll see results from across your PC and OneDrive.

If you only want to see documents, you can click on the "Documents" tab. You also have tabs for apps and web results.

Another alternative is to use the Search File Explorer. You will find it at the top right of the Explorer window, where you can see "Search Documents."

You have three options to define the scope of the search:

- You can search from Home to find files from your PC and from the cloud quickly.

- You can search from a folder to find files stored inside it.

- You can search from This PC for a slow but in-depth search.

This is how you can search for files and folders on Windows. Now let's see how you can do this on macOS.

First, you can use Spotlight, a tool that helps you find files on your Mac. To open Spotlight, go to your menu bar at the top right and find the magnifying glass icon. If you don't see this icon on the menu bar, you can add it in the Control Center settings.

Go to your settings, filter by "Control Center", click on this option and then scroll down until you find the "Spotlight" option. You can also use a keyboard shortcut to open Spotlight: `Command + Spacebar`.

When you open Spotlight, you'll see the Spotlight Search, where you can search for any file or folder by typing its name. When you start typing, you'll see the results grouped by category, including suggestions, folders, presentations, photos, documents, and related searches.

You can also expand a specific category by clicking on "Show More."

Another way to search for files that you have recently opened is to open Finder by click on the Finder icon in the Dock. Then, go to "Recents" in the Finder sidebar. And there, you'll find all the files that you've recently viewed.

This is how you can search for files and folders on macOS. With these search tools, you can optimize your workflow and find the files and folders you need very quickly.


## What Are Some Common File Types You Will Work With in Web Applications?

### Description

Files are classified based on their content and structure. The file type determines how a file is opened and processed by computer programs.

We identify file types based on their extensions. A file extension is a three or four letter suffix at the end of the file name. The three main file types that you will find in web applications are HTML, CSS, and JavaScript.

HTML files contain the structure and content of the web application. They have a `.html` file extension.

CSS files define the styles. They have a `.css` file extension.

And JavaScript files add more advanced functionality and interactivity. They have a `.js` file extension.

As you develop web applications, you will also need to include images. These are some of the most widely used image file types.

JPEG, which stands for "Joint Photographic Experts Group," is known for its efficient compression. It's great for photographs and images. However, the compression is lossy, which means that some image quality is lost to reduce the file size.

PNG, which stands for "Portable Network Graphics," preserves image quality, even after compression. This results in larger files. PNG supports transparency and it's great for images with sharp edges, like logos and icons.

The GIF image format supports both animation and transparency but has a limited color palette. GIF stands for "Graphics Interchange Format."

And finally, we have SVG, which stands for "Scalable Vector Graphics." It's a vector image format. These images can be scaled as much as needed without losing quality.

Great. Now that you know about image formats, let's see some video and audio formats.

MP3 is an audio format known for its efficient compression. It's a lossy format, so some audio data is lost during the compression to make these files smaller.

MP4 is one of the most common video formats. It offers good compression and supports multiple audio and video codecs, subtitles, and metadata.

MOV, the QuickTime multimedia file format developed by Apple, is primarily associated with QuickTime Player.

Other popular audio and video file types are WAV, a lossless audio format that keeps the original quality of the audio, and WebM, a high-quality open-source video format.

If you ever need to customize the fonts of your web application, you will also work with font formats. These are three of the most widely used ones.

TTF, which stands for "TrueType Font", is a font format compatible with different operating systems.

WOFF is a modern font format, specifically designed for web development purposes. It stands for "Web Open Font Format". These files are smaller because they have better compression. They can also store metadata, including licensing information.

And WOFF2 is the successor of WOFF with even more efficient compression and performance.

You can also create archive files if you need to group multiple folders and files. The most widely used archive format is ZIP. ZIP offers lossless compression, so no data is lost during the process. It's widely supported across operating systems and software applications.

And finally, let's talk about documentation. In web applications, you will usually find a file called `README` that contains information about the application, like how to use it, how to install it, its license, and how to contribute.

They are usually written in a file format called Markdown. With Markdown, you can create structured documents with headings, subheadings, links, images, lists, and more. Markdown files have a `.md` or `.markdown` extension.

Here you can find the `README` file of freeCodeCamp's GitHub repository: https://github.com/freeCodeCamp/freeCodeCamp/blob/main/README.md

You can create this detailed structure and format using Markdown.

You will definitely read and write many `README` files throughout your career. Learning about these common file types is essential for web development. 

From the core building blocks of HTML, CSS, and JavaScript to image, video, and audio formats, every file type has an important role in creating interactive web applications.


### Lecture Block: Lecture Browsing The Web Effectively


## What Are Some of the Common Web Browsers Available Today and How Do You Install One?

### Description

Web browsers are applications you use to visit pages on the internet. If you are going through the freeCodeCamp curriculum, there is a very good chance you are using a web browser right now!

As of 2024, the most popular browsers are Microsoft Edge, Firefox, Google Chrome, and Safari. There are quite a few other options, and market shares are always changing, but these four are the most common at this time.

Your operating system most likely comes with a browser installed by default. For Windows, you'd have Microsoft Edge. For Mac, you'd have Safari. For Linux, you'll probably have Firefox.

But what if you want to use a different browser?

The good news is you already have a default browser. So you can navigate to the web page for the browser you want, and download the appropriate installer for your operating system.

When choosing a browser, consider factors like speed, security features, and compatibility with websites you frequently visit.

Some browsers offer unique features. For example, Opera has a built-in VPN, while Brave focuses on privacy and ad-blocking.

Installation is usually straightforward. After downloading the installer, simply run it and follow the on-screen instructions.

Most browsers will offer to import your bookmarks and settings from your current default browser, making the transition easier.

Alternatively, you can install a browser through your operating system's package manager, such as `brew install --cask google-chrome` on macOS with Homebrew, or `yay -S brave-bin` on Arch Linux.

The package manager and package names available to you will vary depending on your operating system.

Remember, you're not limited to just one browser. Many people use different browsers for different purposes – perhaps one for work and another for personal browsing.

Feel free to experiment with different browsers to find what works best for you.


## What Is the Difference Between a Web Browser, a Website, and a Search Engine?

### Description

Web browsers are software applications that allow users to access and navigate the World Wide Web. They interpret and display web content, including text, images, videos, and interactive elements.

Key features of web browsers include the address bar, where you enter URLs or search queries, and the rendering engine, which translates HTML, CSS, and JavaScript into visual web pages.

Browsers also offer bookmarks to save and organize favorite websites, extensions to enhance functionality, and various privacy and security features such as pop-up blockers and private browsing modes.

Popular web browsers include Google Chrome, Mozilla Firefox, Microsoft Edge, Safari, and Opera.

Websites, on the other hand, are collections of web pages and related content that are identified by a common domain name and published on at least one web server. They are the destinations you visit using your web browser.

Components of websites include the domain name, which is the unique address of the website (like freecodecamp.org), and web pages, which are individual documents that make up a website.

Websites also often include multimedia content like images, videos, and audio files that enhance the user experience, as well as interactive elements such as forms and buttons that allow user interaction.

Websites can be static, where content rarely changes, or dynamic, where content updates frequently or is personalized for users.

Search engines are web-based tools designed to help users find information on the internet. They use complex algorithms to index and rank web pages based on relevance to user queries.

Key aspects of search engines include web crawlers, also known as spiders or bots, which are programs that systematically browse the web to discover and index new content.

The indexing process involves organizing and storing information about web pages in massive databases.

Search engines also employ ranking algorithms, which are complex systems that determine the order of search results based on factors like relevance, authority, and user experience. Popular search engines include Google, Bing, Yahoo, and DuckDuckGo.

The relationship between browsers, websites, and search engines is interconnected.

Web browsers are the tools used to access both websites and search engines.

Websites are the destinations that users visit through browsers or find via search engines.

Search engines help users discover websites by providing organized access to the vast amount of information on the web.

Understanding these distinctions and relationships is crucial for effective internet use and basic web literacy.


## How to Use a Search Engine Effectively to Achieve Optimal Results

### Description

Searching for information on the Internet can be a daunting task. There are so many websites out there, with so much data, that it may seem impossible to get the results you want.

But thanks to things like boolean search syntax, you can narrow down your search to exactly what you need.

Boolean search syntax is a way to use special words to help you find exactly what you're looking for when searching online.

Here is an example of a basic search query for `freecodecamp curriculum`.

When you search for `freecodecamp curriculum`, the search engine will return results that match *any* of these keywords – typically sorted by relevance (how likely they are to match, or be related to, more of your query).

But what if you only wanted results that matched both keywords? Well, you might have heard that you can wrap a query in quotation marks, like `"freecodecamp curriculum"`.

However, this query specifically matches the *phrase* `freecodecamp curriculum`. This means that the results you will see will be limited to sites that say `freecodecamp curriculum` together, not sites that say `freecodecamp` AND `curriculum`.

If you want to match sites that include both of those terms, but not necessarily next to each other as a phrase, you can prefix each term with a plus symbol like this: `+freecodecamp +curriculum`

Alternatively, maybe you're interested in freeCodeCamp's initiatives outside of the curriculum. In this case, you can prefix the term `curriculum` with a minus symbol like this: `+freecodecamp -curriculum`.

This will return results that mention `freecodecamp`, but exclude results that also mention `curriculum`.

Or maybe you have a specific site you want to search, like our news platform? You can use `site:` followed by the URL of the site you want to search: `site:freecodecamp.org/news curriculum`.

This query returns all results from `freecodecamp.org/news` that contain the word `curriculum`.

By combining these tools, you can come up with very specific queries to get the exact information you need.

For example, the query `site:freecodecamp.org/news +python -curriculum` would search for Python articles on our news site, excluding articles that might talk about our curriculum.

Search operators may vary, so it is always important to check the documentation for your preferred search engine.

But you should now be empowered to get the exact results you want from your web searches.


## Module: Basic Css


### Lecture Block: Lecture What Is Css


## What Is CSS, and What Is Its Role on the Web?

### Description

CSS, which stands for Cascading Style Sheets, is a crucial component of modern web development. It's a markup language used to apply styles for HTML.

In simpler terms, if HTML is the structure of a web page, CSS is what makes it look good.

The primary role of CSS is to separate the content of a web page from its visual presentation.

This separation allows web developers to create more flexible and maintainable websites.

With CSS, you can control the layout, colors, fonts, and overall visual appearance of web pages without altering the HTML structure.

Let's consider a simple analogy. If you think of a website as a house, HTML would be the foundation and framework, while CSS would be the paint, wallpaper, and decorations that make the house visually appealing and unique.

CSS works by selecting HTML elements and applying styles to them.

These styles can include properties like color, font size, and many more. By changing these properties, you can dramatically alter how a web page looks without changing its content.

One of the most powerful aspects of CSS is its ability to create responsive designs.

This means that with CSS, you can make your website look great on any device, whether it's a desktop computer, a tablet, or a smartphone.

CSS allows you to adjust layouts, font sizes, and other visual elements based on the screen size of the device viewing the website.

Another important feature of CSS is its cascading nature, which is where the "cascading" in its name comes from.

This means that styles can be inherited and overridden, allowing for a hierarchical structure of styling.

CSS also supports the use of external stylesheets.

This means you can keep all your styling rules in a separate file, which can then be linked to multiple HTML pages.

This feature greatly enhances the maintainability of websites, especially larger ones. Instead of having to change styles on each individual page, you can make changes in one CSS file that will affect all linked pages.

In the world of web development, CSS plays a vital role in creating visually appealing, responsive, and user-friendly websites.

It allows developers to transform simple HTML documents into engaging web experiences that capture users' attention and enhance their interaction with web content.


## What Is the Basic Anatomy of a CSS Rule?

### Description

CSS is responsible for the styles of a web page. All of these styles are made up of various CSS rules.

A CSS rule is made up of two main parts: a **selector** and a **declaration** block.

Let's take a look at the basic syntax:

```css
selector {
  property: value;
}
```

A selector is a pattern used in CSS to identify and target specific HTML elements for styling.

Examples of selectors include type selectors, class selectors, and ID selectors.

The curly braces provided in the basic syntax are known as a declaration block. A declaration block applies a set of styles for a given selector, or selectors.

Inside the declaration block, you will have a series of declarations. Each declaration consists of a property and a value.

The property is the CSS identifier that specifies which feature is being styled. An example of a property would be the `background-color` property.

The value would be the specific setting applied to that property. For example, if the property is `background-color`, a value could be `purple`, which sets the background color to purple.

After each property name, you need to place a colon, and after each value, you should have a semicolon.

Now that you know the syntax for a CSS rule, let's take a look at an example.

```css
p {
  color: blue;
}
```

In this CSS rule, a type selector targets all paragraph elements on the page.

Inside the declaration block, there is a one declaration.

The declaration consists of the `color` property with a value set to `blue`. This will change the text color for all paragraph elements to `blue`.

If you want to apply the same set of styles to multiple selectors, you can create a selector list with each selector separated by a comma.

Here is an example of styling multiple selectors:

```css
#title,
.subheading {
  color: navy;
}
```

In this selector list, there is an `id` selector targeting the HTML element with the `id` value of `title`. All `id` selectors must start with a hash `#` symbol.

Then there is a comma followed by a `class` selector that targets all HTML elements with the `class` value of `subheading`. All class selectors must start with a dot `.`

The entire selector list will receive the same styling, with the text color set to `navy`.


## What Is the Meta Viewport Element Used For?

### Description

The meta viewport element is a crucial component in responsive web design.

It's a special HTML meta element that gives the browser instructions on how to control the page's dimensions and scaling on different devices, particularly on mobile phones and tablets.

Let's take a look at the basic syntax of the meta viewport element:

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0">
```

This element is typically placed in the `head` section of your HTML document. But what does each part of the element mean?

The `width=device-width` part tells the browser to set the width of the page to match the screen width of the device. This is essential for creating responsive layouts that adapt to different screen sizes.

The `initial-scale=1.0` sets the initial zoom level when the page is first loaded. A value of 1.0 means that the page is displayed at `100%` zoom, without any scaling.

By using the meta viewport element, you're ensuring that your web pages are displayed properly on mobile devices.

Without it, mobile browsers will typically render the page at a desktop screen width and then scale it down, which can result in a poor user experience with tiny, hard-to-read text.

The meta viewport element also allows you to control whether users can zoom in and out of your web pages.

While it's possible to disable zooming with the `user-scalable=no` attribute, it's generally recommended to avoid this for accessibility reasons.

Many users rely on the ability to zoom for better readability, especially those with visual impairments.

Here's an example of what not to do:

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
```

Instead, it's better to design your website to be responsive and readable at different zoom levels, ensuring that all users can comfortably access your content.

The meta viewport element plays a crucial role in creating mobile-friendly websites.

It ensures that your carefully crafted responsive designs are displayed as intended on various devices, providing a better user experience for all visitors to your site.


## What Are Some Default Browser Styles Applied to HTML?

### Description

When you start working with HTML and CSS, you'll notice that some styles are applied to your web pages even before you write any CSS. These styles are called "default browser styles" or "user-agent styles".

These default browser styles provide basic formatting to ensure that HTML elements are displayed in a readable way across all browsers.

However, these styles can vary slightly from one browser to another, which is why it's important to understand them when designing a consistent look for your website.

Let’s take a look at some common default browser styles applied to various HTML elements.

Headings are one of the most commonly used HTML elements and are styled by default to have varying sizes and weights.

For example, `h1` (the highest-level heading) is usually bold and larger in font size compared to lower-level headings like `h2`, `h3`, and so on.

These heading tags help define the hierarchy and structure of your content.

The following example shows all six heading elements from `h1` to `h6`.

```html
<h1>Heading 1</h1>
<h2>Heading 2</h2>
<h3>Heading 3</h3>
<h4>Heading 4</h4>
<h5>Heading 5</h5>
<h6>Heading 6</h6>
```

Another element with default styles is the `hr` element, which creates a horizontal rule often used to visually separate sections of content. Browsers generally apply a simple line style to this element.

To understand it better, let's look at this code example:

```html
<p>Paragraph 1</p>
<p>Paragraph 2</p>
<hr>
<p>Paragraph 3</p>
<p>Paragraph 4</p>
```

The horizontal rule appears as a thin line with spacing above and below the text to distinguish between sections of content.

Next, we will look at the `blockquote` element.

Blockquotes are used to indicate a section of text that is a quotation from another source. Browsers typically add indentation and sometimes italicize the text.

The indentation helps set blockquotes apart from the rest of the text, making it clear that this content is quoted from another source.

Let's take a look at this code example:

```html
<p>Paragraph 1</p>
<p>Paragraph 2</p>
<blockquote>I think, therefore I am. (Rene Descartes)</blockquote>
<p>Paragraph 3</p>
<p>Paragraph 4</p>
```

In the example above, the `blockquote` element will produce an indent on the text, applied by the default browser styles.

Another element with default styles is the anchor element (`<a>`), which is styled with a default blue color and underlining to make it recognizable as a link.

Let's take at look at the following HTML example:

```html
<p>Paragraph 1</p>
<p>Paragraph 2</p>
<a href="https://freecodecamp.org/">Visit the freeCodeCamp learn page</a>
<p>Paragraph 3</p>
<p>Paragraph 4</p>
```

The above code has four paragraph elements with an anchor element in the middle. The anchor element is styled in blue with an underline to show users to go to the freeCodeCamp learn page.

Finally, we'll look at the unordered and ordered list elements.

Browsers add basic formatting to lists, including indentation and bullets or numbers, depending on whether you are using an unordered list (`ul`) or an ordered list (`ol`).

Let's take a look at an example:

```html
<p>Sample Paragraph</p>
<ol>
  <li>item 1</li>
  <li>item 2</li>
  <li>item 3</li>
</ol>
<ul>
  <li>item</li>
  <li>another item</li>
  <li>yet another item</li>
</ul>
<p>Ending Paragraph</p>
```

In the above code example, we are using an unordered list and an ordered list. Both of these lists will be slightly indented to the right by default.

For all of these examples, you saw how the browser applied default spacing, varying font sizes, and weights to these HTML elements.

In later lectures, you will learn how to reset some of these default styles using a CSS reset.


## What Are Inline, Internal, and External CSS, and When Should You Use Each One?

### Description

CSS can be applied to a webpage in three main ways: inline, internal, or external.

Each method has its own use case, advantages, and limitations, and knowing when to use each one is essential for writing clean, efficient, and maintainable code.

Let’s break down the three types of CSS and when you should use them.

Inline CSS is written directly within an HTML element using the `style` attribute. It applies styles to a specific element.

Here's an example using inline CSS:

```html
<p style="color: red;">This is an inline-styled paragraph.</p>
```

In this example, we are using the `style` attribute to set the paragraph text to `red`.

Inline CSS is generally used for quick, one-off styles or to override other styles for a specific element.

However, it should be avoided in most cases because it can clutter the HTML and make the code harder to maintain.

Most of the time, it's better to use internal or external CSS to keep your styles organized and maintainable.

Internal CSS is written within the `style` tags inside the `head` section of an HTML document. It applies styles to the entire page and is useful when you need to style a single document.

Here's an example of internal CSS:

```html
<head>
  <style>
    p {
      color: blue;
    }
  </style>
</head>
<body>
  <p>This paragraph is styled using internal CSS.</p>
</body>
```

In the above example, the internal CSS applies blue text to all `p` elements on the page.

Internal CSS is best used when you need to apply styles to a specific page rather than across multiple pages. It’s useful for single-page websites or when the styles don’t need to be reused elsewhere.

However, there are some downsides, such as not promoting reusability across multiple pages. Additionally, like inline CSS, it mixes HTML and CSS, making the code harder to maintain in larger projects.

External CSS is written in a separate `.css` file and linked to the HTML document using the `link` element in the `head` section.

It allows you to style multiple pages consistently and is the preferred method in professional web development.

Here's the HTML part of our code example:

```html
<head>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <p>This paragraph is styled using external CSS.</p>
</body>
```

In an earlier lecture, you learned that the `link` element has a `rel` attribute that specifies the relationship between the current document and the linked resource, such as linking to a stylesheet or an external resource.

On the other hand, the `href` attribute specifies the URL of the linked resource, indicating where the resource should be retrieved from.

Here the CSS portion of the same example in separate file named `style.css`.

```css
p {
  color: green;
}
```

This example targets all paragraph elements on the page and sets the text color to green.

External CSS is ideal for large projects where you want to maintain a consistent style across multiple pages.

It promotes separation of concerns by having HTML handle the structure and CSS handle the styling, which makes the code more maintainable and scalable.

Understanding when to use each type of CSS is crucial for efficient and effective web development.

In most cases, external CSS should be your go-to approach, especially for larger and more complex projects.


## How Do Width and Height Work?

### Description

In CSS, the `width` and `height` properties are used to control the dimensions of elements on a webpage.

These properties can be defined in different units such as pixels (`px`), percentages (`%`), viewport units (`vw`, `vh`), and more.

The `width` property specifies the width of an element. If you do not specify a width, then the default is set to `auto`. This means the element will take up the full width of its parent container.

The `height` property specifies the height of an element. Similarly, the height is `auto` by default, which means it will adjust to the content inside.

Here's an example using the `width` and `height` properties:

```html
<head>
  <style>
    .box {
      width: 100px;
      height: 100px;
      background-color: skyblue
    }
  </style>
</head>
<body>
  <div class="box"></div>
</body>
```

In this example, we have a `div` element with class named `box`. This element will be occupying `100px` in height and width, whereas the background color will be `skyblue`.

Pixels are a fixed-size unit of measurement in CSS, providing precise control over dimensions. 

The `min-width` property specifies the minimum width an element can be. Even if the content inside is smaller, the element won’t shrink below this value.

The `min-height` specifies the minimum height an element can be. It ensures that the element does not become shorter than the set value.

Here is an example:

```html
<head>
  <style>
    .box {
      width: 50px;
      min-width: 100px;
      height: 50px;
      min-height: 100px;
      background-color: lightcoral;
    }
  </style>
</head>
<body>
  <div class="box"></div>
</body>
```

The above example demonstrates how `min-width` and `min-height` work.

Even though the box has its `width` and `height` set to 50px, it will actually be `100px` by `100px`. This is because the `min-width` and `min-height` are set to `100px`, which are larger than the specified `width` and `height`.

Remember, if `min-width` or `min-height` are larger than the `width` or `height`, they will override the smaller values. This ensures that elements don't become too small, which is important for maintaining a consistent and usable design.

The `max-width` specifies the maximum width an element can grow to, even if there is enough space for it to be wider.

The `max-height` specifies the maximum height an element can grow to, regardless of the content size.

Here is an example:

```html
<head>
  <style>
    .box {
      width: 200px;
      max-width: 150px;
      height: 200px;
      max-height: 150px;
      background-color: lightgreen;
    }
  </style>
</head>
<body>
  <div class="box"></div>
</body>
```

The above example demonstrates how `max-width` and `max-height` override `width` and `height`. Even though the box is set to `200px` by `200px`, it will actually be `150px` by `150px`. This is because the `max-width` and `max-height` are set to `150px`, which is smaller.

Remember, when `max-width` or `max-height` are smaller than `width` or `height`, they take precedence. This is important for controlling the maximum size of elements in your layouts.

CSS prioritizes `min-width` and `min-height` over `width` and `height`. `max-width` and `max-height` restrict dimensions if values exceed their limits.

For example, if you set `width` to `600px` and `max-width` to `500px`, the element will be limited to `500px` wide. The `max-width` overrides the wider setting, keeping the element within the specified maximum size.

This ensures elements stay within desired size ranges, regardless of standard width and height values.


## What Are the Different Types of CSS Combinators?

### Description

CSS combinators are used to define the relationship between selectors in CSS. They help in selecting elements based on their relationship to other elements, which allows for more precise and efficient styling.

We will discuss some primary CSS combinators and their use cases, starting with the descendant combinator.

A descendant combinator is used to target elements matched by the second selector if they are nested within an ancestor element that matches the first selector. An ancestor can be a parent element or a parent's parent.

To better understand how this works, let's take a look at an example.

```css
figure img {
  border: 4px solid black;
}
```

In the above example, we use the descendant combinator to select all image elements inside `figure` elements and apply a `solid black` border on all four sides.

Note that a `space` is used between the parent and child selector.

In this case, the `figure` would be the parent and the `img` would be the child.

If you had multiple images inside a `figure` element, using the descendant combinator would be a good way to apply a solid black border around each of those images.

Another type of combinator would be the child combinator.

The child combinator (`>`) in CSS is used to select elements that are direct children of a specified parent element.

This combinator targets only elements with a specific parent, making your CSS rules more precise and preventing unintended styling of deeper nested elements.

Let's take a look at the following HTML example:

```html
<div class="container">
    <p>First</p>
    <div>
      <p>Second</p>
    </div>
    <div>
      <p>Third</p>
    </div>
</div>
```

In above HTML structure, the `container` class is applied to a `div` element.

Inside this container, there is a direct child `p` element ("First"), followed by two additional `div` elements, each containing a `p` element ("Second" and "Third").

The first `p` element is a direct child of the `.container` element, while the other two `p` elements are nested inside other `div` elements, making them deeper descendants.

To apply styles to just the direct child of the `container` class, you can use the child combinator like this:

```css
.container > p {
  color: blue;
}
```

In the above example, we are only targeting the direct child of `container` class. This will give the direct child the text color of `blue`.

Because the other two paragraph elements are nested inside `div` elements, they are not considered direct children of the `container` class and will not get the text color of blue.

Another common combinator would be the next-sibling combinator.

The next-sibling combinator (`+`) in CSS selects an element that immediately follows a specified sibling element. This combinator is useful when you want to apply styles to an element that directly follows another element, allowing for targeted styling based on the element's position relative to its siblings.

Let's take a look at the following HTML example:

```html
<figure>
  <img
    src="https://cdn.freecodecamp.org/curriculum/cat-photo-app/relaxing-cat.jpg"
    alt="A cute orange cat lying on its back."
  />
  <figcaption>A cute orange cat lying on its back.</figcaption>
</figure>
```

Here, we have a `figure` element containing an `img` element followed by a `figcaption` element. The `figcaption` element is the immediate sibling of the `img` element.

If you wanted to apply a black border around the `figcaption` element, you can use the next-sibling combinator like this:

```css
img + figcaption {
  border: 4px solid black;
}
```

In this example, the next-sibling combinator (`+`) selects the `figcaption` element that immediately follows the `img` element. The applied CSS rule adds a `4px solid black border` around the `figcaption`.

Another common combinator is the subsequent-sibling combinator.

The subsequent-sibling combinator (`~`) in CSS selects all siblings of a specified element that come after it.

Unlike the next-sibling combinator, which targets only the immediately following sibling, the subsequent-sibling combinator (`~`) can target any siblings that follow the specified element, offering greater flexibility in styling.

Let's take a look at the following HTML example:

```html
<div class="container">
  <h2>Subheading</h2>
  <p>First paragraph.</p>
  <p>Second paragraph.</p>
  <p>Third paragraph.</p>
  <p>Another paragraph element</p>
</div>
```

In this HTML structure, we have an `h2` element followed by four paragraph elements. The paragraph elements are siblings of the `h2` element.

If you want to style all of the paragraph elements that come after the `h2` element, then you can use the subsequent-sibling combinator like this:

```css
h2 ~ p {
  color: green;
}
```

In this example, all paragraph elements following the `h2` element will have the text color green.

The subsequent-sibling combinator (`~`) targets all paragraph siblings that appear after the `h2` element, regardless of whether they are immediate siblings.

In conclusion, understanding and using various CSS combinators allows you to apply precise styles to your HTML elements, enhancing the control and flexibility of your design.

By mastering these selectors, you can create more sophisticated and targeted styling rules that improve both the appearance and functionality of your web pages.


## What Is the Difference Between Inline and Block-Level Elements in CSS?

### Description

In HTML and CSS, elements are classified as either **inline elements** or **block-level elements**, and this classification dictates how they behave in the document layout.

Understanding this difference is crucial for controlling how your content is displayed on a webpage.

Block-level elements are elements that take up the full width available to them by default, stretching across the width of their container.

These elements always start on a new line and push other content to the next line, creating a "block" of content.

Block-level elements have the CSS property `display: block;` applied by default. This property ensures that the element stretches to fill the container's width and appears on a new line.

Some common block-level elements are `div` elements, paragraphs, headings, ordered lists, unordered lists, and section elements.

Here is a code example of a block-level element:

```html
<p style="border: 2px solid red;">
  First paragraph
</p>
<p>Second paragraph</p>
```

In this example, we have two paragraph elements where the first one has a red border around it.

The two paragraph elements do not share the same line because they are block level elements by default.

So, both paragraph elements will take up the full width of its container, which in this case is the `body` element.

Block-level elements are ideal when you want content to stack vertically, such as paragraphs, sections, or larger blocks of content. They're commonly used to define the layout and structure of a webpage.

Inline elements, unlike block-level elements, only take up as much width as they need and do not start on a new line. These elements flow within the content, allowing text and other inline elements to appear alongside them.

Inline elements have the CSS property `display: inline;` applied by default. This property ensures that the element remains within the flow of the content and does not break onto a new line.

Common inline elements are `span`, `anchor`, and `img` elements.

Here's an example to better understand inline elements:

```html
<p>This is a
  <span style="color: red; border: 2px solid green;">red</span>
  word inside a paragraph.
</p>
```

In this example, we have a `span` element nested inside of a paragraph element. The `span` element has a `red` text color with a `green` border around it so you can see the highlighted word better.

As you can see, the `span` element only takes up as much space as the word "red" and does not push the following content to a new line.

Inline elements are best used for styling smaller portions of text or content within a line, such as emphasizing a word, creating hyperlinks, or applying specific styles to parts of a paragraph.


## How Does Inline-Block Work, and How Does It Differ from Inline and Block Elements?

### Description

When working with CSS, you often encounter three different types of display behaviors for elements: `inline`, `block`, and `inline-block`.

Each of these properties affects how elements are positioned and how they interact with other elements on the page.

In this lecture, we will focus on how the `inline-block` property works and how it differs from both inline and block-level elements.

Block-level elements behave like large containers or "blocks" that take up the full width of their parent container. They always start on a new line, and their height and width can be adjusted.

Inline elements only take up as much space as they need. They flow within the surrounding content and do not break onto a new line.

The `inline-block` property is a hybrid of these two behaviors. Like inline elements, `inline-block` elements remain in the text flow without starting on a new line.

However, unlike inline elements, you can adjust the width and height of an `inline-block` element, just as you would with block-level elements.

In short, the key difference between `inline` and `inline-block` is that `inline` elements cannot have their size controlled, whereas `inline-block` elements allow for full control over dimensions while still staying inline with other content.

Let's take a look at an example.

```html
<div class="container">
  <span class="inline-block-element element1">Inline-Block Element 1</span>
  <span class="inline-block-element element2">Inline-Block Element 2</span>
</div>
```

In the above example, we have a `div` with a class of `container`. Inside that `div` element, we have two `span` elements.

Here is the accompanying CSS:

```css
.inline-block-element {
  display: inline-block;
  width: 150px;
  height: 100px;
}

.element1 {
  background-color: lightblue;
}

.element2 {
  background-color: lightgreen;
}
```

Each of the span elements is set to `display:inline-block` and has a width and height set as well.

The inline-block elements will appear side by side because they behave like inline elements, but they also have a specified width and height, which gives them block-like properties.

But, if you remove the `display: inline-block` property, neither the `height` nor the `width` will be applied even though you defined it clearly.

Here is the revised CSS:

```css
.inline-block-element {
  width: 150px;
  height: 100px;
}

.element1 {
  background-color: lightblue;
}

.element2 {
  background-color: lightgreen;
}
```

In this code, we removed the `display: inline-block;` property but kept everything else intact. Here, the `span` elements revert to their default behavior as inline elements.

As a result, the specified width and height are ignored, and the elements only take up the space needed for their content.

Understanding how `inline-block` works is useful because you can use it for creating layouts that require both alignment and dimension control within a continuous text flow.


## What Are Margins and Padding, and How Do They Work?

### Description

Margin and padding are essential properties in CSS for creating well-structured, readable, and visually appealing web pages.

Margins control the space outside an element, helping to separate it from other elements and define the layout structure, while padding controls the space inside an element, improving content readability and aesthetic appeal.

To better understand the differences between `margin` and `padding`, let's take a look at some examples.

Here is an HTML example of three paragraph elements on the page:

```html
<p>Paragraph one</p>
<p>Paragraph two</p>
<p>Paragraph three</p>
```

To apply spacing to the top of each paragraph element, you can use the `margin-top` property like this:

```css
p {
  margin-top: 20px;
  border: 2px solid black;
}
```

In this example, we are applying `20px` of margin only to the top of each paragraph element.

We also have a solid black border on all four sides so you can see the margin better.

The four different `margin` properties are `margin-top`, `margin-right`, `margin-bottom` and `margin-left`.

Here is an example of using all four properties:

```html
<span>Paragraph one</span>
<p>Paragraph two</p>
<span>Paragraph three</span>
```

```css
p {
  margin-top: 10px;
  margin-right: 20px;
  margin-bottom: 30px;
  margin-left: 40px;
  border: 2px solid black;
}
```

In this example, we are assigning spacing values on all four sides of the paragraph element. A solid black border has also been added so you can see the margins better.

Another way to use the `margin` property is with shorthand notation. You can specify one, two, three, or four values at once. Let’s explore these options together.

When using a singular value on the `margin` shorthand, that exact value will be applied to all four sides of the target element.

Here is an example of using a single value on `margin` shorthand:

```css
p {
  margin: 10px;
}
```

This code example will apply `10px` of `margin` equally to all four sides of the paragraph element.

When using two values, the first value applies to the `top` and `bottom`, while the second value applies to the `left` and `right` sides of the element.

Here is an example of using of two values for the `margin` shorthand:

```css
p {
  margin: 10px 20px;
}
```

This sets the `top` and `bottom` margins to `10px`, and `20px` for the `left` and `right` margins for the paragraph element.

If three values are provided, the first value applies to the `top` margin, the second value to the `left` and `right` margin, and the third value to the `bottom` margin.

Here is an example to better understand:

```css
p {
  margin: 10px 20px 30px;
}
```

This sets the margin to `10px` for the `top`, `20px` for the `left` and `right`, and `30px` for the `bottom`.

When using four values, this gives you more control, as you can independently specify each margin value for each side of the target element.

The first value targets the `top`, the second value targets the `right`, the third value targets the `bottom`, and the fourth value targets the `left`.

Here is an example of using the margin shorthand with four values:

```css
p {
  margin: 10px 20px 30px 40px;
}
```

This sets the margin to `10px` for the `top`, `20px` for the `right`, `30px` for the `bottom`, and `40px` for the `left`.

The `padding` property is used to apply space inside the element, between the content and its border.

Like the `margin` property, the four `padding` properties are `padding-top`, `padding-right`, `padding-bottom` and `padding-left`.

Here's an example on how to set the `padding` for a paragraph element:

```html
<span>Paragraph one</span>
<p>Paragraph two</p>
<span>Paragraph three</span>
```

```css
p {
  padding-top: 10px;
  padding-right: 20px;
  padding-bottom: 30px;
  padding-left: 40px;
  border: 2px solid black;
}
```

This sets the padding to `10px` for the `top`, `20px` for the `right`, `30px` for the `bottom`, and `40px` for the `left`.

As you can see that, `padding` is applied to the content which is inside the border, unlike `margin` which applies to outside the border.

Just like the `margin` property, you can also choose to use the shorthand for the `padding` property.

You can either specify one, two, three, or four values on the `padding` shorthand property as well.

Here is an example of using the `padding` shorthand for paragraph element from earlier:

```css
p {
  padding: 10px 20px 30px 40px;
  border: 2px solid black;
}
```

In the example, using the shorthand the code will set the padding to `10px` for the `top`, `20px` for the `right`, `30px` for the `bottom`, and `40px` for the `left` of the paragraph element.


### Lecture Block: Lecture Css Specificity The Cascade Algorithm And Inheritance


## What Is CSS Specificity, and the Specificity for Inline, Internal, and External CSS?

### Description

CSS specificity is a fundamental concept that determines which styles are applied to an element when multiple rules could apply.

Understanding specificity helps developers resolve conflicts between different CSS rules and ensures that the desired styles are consistently applied.

CSS specificity is calculated based on the type of selectors used.

The highest specificity is attributed to inline styles, which are applied directly to an element through the `style` attribute.

Following this, ID selectors like `#main` and `#header` have a high level of specificity.

Next, class selectors, attribute selectors, and pseudo-classes come into play.

Examples include class selectors such as `.container` and `.button`, attribute selectors like `[type="text"]`, and pseudo-classes such as `:hover`. These have a moderate level of specificity.

Type selectors, such as `div` and `h1`, and pseudo-elements like `::before` and `::after`, have a lower specificity compared to the previous groups.

Finally, the universal selector, represented by an asterisk `*`, has the lowest specificity of all.

Specificity values are calculated as a four-part value `(a, b, c, d)`:

- `a`: Inline styles (`1` or `0`).
- `b`: Number of ID selectors.
- `c`: Number of class selectors, attribute selectors, and pseudo-classes.
- `d`: Number of type selectors, pseudo-elements, and universal selectors.

Each part of the specificity value carries different weight:

- **Inline styles** (`a`) have the highest weight, contributing a value of `1` to the first part of the specificity value.
    
- **ID selectors** (`b`) carry the next highest weight, with each ID contributing `1` to the second part of the specificity value.
    
- **Class selectors, attribute selectors, and pseudo-classes** (`c`) carry moderate weight, with each contributing `1` to the third part of the specificity value.
    
- **Type selectors and pseudo-elements** (`d`) have the lowest weight, with each contributing `1` to the fourth part of the specificity value.
    
- **Universal selector** (`*`): The universal selector contributes `0` to the specificity calculation and does not affect specificity. Its inclusion in a selector does not change the specificity value.

Inline CSS has the highest specificity because it is applied directly to the element. It overrides any internal or external CSS. The specificity value for inline styles is `(1, 0, 0, 0)`.

Here is an example using inline styles for a `div` element.

```html
<div style="color: red;">This text is red.</div>
```

In this example, the text will always be red, regardless of any other styles applied via internal or external CSS.

Internal CSS is defined within a `style` element in the `head` section of the HTML document. It has lower specificity than inline styles but can override external styles.

The specificity value for internal styles is determined by the selectors used. For example, an ID selector within internal CSS has a specificity value of `(0, 1, 0, 0)`.

```html
<head>
  <style>
    .text {
      color: blue;
    }
  </style>
</head>
<body>
  <div class="text">This text is blue.</div>
</body>
```

In this example, the text will be blue unless an inline style or a more specific external style is applied.

External CSS is linked via a `link` element in the `head` section and is written in separate `.css` files. It has the lowest specificity but provides the best maintainability for larger projects.

The specificity value for external styles is also determined by the selectors used. For example, a class selector within external CSS has a specificity value of `(0, 0, 1, 0)`.

```html
<head>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="text">This text's color is defined in an external CSS file.</div>
</body>
```

In this example, the text color is defined in the `styles.css` file and will be applied unless overridden by internal or inline styles.


## What Is the Universal Selector, and What Is Its Specificity?

### Description

The universal selector (`*`) is a special type of CSS selector that matches any element in the document.

It is often used to apply a style to all elements on the page, which can be useful for resetting or normalizing styles across different browsers.

The universal selector can be used to select all elements within a specific context or globally across the entire document.

Here is an example of using the universal selector for setting the `margin` and `padding` for the entire HTML document:

```css
* {
  margin: 0;
  padding: 0;
}
```

In this code example, the `*` selector resets the margin and padding of all elements to zero, which is a common technique used in CSS resets.

The universal selector has the lowest specificity value of any selector. It contributes 0 to all parts of the specificity value `(0, 0, 0, 0)`.

This means that any other selector, including type selectors, class selectors, ID selectors, and inline styles, will override the styles set by the universal selector.

Let's take a look at the following HTML and CSS example:

```html
<head>
  <style>
    * {
      color: blue;
    }
    p {
      color: red;
    }
    .highlight {
      color: green;
    }
    #unique {
      color: purple;
    }
  </style>
</head>
<body>
  <p id="unique" class="highlight">This text has multiple styles applied.</p>
</body>
```

The universal `*` selector sets the text color to `blue` for all elements.

However, the `p` type selector overrides this by setting the text color to `red` specifically for `p` elements.

If an element has the `highlight` class, the class selector takes precedence, changing the text color to `green`.

Finally, the `#unique` ID selector, which has the highest specificity, will override all others, setting the text color to `purple`.


## What Is the Specificity for Type Selectors?

### Description

Type selectors, also known as element selectors, target elements based on their tag name.

These selectors are fundamental in CSS and allow you to apply styles to all instances of a specific HTML element.

Type selectors are straightforward to use and are written simply as the tag name of the element you want to style.

Here is an example of a type selector targeting all paragraph elements on the page:

```css
p {
  color: blue;
}
```

In this example, all `p` elements will have their text color set to `blue`.

Type selectors have a relatively low specificity compared to other selectors. The specificity value for a type selector is `(0, 0, 0, 1)`.

This means that type selectors will be overridden by class selectors, ID selectors, and inline styles, but can still apply styles unless those higher-specificity rules are present.

Let's take a look at an example where the class selectors will override the styles of the type selector.

Here is an example with two paragraph elements:

```html
<p class="para">I am a paragraph</p>
<p class="para">Here is another paragraph</p>
```

Both paragraph elements have a class called `para`.

Inside the CSS file, the type selector targets paragraphs, and the class selector targets elements with the `para` class.

```css
p {
  color: blue;
}

.para {
  color: red;
}
```

All paragraphs on the page with the class of `para` will have the text color set to `red` instead of `blue` because class selectors have a higher specificity than type selectors.


## What Is the Specificity for Class Selectors?

### Description

Class selectors are a key part of CSS, allowing developers to target multiple elements with the same class attribute and apply consistent styling.

This makes them highly versatile and efficient for applying styles across a website.

Class selectors are defined by a period (`.`) followed by the class name. They can be applied to any element in the HTML document.

Here is an example using a class selector:

```css
.highlight {
  color: green;
}
```

In this example, any element with the class `highlight` will have its text color set to `green`.

Class selectors have a higher specificity than type selectors but lower than ID selectors and inline styles.

The specificity value for a class selector is `(0, 0, 1, 0)`. This means that class selectors can override type selectors, but they can be overridden by ID selectors and inline styles.

Class selectors can be combined with other selectors to create more specific rules.

Here is an example combining a paragraph type selector with a class selector:

```css
p.highlight {
  font-weight: bold;
}
```

This rule applies only to `p` elements that also have the `highlight` class, making their text bold.


## What Is the Specificity for ID Selectors?

### Description

ID selectors are among the most powerful selectors in CSS, allowing developers to apply styles to specific elements with unique identifiers.

This makes them highly effective for targeting individual elements that need unique styling.

ID selectors are defined by a hash symbol (`#`) followed by the ID name. They should be unique within an HTML document, meaning no two elements should share the same ID.

Here is an example using an ID selector:

```css
#unique {
  color: purple;
}
```

In this example, the element with the ID `unique` will have its text color set to `purple`.

ID selectors have a very high specificity, higher than type selectors and class selectors, but lower than inline styles. The specificity value for an ID selector is `(0, 1, 0, 0)`.

This means that ID selectors can override class selectors and type selectors but can be overridden by inline styles.


## What Is the important Keyword, and What Are the Best Practices for Using It?

### Description

The `!important` keyword in CSS is used to give a style rule the highest priority, allowing it to override any other declarations for a property.

When used, it forces the browser to apply the specified style, regardless of the specificity of other selectors.

Let's say you have an HTML paragraph element with inline styles like this:

```html
<p class="para" style="background-color: lightblue; color: black;">
  This is a paragraph.
</p>
```

In this example, the paragraph element has a background color set to `lightblue` and a text color set to `black`.

The CSS file applies the following styles to the paragraph element:

```css
.para {
  background-color: black;
  color: white;
}
```

Since inline styles have a higher precedence than class, ID and type selectors, the black background color and white text color will not be applied to that paragraph element.

To override those inline styles, you can use the `!important` keyword like this:

```css
.para {
  background-color: black !important;
  color: white !important;
}
```

The `!important` keyword is used after the CSS value and before the semicolon.

Now the paragraph element will have those black and white colors applied because the inline styles are being overridden with the use of the `!important` keyword.

The `!important` keyword in CSS is used to give a style rule the highest priority, effectively overriding other declarations, including those with higher specificity and inline styles.

However, the `!important` keyword does not change the specificity of the CSS selector itself. It simply ensures that the rule with `!important` is applied, even if there are other conflicting rules with higher specificity.

Another appropriate use case for the `!important` keyword is to override styles from third-party libraries or frameworks when you do not have control over the original CSS.

However, overusing the `!important` keyword can lead to difficulties in maintaining and debugging your CSS, as it breaks the natural cascading of styles and can lead to unintended consequences.

So, it is best to use the `!important` keyword sparingly.


## How Does the Cascade Algorithm Work at a High Level?

### Description

The Cascade Algorithm is the process the browser uses to decide which CSS rules to apply when there are multiple styles targeting the same element. It ensures that the most appropriate styles are used, based on a set of well-defined rules.

The process begins with **relevance**. The browser first filters all the CSS rules to find those that actually apply to the element in question. This includes matching selectors and considering media queries that might be in effect.

A media query is a CSS technique used to apply styles based on the characteristics of the device or viewport, such as its width, height, or orientation.

Next, the algorithm considers **origin and importance**. CSS can come from different sources: the browser’s default styles (user-agent), styles set by the user, and styles written by the author (you).

Following the consideration of origin, the algorithm then evaluates the importance of each rule, giving priority to rules marked with `!important`, which override other rules regardless of their source.

After filtering by origin and importance, the algorithm looks at **specificity**. When two rules from the same origin and importance level apply, the rule with the higher specificity will be applied.

Specificity is a measure of how targeted a selector is, with more specific selectors taking precedence over more general ones.

Finally, if everything else is equal, the **order of appearance** comes into play. When two rules have the same specificity, the one that appears last in the CSS will be applied.

This is why the order in which you write your styles can sometimes affect the outcome.

Let's take a look at an example.

Here we have a single paragraph element on the page:

```html
<p>example paragraph</p>
```

Inside the CSS, we have two rules each targeting the paragraph element.

```css
p {
  color: blue;
}

p {
  color: green; 
}
```

The first rule sets all paragraph elements to the text color of blue while the second rule sets all paragraph elements to the text color of green.

So which color will be applied? The color green will be applied to the paragraph elements.

By considering relevance, origin and importance, specificity, scope, and order of appearance, the Cascade Algorithm ensures that your CSS behaves predictably, allowing you to design more complex and nuanced web pages.


## How Does Inheritance Work with CSS at a High Level?

### Description

Inheritance is a key concept in CSS that determines how styles are passed down from parent elements to their child elements.

Just like in the real world, where children often inherit traits from their parents, in CSS, certain properties can be inherited by child elements from their parent elements.

This allows for a more efficient way to apply consistent styling across an entire document.

In CSS, not all properties are inherited by default. For example, properties like `color`, `font-family`, and `line-height` are inherited. This means that if you set the text color on a parent element, all of its child elements will inherit that color unless you specifically override it.

For instance, consider the following example where a parent `div` element has its color set using an inline style, and the child `p` element inherits that color:

```html
<div style="color: blue;">
  This is the parent element.
  <p>This is the child element inheriting the color.</p>
</div>
```

In this case, both the parent `div` and the child `p` will display their text in blue because the color is inherited.

On the other hand, properties like `margin`, `padding`, `border`, and `background` are not inherited by default. If you want a child element to inherit these styles, you need to explicitly set them, either directly on the child element or by using the `inherit` keyword.

The `inherit` keyword can be used to force inheritance of a property from a parent element, even if that property is not normally inherited.

For example, if you want a specific child element to have the same `padding` as its parent, you can set `padding: inherit` on the child element:

```html
<div style="padding: 20px;">
  This is the parent element with padding.
  <p style="padding: inherit;">This is the child element inheriting the padding.</p>
</div>
```

In this case, the child `p` element will inherit the `20px` of padding from its parent `div` element.

Inheritance is especially useful for maintaining consistency and reducing redundancy in your stylesheets.

Instead of writing the same style rule for multiple elements, you can define it once on a parent element, and the child elements will inherit it. This can make your CSS more concise and easier to manage.

However, it’s important to remember that inheritance only works in one direction – from parent to child. If you override a style on a child element, it won’t affect the parent element.


### Lecture Block: Lecture Styling Lists And Links


## How Do You Space List Items Using margin or line-height?

### Description

Margins and line-height are essential for spacing list items to enhance readability and visual appeal.

First, let's start spacing list items using margins!

Margins can be used to create space between list items by applying margin properties to the `li` elements. This method allows you to control the spacing outside each list item, effectively increasing or decreasing the gap between them.

Let's take a look at an example of an unordered list with three list items.

```html
<ul>
  <li>Item 1</li>
  <li>Item 2</li>
  <li>Item 3</li>
</ul>
```

By default, HTML will not apply that much spacing between the list items.

To apply some spacing to the bottom of each list item, you can use the `margin-bottom` property like this:

```css
li {
  margin-bottom: 40px;
}
```

In this example, `40px` of margin will be applied to the bottom of each list item inside the unordered list.

Another way to space out list items would be to use the `line-height` property.

The `line-height` property adjusts the vertical spacing between lines of text within a single list item.

While it primarily affects the spacing between lines of text within each item, it can also indirectly influence the overall spacing between list items if the items contain only a single line of text.

If list items have multiple lines of text, the `line-height` will affect the spacing between those lines, but it does not directly adjust the spacing between separate list items themselves.

To control the spacing between individual list items, you would use `margin` or `padding` properties instead.

Using the same unordered list from earlier, here is an example of applying `line-height` to the list items:

```css
li {
  line-height: 2; 
}
```

In this example, `line-height: 2;` sets the line height to be twice the font size, creating more vertical space within each list item.


## How Do the Different list-style Properties Work?

### Description

In CSS, the `list-style` property is used to control the appearance of lists on a webpage.

Whether you're working with ordered lists (`ol`) or unordered lists (`ul`), the `list-style` property allows you to customize how list items are displayed.

The `list-style` property is actually a shorthand for three other properties:

- `list-style-type`
- `list-style-position`
- `list-style-image`

Each one plays a different role in defining the appearance of lists.

The `list-style-type` property allows you to define the type of bullet point or number used in a list.

For unordered lists, you can choose from several bullet styles, such as discs, circles, or squares.

For ordered lists, you can use different numbering systems, like decimal, Roman numerals, or even alphabetical characters.

Here’s an example of using `list-style-type`:

```html
<ul style="list-style-type: square;">
  <li>Item 1</li>
  <li>Item 2</li>
  <li>Item 3</li>
</ul>
```

In this example, the bullet points of the unordered list are changed to squares.

The `list-style-type` property is the most commonly used of the three, as it directly affects the appearance of the bullet or numbering style in your lists.

The `list-style-position` property controls the position of the bullet or number in relation to the list item’s content. There are two values you can use: `inside` and `outside`.

When you use the value `outside`, the bullet or number appears outside the content, which is the default behavior.

And, when you use the value `inside`, the bullet or number appears inside the content, which may cause the text to wrap and align with the bullet or number.

Here’s an example of using `list-style-position`:

```html
<ul style="list-style-position: inside;">
  <li>Item 1</li>
  <li>Item 2</li>
  <li>Item 3</li>
</ul>
<ul style="list-style-position: outside;">
  <li>Item 4</li>
  <li>Item 5</li>
  <li>Item 6</li>
</ul>
```

In this example, both `inside` and `outside` values are provided for two different unordered list tags.

The `list-style-position` property can be useful when you want to control the alignment of the list content, especially in situations where you have multiple lines of text in a single list item.

The `list-style-image` property allows you to use an image as the bullet point for your list items. This can be useful for adding a unique visual style to your lists.

Here’s an example of using `list-style-image`:

```html
<head>
  <style>
    ul {
      list-style-image: url('freeCodeCamp-logo.svg');
      list-style-position: inside;
    }
  </style>
</head>
<body>
  <ul>
    <li>Item 1</li>
    <li>Item 2</li>
    <li>Item 3</li>
  </ul>
</body>
```

In this example, the bullet points are replaced by a custom freeCodeCamp logo, adding a personalized touch to the list.

When using `list-style-image`, make sure the image you choose is small and appropriate for the design of your webpage. If the image is too large or complex, it can make the list harder to read.

You can combine the three properties – `list-style-type`, `list-style-position`, and `list-style-image` – into a single `list-style` shorthand property.

The order of the values in the shorthand doesn’t matter, but all three can be specified together.

Here’s an example using the shorthand property:

```html
<ul style="list-style: square inside url('https://cdn.freecodecamp.org/curriculum/cat-photo-app/relaxing-cat.jpg');">
  <li>Item 1</li>
  <li>Item 2</li>
  <li>Item 3</li>
</ul>
```

In this example, the list items use square bullets, positioned inside the content, with a custom image as the bullet.

However, if the image is unavailable or not rendered, the square bullets will be used as a fallback.


## Why Are Default Link Styles Important for Usability on the Web?

### Description

Default link styles play a crucial role in enhancing usability and accessibility on the web.

These styles, typically blue for unvisited links and purple for visited links, have become a standard that users have come to expect and rely on when navigating websites.

The primary purpose of default link styles is to provide clear visual cues that help users distinguish between interactive and non-interactive elements on a webpage.

This distinction is fundamental to creating an intuitive and user-friendly browsing experience.

Let's consider the basic default styles for links:

```css
a:link {
  color: blue;
  text-decoration: underline;
}

a:visited {
  color: purple;
}
```

These styles serve several important functions.

Firstly, the blue color for unvisited links stands out against most background colors and text, making links easily identifiable. This contrast is crucial for users to quickly scan a page and find navigational elements or important information.

The underline further emphasizes that the text is clickable, providing an additional visual cue. This is particularly helpful for users who may be colorblind or have difficulty distinguishing colors.

The change in color for visited links (typically to purple) helps users keep track of where they've been. This feature is invaluable for navigating large websites or conducting research, as it prevents users from inadvertently revisiting the same pages.

Consider this HTML example:

```html
<p>Learn more about <a href="https://www.example.com/cats">cats</a> and <a href="https://www.example.com/dogs">dogs</a>.</p>
```

Without any custom CSS, most browsers will render these links in blue with an underline. After clicking on one of the links, its color will change to purple, providing immediate feedback to the user about their browsing history.

While it's common for designers to modify these default styles to match a website's aesthetic, it's crucial to maintain the core principles behind them.

If you choose to change the default styles, ensure that links are still clearly distinguishable from regular text, there's a visible difference between visited and unvisited links, and the chosen colors provide sufficient contrast with the background.

For example, you might use a custom style like this:

```css
a:link {
  color: blue;
  text-decoration: none;
  border-bottom: 1px solid blue;
}

a:visited {
  color: purple;
  border-bottom: 1px solid purple;
}
```

This maintains the blue and purple color scheme while replacing the underline with a bottom border for a more modern look.

It's also important to consider the different states of links. In addition to the default and visited states, links typically have hover and active states:

```css
a:hover {
  color: red;
}

a:active {
  color: darkorange;
}
```

These states provide immediate feedback to users as they interact with links, enhancing the overall usability of the site.

In conclusion, while it's possible to customize link styles, the principles behind the default styles should be maintained.

They play a crucial role in creating a usable and accessible web experience, helping users navigate and interact with content effectively.

Always prioritize clarity and user experience when designing link styles for your websites.


## How Do You Style the Different Link States?

### Description

There are different states of a link, including `link`, `visited`, `hover`, `focus`, and `active`. These states are important for helping users recognize links and providing clear feedback after interactions, which improves both usability and accessibility.

Styling these different link states is crucial for usability and accessibility, as it provides visual cues about the current state of the link. This helps users understand which links they have visited, which link they are interacting with, and what will happen when they click.

For users with visual impairments or cognitive disabilities, these distinct styles can make navigation much easier and more intuitive.

Additionally, clear link states enhance the overall user experience by providing immediate feedback on user interactions, reducing confusion and improving the site's navigability.

These states can be styled using something called `pseudo-classes` in CSS.

A pseudo-class is a keyword added to a selector that specifies a special state of the selected element.

For example, `:hover` can change a button's color when the user's pointer hovers over it, while `:visited` can change the color of a link that has already been visited.

Pseudo-classes allow you to style elements based on their state or the user's interaction with them, without the need for additional markup in your HTML.

The syntax of a `pseudo-class` looks something like this where `A` is the selector and `:B` is the `pseudo-class`:

```css
A:B {
  property: value;
}
```

To better understand how to style the different link states, let's take a look at some examples.

The `:link` pseudo-class styles unvisited links, indicating that they are clickable.

Here is an example of targeting an anchor element and using the `:link` pseudo-class:

```css
/* Normal state (unvisited link) */
a:link { 
  color: red;
}
```

The above example will change the link's default blue color to `red` when it is unvisited.

`:visited` styles links that have already been visited or clicked, helping users track which links they have clicked before. Here’s an example usage of `:visited` pseudo-class:

```css
/* Visited link */
a:visited {
  color: green;
}
```

This code will color the link to `green` when it is clicked.

`:hover` changes the link's style when the user hovers over it, providing a visual cue that the link is interactive. Here’s an example usage of `:hover` pseudo-class:

```css
/* Hover state */
a:hover {
  color: yellow;
}
```

This code will color the links to `yellow` when mouse is hovered over it.

`:focus` adds styles around the link when it is focused, such as when navigating with a keyboard, or enhancing accessibility.

Here is an example using the `outline` property to apply a solid orange outline when the link is focused.

```css
/* Focus state */
a:focus {
  outline: 2px solid orange;
}
```

`:active` changes the link's styles while the link is being clicked, providing immediate feedback to the user that their action is being registered. Here’s an example usage of `:active` pseudo-class:

```css
/* Active state */
a:active {
  color: pink;
}
```

This code example will make the link to `pink` color immediately when the link is clicked.


### Lecture Block: Lecture Working With Backgrounds And Borders


## How Do Background Image Size, Repeat, Position, and Attachment Work?

### Description

When working with background images in CSS, you have several properties at your disposal to control how these images are displayed.

The main properties we'll focus on are `background-size`, `background-repeat`, `background-position`, and `background-attachment`.

Let’s first take a look at the `background-image` property:

```css
body {
  background-image: url("https://cdn.freecodecamp.org/curriculum/cat-photo-app/relaxing-cat.jpg");
}
```

The above CSS sets a cat background image for the `body` element.

If you want to set the size for the background image, you can use the `background-size` property.

You can use `contain` to scale the image as large as possible without cropping or stretching.

Here's an example with `background-size: contain`:

```css
body {
  background-image: url("https://cdn.freecodecamp.org/curriculum/cat-photo-app/relaxing-cat.jpg");
  background-size: contain;
  min-height: 100px;
}
```

We are setting the `min-height` to `100px` so the background image is visible and the layout maintains a baseline height, ensuring that even with minimal content, the design appears balanced and visually appealing.

If we change the `background-size` property to use the `cover` value, then the background image will scale to cover the entire `body` element while maintaining its aspect ratio.

```css
body {
  background-image: url("https://cdn.freecodecamp.org/curriculum/cat-photo-app/relaxing-cat.jpg");
  background-size: cover;
  min-height: 100px;
}
```

In the previous examples, you probably noticed that the background image would continuously repeat.

By default, background images repeat both horizontally and vertically to fill the entire element. However, you can control this behavior.

You can use the `background-repeat` property with the value set to `no-repeat`.

```css
body {
  background-image: url("https://cdn.freecodecamp.org/curriculum/cat-photo-app/relaxing-cat.jpg");
  background-size: contain;
  background-repeat: no-repeat;
  min-height: 100px;
}
```

With the `background-size` set to `contain` and the `background-repeat` set to `no-repeat`, the image will no longer repeat on the screen.

If you wanted to repeat the background image horizontally, you can use the `repeat-x` value for the `background-repeat` property.

```css
body {
  background-image: url("https://cdn.freecodecamp.org/curriculum/cat-photo-app/relaxing-cat.jpg");
  background-size: contain;
  background-repeat: repeat-x;
  min-height: 100px;
}
```

If you wanted to repeat the background image vertically, you can use the `repeat-y` value for the `background-repeat` property.

```css
body {
  background-image: url("https://cdn.freecodecamp.org/curriculum/cat-photo-app/relaxing-cat.jpg");
  background-size: contain;
  background-repeat: repeat-y;
  min-height: 100px;
}
```

To position a background image on the screen, you can use the `background-position` property.

The `background-position` property allows you to set where in the element the background image appears. You can use keywords like `top`, `bottom`, `left`, `right`, and `center`, or specific pixel or percentage values.

Here is an example using the `center` and `top` for the `background-position`:

```css
body {
  background-image: url("https://cdn.freecodecamp.org/curriculum/cat-photo-app/relaxing-cat.jpg");
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center top;
  min-height: 100px;
}
```

This CSS code positions the background image at the center of the element horizontally and at the top vertically.

Lastly, `background-attachment` determines whether the background image scrolls with the content or remains fixed when the page is scrolled.

The main values are `scroll` (default), where the background image scrolls with the content, and `fixed`, where the background image stays in the same position on the screen.

Here is an example using the `fixed` value for the `background-attachment` property:

```css
body {
  background-image: url("https://cdn.freecodecamp.org/curriculum/cat-photo-app/relaxing-cat.jpg");
  background-position: center top;
  background-attachment: fixed;
}
```

This CSS code sets the background image to remain fixed in place even when the page is scrolled.

If you wanted to combine a few of the properties into one line, you can do that by using the shorthand `background` property.

Here is an example:

```css
body {
  background: center top fixed
    url("https://cdn.freecodecamp.org/curriculum/cat-photo-app/relaxing-cat.jpg");
}
```

The above example combines the `background-image`, `background-position`, and `background-attachment` into a single line.

By mastering these properties, you'll have great control over how background images are displayed in your web designs, allowing for more visually appealing and functional layouts.


## What Is a Background Gradient, and How Does It Work?

### Description

A background gradient in CSS is a smooth transition between two or more colors that can be applied to the background of an element. Gradients allow you to create visually appealing backgrounds without needing images.

There are two main types of gradients in CSS: linear gradients and radial gradients.

A linear gradient transitions colors along a straight line. You can define the direction and the colors involved.

Here is the basic syntax:

```css
background: linear-gradient(direction, color-stop1, color-stop2, ...);
```

In this example, we are using the `background` CSS property with a value of the `linear gradient`.

The direction specifies the direction of the gradient. It can be an angle (such as `45deg`), a keyword (such as `to right`, `to bottom`), or a side/corner.

`color-stop` specifies the colors and positions where the gradient transitions occur.

To better understand how linear gradients work, let's take a look at the following example:

```css
.linear-gradient{
  background: linear-gradient(to right, red, yellow);
  height: 40vh;
}
```

This CSS creates a linear gradient that transitions from `red` on the `left` to `yellow` on the `right`. The gradient is applied to an element with a height of `40%` of the viewport height. You'll learn more about `vh` units in a future lecture.

The `to right` direction means the gradient runs horizontally from left to right.

Another type of gradient would be the `radial` gradient.

A radial gradient transitions colors radiating from an origin (usually the center) outward in a circular or elliptical shape.

Here is the basic syntax:

```css
background: radial-gradient(shape size at position, color-stop1, color-stop2, ...)
```

On the syntax, the `shape` specifies the shape of gradient which could be `circle` or `ellipse`.

The `size` determines the size of the gradient's ending shape which could be `closest-side`, `closest-corner`, `farthest-side`, `farthest-corner`, `contain`, or `cover`.

`position` determines the position of the gradient's center which could be specified using keywords (such as `center`, `top left`, `bottom right`) or precise values (such as `50% 50%`, `10px 20px`).

Lastly, color stops are a list of colors that the gradient transitions through. Each color stop can optionally include a position value (percentage or length) indicating where the color should be placed.

An example would be:

```css
.radial-gradient{
  background: radial-gradient(circle closest-side at center, red, yellow 50%, green);
  height: 60vh;
}
```

This CSS creates a circular radial gradient centered in the element. It starts with `red` at the center, transitions to `yellow` at `50%` of the radius, and ends with `green`.

The `closest-side` keyword makes the gradient's ending shape fit the closest side of the element. The gradient is applied to an element with a height of `60%` of the viewport height.

Understanding how to work with CSS gradients can significantly enhance your designs by providing visually appealing backgrounds without the need for images.

With options like linear gradients for smooth transitions and radial gradients for circular effects, they offer both flexibility and creativity in web design.


## What Are Some Accessibility Considerations for Backgrounds?

### Description

In web design, backgrounds play a vital role in defining the overall look and feel of a webpage.

However, when designing with backgrounds, it's crucial to consider accessibility to ensure your content is usable and readable by all users, including those with visual impairments.

One of the primary accessibility concerns related to backgrounds is ensuring that there is sufficient contrast between the background and the text.

Without adequate contrast, users with visual impairments, including those with low vision or color blindness, may struggle to read the content on your page.

Contrast refers to the difference in lightness or darkness between two colors. Sufficient contrast between the background color and the text color is essential for readability.

The Web Content Accessibility Guidelines (WCAG) recommend a minimum contrast ratio of 4.5:1 for normal text and 3:1 for large text.

For example, placing white text on a light-gray background would result in poor contrast, making the text difficult to read. However, white text on a dark-blue background would provide good contrast, enhancing readability for all users.

Here’s an example of poor contrast:

```html
<p style="color: lightgray; background-color: whitesmoke;">
   This is an example of poor contrast.
</p>
```

Now, here’s an example of good contrast:

```html
<p style="color: white; background-color: darkslategray;">
  This is an example of good contrast.
</p>
```

Another consideration is avoiding placing text over busy or complex backgrounds, such as images or gradients with multiple colors. Busy backgrounds can make it hard to distinguish the text from the background, regardless of the contrast.

If you must use a background image, it’s a good idea to apply a semi-transparent overlay or a solid color behind the text to make it more readable. Here's an example of how you can do this:

```css
.background-image-text {
  background-image: url('fcc-logo.svg');
  color: white;
  padding: 20px;
  background-color: rgba(0, 0, 0, 0.75);
}
```

This code places a semi-transparent black overlay behind the text, improving its readability against the background image.

When designing backgrounds, avoid using color as the sole means of conveying information. For example, using just color to indicate an error or success message (such as red for error or green for success) can be problematic for users with color blindness.

In addition to color, you should use symbols or text to convey information. For example, alongside a red error message, you could use an icon or bold text to make it clear that there’s an error.

Though less common, background audio or videos can also affect accessibility.

Background music or auto-playing videos can be distracting for some users, particularly those with cognitive disabilities. If you include background audio, always provide a way for users to mute or pause the audio.

By taking these accessibility considerations into account, you can create more inclusive designs that ensure your content is readable and usable by all users, regardless of their abilities.


## What Are the Different Ways You Can Add Borders Around Images?

### Description

In CSS, there are several ways to add borders around images, each offering different styling options and levels of control.

Let's explore some of the most common and versatile methods.

The most straightforward way to add a border to an image is by using the `border` property. This property is a shorthand that allows you to set the width, style, and color of the border all at once.

```css
img {
  border: 2px solid red;
}
```

This CSS rule adds a 2-pixel wide, solid red border around all `img` elements. You can adjust the width, style (such as `dashed`, `dotted`, or `double`), and color to suit your design needs.

If you need more control over individual sides of the border, you can use the specific border properties for each side:

```css
img {
  border-top: 1px solid red;
  border-right: 2px dashed green;
  border-bottom: 3px dotted blue;
  border-left: 4px double yellow;
}
```

This allows you to create unique border styles for each side of the image.

Another way to create a border effect is by using the `outline` property. While similar to border, outline doesn't affect the element's dimensions or layout:

```css
img {
  outline: 3px solid gold;
}
```

This creates a gold outline around the image without changing its size or position.

If you want to create rounded corners on your border, you can use the `border-radius` property in conjunction with border:

```css
img {
  border: 2px solid black;
  border-radius: 10px;
}
```

Remember, these techniques can be combined and customized to create unique border effects. The choice of method depends on your specific design requirements and the level of complexity you need.


## Module: Design For Developers


### Lecture Block: Lecture User Interface Design Fundamentals


## What Are Common Design Terms to Help You Communicate with Designers?

### Description

As a developer, you may need to work closely with designers. If you understand basic design terminology, you'll have a shared vocabulary and you'll be able to participate in the design process more actively. This can make your workflow more efficient and result in a better user experience.

So let's dive in. We'll start with the term layout. Layout is how the visual elements are arranged on a page or screen to communicate a message. These elements may include text, images, and white space. The layout is like the blueprint of a design. Designers must consider the placement, size, and hierarchy of each element.

The term that is closely related to layout is alignment. Alignment is how the elements are placed in relation to one another. Using alignment correctly is helpful for making the design look clean and organized. Designers create visual order by aligning elements along imaginary lines, edges, or a central point.

Great. Now let's talk about composition. Composition is the art of arranging elements to create a harmonious design. It determines how elements like images, text, and shapes relate to each other and contribute to the design in an artistic way. While layout mostly focuses on the placement of the elements, composition also considers the artistic impact that this placement will have in the overall design.

Composition is closely related to concepts of balance. Balance is how the visual weight is distributed within a composition. Designers aim to create an equilibrium through symmetrical or asymmetrical arrangements. A balanced design feels harmonious.

Hierarchy is another important concept that you should know. Hierarchy establishes the order of importance of the elements in a design. It's about making sure the most important information is noticed first. You can implement a visual hierarchy with size, color, contrast, alignment, white space, and even typography.

To create clear distinctions between the elements, you can use contrast. Contrast is helpful for guiding user attention to what you want to emphasize. You can do this through variations in color, size, shape, texture, or any other visual characteristic. Strong contrast is also helpful for improving readability.

Another helpful term is white space. White Space, also known as "negative space", is the empty space in a design. It's the area surrounding the elements. You might be surprised to know that white space is not necessarily white. Actually, it can be space in any color or texture. Its purpose is to improve the readability and enhance the visual hierarchy of a design.

These are general design concepts that you will find very often, but you may also find design terms that are more closely related to software development.

The user interface, also known as UI, is how humans interact with computers. A user interface includes the visual and interactive elements that users can see on their screens, like icons, images, text, menus, links, and buttons.

The user experience, also known as UX, is about how users feel when using a product or service. An application with a well-designed user experience is intuitive, easy to use, efficient, accessible, and enjoyable. The user interface plays a key role in making the user experience as easy and enjoyable as possible, so they are very closely related.

These are some of the common terms that you should know to communicate with designers. With this knowledge, now you can take a more active role in the design process.


## How Do You Create Good Background and Foreground Contrast in Your Designs?

### Description

First, you may need to familiarize yourself with contrast. Contrast is the difference between two colors - or how easy it is to tell them apart.

Colors with a higher contrast will be more visually distinct, whereas colors with a lower contrast will be more visually similar. For example, black and white have a very high contrast ratio. Whereas light blue and light purple have less of a contrast.

Of course, in these examples the distinction might be made clearer because of the layout. But what about applying these colors to text? You can have the high contrast black text on a white background. And the low contrast purple text on a blue background.

But how do you determine what is a "good enough" contrast? You can't base it solely on how the text looks to you, as every user will have a different experience. Thankfully, the Web Content Accessibility Guidelines, or WCAG, provide a standard for this. 

Text with a contrast ratio of 4.5:1 is considered the AA standard, which is the bare minimum you should follow to be accessible to most users. Text with a contrast ratio of 7:1 is considered the AAA standard, and ensures the best level of accessibility.

There are a number of websites that can check the contrast ratio between two colors, but most browsers will allow you to do this directly in the developer tools on your website.

Let's open the developer tools and inspect the text elements of the example site.

The black text on a white background has a contrast ratio of 21:1, which more than meets the AAA standard. The purple text on a blue background, however, has a contrast ratio of 1.48:1, which does not even meet the AA standard.

How can you fix this? Well, there are three aspects that impact the contrast ratio.

The first is the hue, which represents the general color type, like red, blue, orange. Let's shift to a hue that is further away from blue. In this case, let's use red.

Unfortunately, this change only brought the contrast ratio to 1.49:1,  which means you need to change the saturation, or the "amount" of color present. Let's increase the amount of red in the text. That brings us much closer to the goal, with a 3.54:1 contrast ratio.

However, you can potentially get even closer by changing the last value, which is lightness. Lightness represents how much white is present in the color.

Let's decrease the lightness of the red. Now there is a much darker red against the light blue background, which brings the contrast ratio to 10.34:1.

You could continue to adjust the colors to find the balance between the visual effect you want and an accessible contrast ratio. But it is important to remember that accessibility should always take precedence.


## What Is the Importance of Good Visual Hierarchy in Design?

### Description

Visual hierarchy refers to the way you layout and display the content of your page to guide the viewer's attention. 

A strong hierarchy can provide a clear path for the eye to follow, ensuring that the information you convey is consumed in the order that you intended.

Let's consider a basic page layout in which the HTML for the page is semantically correct, but the styling applied does not create a strong visual hierarchy.

If the font size isn't distinct, there is no visible indication of the document flow, although things are separated by headings.

To create a visual hierarchy, you should apply different font sizes to the heading tiers. You could also use something like a "callout box" to highlight a specific section.

Visual hierarchy can also help increase your user conversion. For example, you can take advantage of the callout box to further draw attention to a Call to Action (CTA) button.

With the CTA button being visually tied to the work history section, it guides the user to the vital information and the action you want them to take based on that information.

Finally, your visual hierarchy can be important for conveying other components, like a navigation bar or a footer.

This makes it easier for your users to find the essential information that they may be looking for.


## How Does Scale Work in Design?

### Description

The "scale" of something refers to its size. 

When you're looking at scaling in your web design, you're looking at the size relationships between different elements, and how these elements might adapt to different screen sizes.

Using the correct scale for your elements plays an important role in visual hierarchy. Larger elements will draw more attention, which can guide your users through the content in the way that you want.

For example, the visual separation between a heading and a paragraph draws your reader’s attention, but the scale should be appropriate to get an eye-catching text that pulls your reader to that section.

Scale doesn't apply just to text, though. It's also important for images. And while the scale of a banner image might make sense for a desktop layout, it might be too large on a mobile layout.

By scaling an image down to a more appropriate ratio, you can keep the visual impact while ensuring the information on the site is visible.

Scale is also important for interactivity, and the ability to actually use your website. If the text in a navigation bar is not at an appropriate scale, mobile phone users will have a hard time tapping on the links. 

And if you scale it appropriately, you end up with links that are not only easier to read, but easier to click on for your mobile users.

There are many ways that scale is important in your designs. We've covered the basics, so you should now have a fundamental understanding of its importance.


## How Does Alignment Work in Design?

### Description

When you are designing web pages, it is important to create cohesive and visually appealing designs. One way to achieve this is through the use of alignment.

Alignment is the process of arranging text and images in a way that creates a visual connection between elements.

It helps to create a sense of order and organization on the page, making it easier for users to navigate and understand the content.

There are several types of alignment you can use, but the basic ones are:

- left alignment
- center alignment
- right alignment
- justified alignment
- vertical alignment

Left, right, and center alignments are all subtypes of horizontal alignment, while vertical alignment is used to align elements along a vertical axis.

Let's take a closer look at each type of alignment and how you can use them in your designs.

Left alignment is commonly used with text where each element is aligned to the left margin. Aligning all of the headings and paragraphs on a web page to the left margin makes it easier for the user to read and follow the content.

The opposite of left alignment is right alignment, where each element is aligned to the right margin. This is often used on websites to display additional content like promotional banners or advertisements.

For example, an ad that is aligned to the right margin makes it stand out from the rest of the content on the page but doesn't distract the user from the main content.

Center alignment is where elements are centered on the page. This is often used for headings, logos, and other important elements that you want to draw attention to.

Justified alignment is when text is aligned to both the left and right margins. This is typically used for descriptive passages or articles, and creates a clean and professional look.

The last type of alignment is vertical alignment, which is used to align elements along a vertical axis.

Vertical alignment can be used, for example, for a contact form on a website. Aligning all of the form inputs like the name, email, and message fields along a vertical axis makes it easier for the user to fill out the form.

By using different types of alignment, you can create a sense of order and organization on the page that makes it easier for users to navigate and understand the content.


## What Is the Importance of Whitespace in Design?

### Description

White space refers to any type of space around elements like images, text, and buttons. White space is important in design because it helps to create a balance between the elements on the page.

Let's take a look at some examples of how white space can be used effectively in design.

For example, let's consider a call-to-action (CTA) button. CTAs are used to encourage users to take a specific action like signing up for a newsletter or making a purchase.

By using white space effectively, we can help to make a CTA button more prominent and encourage users to click on it.

Now let's take a closer look at the different types of white space.

This first example uses both macro and active white space. Macro white space is the space between larger elements like images, text blocks, and buttons.

Active white space is the space that is intentionally created to help guide the user's eye and draw attention to certain elements on the page.

In contrast to active white space, there is also passive white space. Passive white space is the space that is left over after all the elements on a page have been placed.

Another type of whitespace would be micro white space. This is the space between individual characters in a line of text.

Micro white space is important because it helps to improve readability and legibility, making it easier for users to scan and understand the content.

When designing your web pages, you always want to be mindful of the law of proximity. This law states that elements that are close together are perceived as being related, while elements that are far apart are perceived as being unrelated.

You can use white space to help group related elements together and help navigate users through the content on your page.


## What Are Best Practices for Working with Images in Your Designs?

### Description

Adding images to your websites is a great way to engage your users and increase the visual appeal of your site. But there are a few things to consider when working with images in your designs.

The first thing to consider is creating responsive images. Responsive images are images that scale to fit the size of the screen they are being viewed on. This is important because it ensures that your images look good on all devices, from desktops to mobile phones.

Another thing to consider is the resolution for images. Higher quality images with better resolution have more pixels per inch. Pixels are small squares that make up an image.

Pixels per inch, or PPI, is the number of pixels in one inch of an image. The higher the PPI, the better the image quality.

You want to make sure that your images are high quality and look good on all devices. This means that you should use high resolution images that are optimized for the web.

Another thing to consider is the size of your images and how they fit within the spaces in the layout. You want to make sure that your images are the right size and are not too large or too small.

Using large images that are meant to fit in smaller spaces in the design can slow down your website and make it harder for users to load your site. You want to make sure that your images are the right size and are optimized for the web.

When it comes to image placement, you want to think about balance, hierarchy, and alignment to help ensure your images are optimized for the web.

Balance is the distribution of visual weight in a design. You want to make sure there is a good balance between text and images on the site so it creates a harmonious design.

Hierarchy is the order in which elements are viewed on a page. You want to make sure that images that align with important content are placed higher than images that are less important.

Alignment is the placement of elements in relation to each other. You want to make sure that your images are aligned with the text and other elements on your site so that it creates a cohesive design.

The last thing to consider is accessibility for images. You want to make sure that your images are accessible to all users, including those with visual impairments. This means that you should use alt text for your images so that screen readers can read the text to users who are visually impaired.


## What Is Progressive Enhancement?

### Description

Progressive enhancement is a design approach that ensures all users, regardless of browser or device, can access the essential content and functionality of an application. 

It focuses on delivering a core experience that works for everyone, while offering extra features and improvements to users with more advanced browsers or better internet connections.

The progressive enhancement approach lives by these core principles:

- All core content and basic functionality should be accessible on all browsers
- All advanced layouts should be provided through external CSS stylesheets
- All advanced functionality should be provided through external JavaScript files
- A user's browser preferences should be respected

Using a progressive enhancement approach makes your applications more accessible because all core content and functionality should not be blocked in unsupported environments. 

In terms of speed, a progressive enhancement approach can also help improve the performance of your applications. 

Those users that are working with slower internet connection speeds will still be able to access the content because the browser will download the necessary resources first.

When it comes to SEO, progressive enhancement can also help improve the visibility of your applications. 

Search engines will be able to crawl the content of your applications because the core content is available in the initial HTML response.

While some have criticized this approach deeming that it is not always realistic for applications that rely heavily on JavaScript for their functionality, it is still a good practice to follow when building applications.


### Lecture Block: Lecture User Centered Design


## What Is User-Centered Design?

### Description

User-centered design is a web development approach that prioritizes the end user, from their needs to their preferences and limitations. The goal of user-centered design is to craft a web page that is intuitive, efficient to use, and pleasing for your users to interact with.

One of the first aspects of user-centered design is considering your target demographics. For example, if your intended user-base is younger, you might leverage more flashy eye-catching designs that grab their attention immediately. For an older audience, you might focus more on clear and streamlined designs without distractions.

Another aspect to consider is the goal of your end users. For example, if you're building an e-commerce page for your products, you probably don't want to advertise someone else's products on your page. But if you're building a personal blog, you might include advertisement elements to generate revenue from passive readers.

User behavior is an important factor as well. You'll want to leverage an analytics tool, like Google Analytics, to measure how your users engage with your pages. This can reveal areas where users might be getting "stuck" and leaving your page, or opportunities to improve the overall interaction flow.

A key to user-centered design is to actually involve your users. Providing a feedback channel where they can share their experiences and pain points with your site allows you to capture vital information and iterate further to improve. Ultimately, user-centered design means you need to put the user at the forefront of your decision making, whether that's through research or direct feedback.


## What Are User Requirements, User Research, and Testing?

### Description

User research is the systematic study of the people who use your product. The goal is to measure user needs, behaviors, and pain points.

User research comes in many forms. Perhaps one of the most common is the Net Promoter Score, or NPS. The NPS measures how likely your users are to recommend your product to a friend. NPS is measured through a survey offered at key milestones along the user's journey, such as after 7 days, 30 days, and 90 days. NPS is measured on a scale of 0 to 10, with 9 and 10 indicating an active promoter of your site.

Another research vector is an exit interview. This is a survey you show to your users when they cancel a subscription or delete an account. Data from this survey can give you insight into the factors causing user churn, so you can address them.

User testing, on the other hand, refers to the practice of capturing data from users as they interface with your application. For example, a video game going through beta testing is a form of user testing. One you might run into as a web developer is A/B testing. A/B testing involves shipping a new feature to a randomly selected subset of your user base. You can then leverage analytics data to determine if the feature is beneficial.

Finally, user requirements refer to the stories or rubric that your application needs to follow. This can inform the development process. User requirements might be defined by user research, or industry standards. They can even be defined by stakeholder input.

These requirements may be functional, meaning they dictate how your application should work, or non-functional, meaning they define how your application should behave. User requirements are not static, either. The information from both user testing and user research can impact the requirements, and they will change as your user base changes.

Understanding the difference is essential for collecting the most accurate data so you can deliver the best experience for your end users.


## What Are Best Practices for Designing a Dark Mode Feature?

### Description

Dark mode is a special feature on web applications where you can change the default light color scheme to a dark color scheme. This helps reduce eye strain and improve readability in low-light conditions. When designing your dark mode features, it is important to understand best practices to ensure that your dark mode feature is effective and user-friendly.

The first consideration is the avoidance of saturated colors in dark mode. Saturated colors are colors that are bright and intense. For example, a bright magenta button against a dark gray background can be too intense and cause eye strain. Instead, you should use desaturated colors in dark mode. Desaturated colors are colors that are less intense, have a lower saturation level, and more comfortable to look at in dark mode.

Another consideration with dark mode is the use of pure black backgrounds with white text. While this high contrast can be effective, it can also be too harsh on the eyes. Instead, consider using a dark gray background with light gray text for a softer contrast. Text will be easier on the eyes and more comfortable to read in dark mode.

Another consideration is the use of dark mode with the site's brand identity. A brand identity is a set of visual elements that represent a brand, such as the logo, colors, and typography. When implementing dark mode, you should consider how the dark mode feature is consistent with your brand's colors and style. It is fine to have the brand icon and buttons at full saturation, while the surrounding elements are desaturated.

In general, when it comes to design, you always want to be mindful of the user experience and contrast levels. Dark mode is no exception, and by following these best practices, you can create a dark mode feature that is effective and user-friendly.


## What Are Best Practices for Designing Breadcrumbs?

### Description

When it comes to web design, there are many types of navigational aids you can use. Examples include top navigation bars, sidebars, and footers. But if your site is on the more complex side with deeper levels of navigation, you might want to consider using breadcrumbs.

Breadcrumbs are a navigation aid that shows the user where they are in the site's hierarchy. Here is an example of what breadcrumbs look like for a mock-up electronics website:

```md
Home / Electronics / Phones / Smartphone XYZ
```

In most websites, breadcrumbs are displayed at the top of the page, showing the user the path they took to get to the current page. Starting from the `Homepage`, the user navigated to the `Electronics` category, then to the `Phones` category, and finally to the `Smartphone XYZ` product. You have probably interacted with breadcrumbs on a website as you were searching for a product or specific piece of information.

The use of breadcrumbs is helpful because it can help users understand where they are in the site's hierarchy and how to navigate back to the previous pages. This is especially useful when a user has come from a search result or an external link and needs to understand the context of the page they are on.

When it comes to designing breadcrumbs, there are a few considerations to keep in mind. The first is to decide on what the separator will be. The separator is the character that separates the different levels of the hierarchy. Common separators include the greater than sign (`>`), right angle quotation marks (`»`) ,and the forward slash (`/`).

The second consideration is the placement of the breadcrumbs. Breadcrumbs are typically placed at the top of the page, either above or below the main navigation bar. Users shouldn't have to struggle to find the breadcrumbs, so make sure they are visible and easy to locate.

Another consideration is the size of the breadcrumbs. You want to make sure the breadcrumbs are large enough to be easily read, but not so large that they take up too much space on the page. Remember, the breadcrumbs aren't meant to serve as a primary navigation tool, but rather as a secondary navigational aid. In websites where there is a lot of information on a page, users can easily see where they are in the hierarchy and navigate back to previous pages using breadcrumbs.

So when should you use breadcrumbs on your site? If your site is simple and has a shallow hierarchy, breadcrumbs might not be necessary. A shallow hierarchy means that the site has only a few levels of navigation, so breadcrumbs might not add much value. Typically, you will see breadcrumbs on e-commerce sites, news sites, and other sites with a deep hierarchy like technical documentation sites.


## What Are Best Practices for Designing Cards?

### Description

Card components are a very common occurrence in e-commerce, social media, and news sites. They are used to help display information in a structured way. When you are designing your cards, it is important to understand best practices so your users can easily understand the information you are trying to convey.

The first consideration for card design should be simplicity. You don't want your cards to be visually cluttered or display too much information. For example, if a card design is visually cluttered, there will be too much information for the user to process all at once. Having less information and good spacing between items on the card makes it easier for the user to process the information, and allows for multiple cards on the page.

Another thing to consider is where the user can click on the card. Some card designs will have a single button, making it obvious where the user can click. Other card designs will have the entire card clickable. When the user hovers over any part of the card, the card will change color or have a shadow effect to indicate that the card is clickable. Whatever design you choose, it needs to be consistent throughout your site and easy for the user to understand. 

Another consideration is the use of media on your cards. Choosing high-quality media can significantly enhance the user experience. If you are using images or videos for say a product card, the higher the quality the more the user will be interested in that product. But if you use poor media quality, then the user might not trust the quality of your products and services. 

One of the last things to consider is the use of color hierarchy. You want to make sure that the most important information on the card is the most prominent. You can use bright colors for important elements like a call-to-action button, and light colors for less important items on a card.

As you continue to work on web applications, keep in mind the different best practices for card design. This will help you create better user experiences for your users.


## What Are Best Practices for Designing Infinite Scrolls?

### Description

Infinite scrolling is a design pattern that loads more content as the user scrolls down the page. Oftentimes, this is used on social media sites like Twitter. For example, if you are logged in and want to see more tweets, you can scroll down and more tweets will load. This is an example of infinite scrolling.

Infinite scrolling is also used as a substitute for pagination. Pagination is a design pattern that breaks up content into pages. This is often used when there is a lot of content to display. An example of pagination is when you search for something on Google and you see the search results on multiple pages. With pagination, you have to click on a button to go to the next page. With infinite scrolling, you just keep scrolling down and more content will load.

As you incorporate infinite scrolling into your design, there are a few best practices to keep in mind. The first consideration is to provide a "Load More" button that loads the next set of results when the user clicks on it. This is a good way to give the user control over when they want to see more content.

Another consideration would be to add a "Back" button. This gives users the ability to go back to the previous page without having to scroll all the way back up. This creates a better user experience and gives them more control over their browsing experience.

Sometimes you will see designs with a "Back to the top" button which leads users back to the top of the page of results. Another consideration is to provide a loading indicator. Users should have a clear indication that more content is being loaded; otherwise, they might think that the page is broken.

One of the last considerations would be to keep the footer accessible to the user. If the footer contains important information, then it should be accessible to the user at all times.

In conclusion, infinite scrolling is a great way to display content on your website. However, you should keep in mind the best practices when designing your infinite scroll so that you can provide the best user experience possible.


## What Are Best Practices for Designing Modal Dialogs?

### Description

What is a modal? It's the type of pop-up that a website might show you on top of their content.

The content behind a modal is usually dimmed. This helps the user visually focus on the area you want them to interact with – in this case, the modal.

It's always a good idea to allow the user to click outside of the modal to close it.

You'll often see very prominent buttons on modals. These are called CTAs, or call-to-action. You want these to be easily identifiable since the purpose of interrupting the user's flow with a modal is to prompt them to take a specific action.

Modals should also have a close button. While you may really want the user to click on your CTAs, it's important to give them an option to back out of the modal and resume whatever they were previously doing.

There are, of course, accessibility concerns with modals, such as correctly managing focus on elements. However, if you use these general practices as your starting point, you'll have a solid foundation to build on.


## What Are Best Practices for Progress Indication on Forms, Registration, and Setup?

### Description

Progress indication is a way to show users how far they are in a process. It can be used in forms, registration, and setup processes. The goal is to help users understand where they are in the process and how much more they need to do.

For example, you can use a progress indication bar to show users what is left to do when filling forms. You don't want to create a situation where the user needs to fill out a lengthy form and they don't know how many more steps they need to complete. Transparency is key so the user knows whether they have enough time to sit down and complete the form or if they need to come back later.

When designing a progress indication section, there are a few best practices to keep in mind. The first consideration is to keep it simple. You don't want to overwhelm the user with too much information where they get frustrated and leave the site.

The second consideration is to make it possible to go back to previous steps. This is important because users may want to go back and check their previous answers or make changes.

Another consideration is to make the progress indication section easy to find. If the user can't find it, they won't know how far they are in the process.

The last consideration is to have clear section titles, percentages, or steps. If you just have a progress bar with no context, the user won't know what it means.

These are just a few best practices to keep in mind when designing progress indication on forms, registration, and setup processes. Study a few examples on big websites and see how they implement progress indication. Then test your design with real users to see how well it works.


## What Are Best Practices for Designing Shopping Carts?

### Description

There are thousands of e-commerce websites on the internet, and the shopping cart is a crucial part of the e-commerce experience. A good design can make the shopping cart experience more enjoyable and increase sales. A poor design can lead to abandoned carts and lost sales.

In this lecture, we will discuss some best practices for designing shopping carts. The first design consideration is making sure the shopping cart is visible to users at all times. Most shopping cart designs will have the cart displayed in the upper right hand corner of the page. Users should see the number of items in their cart displayed next to the cart icon, and be able to click on the cart to see more details about the items they are purchasing.

Another consideration is providing a clear way for users to update the quantity of items in their cart. This can be done by providing a quantity input field next to each item in the cart. Users can easily update the quantity of an item by changing the number in the input field.

You should also provide a "Remove" button next to each item in the cart. This allows users to easily remove items from their cart. You don't want to make it difficult for users to remove items from their cart, as this can lead to frustration and abandoned carts.

Another consideration is the shopping cart icon itself. The icon should be something easily recognizable for all users. A common icon is a shopping cart with a handle and wheels. Other icons might be a shopping bag or a basket. But you don't want to choose an icon that is too abstract or difficult to understand.

When the user wants to review the total in their cart, they should be able to easily find the total cost of all items in the cart. This should be displayed prominently on the page, so users don't have to search for it.

Finally, you should provide a clear call-to-action button for users to proceed to checkout. This button should be prominently displayed on the page, so users don't have to search for it.

You don't want to have too many buttons on the page, as this can lead to confusion. The call-to-action button should be the most prominent button on the page, so users know exactly what to do next. You should use the brand's primary color for the button, so it stands out from the rest of the page.

These are just a few best practices for designing shopping carts. By following these guidelines, you can create a shopping cart that is easy to use and will help increase sales for your e-commerce website.


## What Is Progressive Disclosure?

### Description

A progressive disclosure is a design pattern used to only show users relevant content based on their current activity and hide the rest. This is done to reduce cognitive load and make the user experience more intuitive.

For example, when you use Google's search page, most of your searches will be simple. So having a simple user interface with very few options makes sense. But for the few times you will need a more advanced search, Google provides an advanced search option that will reveal more options.

You can find Google's advanced search option from the settings menu on the Google homepage. Or you can go to `google.com/advanced_search`.

Another example of progressive disclosure would be the "More details" button on products in an e-commerce website. When you visit a site like Amazon, you will see a list of product images in different categories. This allows users to shop with ease and not get overwhelmed by too much information.

If the user is interested in a particular product, they can click on the product image to reveal more details about the product. Displaying all of the information right away may be overwhelming for the user. So, by using progressive disclosure, the user can choose to see more information when they are ready.

So, what are some best practices for designing with the progressive disclosure technique? The first consideration is to keep all important information visible at all times. Users should not have to struggle to find key information because it is hidden by extra advanced features.

Another consideration is to provide a single access point for users to access additional features or information. This could be a button or link that is always visible on the page. Consider again Amazon's site: the additional product information is only made available when the user click on the product they are interested in. There aren't multiple buttons or links to click on to see the additional information. Adding multiple access points can be confusing for users and can lead to a poor user experience. 

As you design your applications, think about the overall user experience and how you can use progressive disclosure to make it easier for users to find the information they need. When done correctly it can make a big difference to the overall user experience.


## What Is Deferred and Lazy Registration?

### Description

Lazy registration is a UI design pattern that allows users to browse and interact with your application without having to register. A good example of this would be an e-commerce site. Users should be able to browse through the products and add a few items to their cart. Then, if they are interested in purchasing, they will need to register.

The reason is that users need to see the value your site offers before they are willing to provide their information and register. When designing your applications, users should be able to see the value and feel like the application is safe to provide their information. Otherwise, they will not be willing to register and you will lose potential customers.

You will need to make sure to communicate that the user's sensitive data will be protected and secure. In later modules, we will discuss how to secure your application and protect your user's data.

Another good example of lazy registration would be YouTube. YouTube is a video sharing platform with millions of videos on everything from tech, pop culture, and gaming. If you visit YouTube, users can watch as many videos as they like without needing to sign in or register. However, if they want to like, comment, or subscribe to a channel, they will need to register.

If the user likes the content they are watching or wants to participate in the conversations, then they will be more willing to register. Lazy registration is a useful design pattern that allows users to see the value of your application before they are willing to provide their information.

The next time you are designing an application, consider using lazy registration to increase user engagement and retention.


### Lecture Block: Lecture Common Design Tools


## What Are Design Briefs and How Do Developers Work with Them?

### Description

When it comes to designing new features or applications, a good first step would be to create a design brief.

A design brief is a document that outlines the objectives, goals, and requirements of a project. It is a roadmap that guides the design process and ensures that the final product meets the needs of the client.

Usually the client will write the design brief and it will serve as a working draft. Sometimes, the designer might write one and consult with the client to make sure it meets their needs.

There are a few key elements that should be included in a design brief.

The first element is the overview of the project and business. This overview should include the company's details, mission, values, unique selling points, and products or services.

The next key element should be to document the goals and objectives for the project. This should include the purpose of the project, and the desired outcomes.

Examples of goals include increasing traffic to a site or increasing the number of monthly page visits by X percent.

Another key element would be the target audience. The design brief should include information about the target demographics, interests, and needs of the audience.

You should also include information about the competition and how the project will differentiate itself from the competition.

Another key element would be the project scope. This should include the deliverables, timeline, and budget. The deliverables should include a list of all the items that will be produced as part of the project, such as mockups, and final designs.

Without clearly defining project scope, things can get out of hand and go over budget. So, it's best to be as detailed as possible about what is expected to be delivered and by when.

One of the challenging aspects about project design is the timescale and budget. It is important to be realistic about what can be achieved within the given timeframe and budget. So, having a design brief that outlines these constraints is important.

Once all of these details have been discussed and documented, the design brief should be reviewed and approved by all stakeholders before the project begins. At that point, that is when the designers can get started with their work.

So, what is the developer's role in all of this? The developer's role is to take the designs, understand the project requirements, and turn them into a working product.

This involves writing code, testing, and debugging the application to ensure that it meets the requirements outlined in the design brief.

Oftentimes, developers will work in teams where the work is split up between multiple developers.

There will also usually be a project manager who will be responsible for coordinating the work and making sure that the project stays on track.

So, while you might not be involved in the design and initial decision making process as a developer, it is still important to understand the design brief and how it will impact your work.


## What Are Some Common Tools Developers Should Know About That Are Used by Designers in the Industry?

### Description

Design is the foundation of every enterprise-level web application. That's why designers and developers work closely to create user-focused interfaces that are visually appealing and functional.

Because of this, developers should be familiar with common design tools to make the most of what designers offer. Most of these design tools excel in vector-based design and prototyping.

Vector-based design involves creating digital art using mathematical formulas to define lines, shapes, and colors. Prototyping, on the other hand, refers to the process of creating an interactive model of a product or user interface.

Let's talk about some common design tools developers should know about.

Figma is one of the most common and essential design tools that developers should know. This cloud-based tool specializes in User Interface and User Experience (UI/UX) design. It enables design and development teams to collaborate from anywhere, offering built-in features such as:

- Vector-based design
- Automatic layout
- Commenting and feedback system
- Version history
- Real-time collaboration
- Design systems, and more.

To get started with Figma, you can use the web-based interface or download the desktop app for your computer. It has a generous free tier, so you can get a lot done without paying for the pro version.

Sketch is another essential design tool that developers should be familiar with. Like Figma, it is vector-based and primarily used for UI/UX design.

Sketch is popular for its intuitive interface and simplicity, making it ideal for developers who want to quickly create prototypes. It's also widely used by designers for tasks like creating UIs, icons, and web layouts.

The main constraints with Sketch are its lack of a cloud-based interface and its availability only on macOS.

Adobe XD is another vector-based design and prototyping tool for UI/UX design, known for its seamless integration with other Adobe apps like Photoshop, Illustrator, and After Effects.

This integration makes workflows such as interactive prototyping and animations more efficient.

Adobe XD is available for both Windows and MacOS and includes a cloud-based interface. For the best experience, however, you should use the app directly.

Another design tool worth mentioning is Canva. You can use Canva to create a wide range of visual content, including posters, cover photos, presentations, short videos, and more. Its user-friendly and simple design makes it ideal for beginners.

Additionally, Canva offers a rich library of templates, images, and design elements that make it easy to create professional-looking designs.

Beyond these features, Canva supports web interface design and allows for collaboration with teammates. The platform is available on the web and as an Android app.

Other popular design tools developers should know are Framer, InVision, Adobe Photoshop, Adobe Illustrator, and Miro.


## Module: Absolute And Relative Units


### Lecture Block: Lecture Working With Relative And Absolute Units


## What Are Absolute Units in CSS, and When Should You Use Them?

### Description

As you design your pages, you will work with different properties like widths, heights, padding, margins, and more. When you define these properties, you will need to specify the length units of measurement you want to use.

There are two types of units you can use to define these properties: relative units and absolute units. In this lecture, we will just focus on absolute units.

Absolute length units are of fixed length and are not relative to anything else. Relative means that the length is relative to something else, like the size of the screen or the size of the parent element. We will talk more about relative units in the next few lectures.

The most common absolute unit is the pixel (`px`). Pixels are a fixed-size unit of measurement in CSS, providing precise control over dimensions. This means that 1px is always equal to 1/96th of an inch.

It is important to note that while 1px is standardized as 1/96th of an inch for the purposes of CSS layout, the actual physical size of a pixel may differ depending on the display.

Let's take a look at an example of using pixels to set the width and height for a box:

```css
.box {
  width: 100px;
  height: 100px;
  background-color: red;
}
```

In this example, we have a red box with a width and height set to `100px`. The dimensions for this box will stay the same regardless of changes pertaining to the screen size.

So, if you are on a device with a small screen, the box will still be `100px` wide. If you are on a large desktop screen, the box will still be `100px` wide.

So, when should you use absolute units like pixels? Well, it depends on the situation. But generally you will use pixels where you need precise control over element dimensions, spacing, and layout. Sometimes you might use pixels for margins, padding, and borders.

Here is an example of using pixels to set the margin for a box:

```css
.box {
  width: 100px;
  height: 100px;
  background-color: red;
  margin: 10px;
}
```

Remember that margin is the space outside of the box. So, in this example, the box will have a margin of `10px` on all sides.

Other types of absolute units include the following:

- The `in` (inches) unit, which is equal to 96px
- The `cm` (centimeters) unit, which is equal to 25.2/64 of an inch
- The `mm` (millimeters) unit, which is equal to 1/10th of a centimeter
- The `q` (quarter-millimeters) unit, which is equal to 1/40th of a centimeter
- The `pc` (picas) unit, which is equal to 1/6th of an inch
- The `pt` (points) unit, which is equal to 1/72th of an inch

Most of these units will be used for print and not for screens. 

While the most common unit you will use is pixels, it is important to know that the other absolute units exist.


## What Are Percentages in CSS, and When Should You Use Them?

### Description

Percentages in CSS are relative units that allow you to define sizes, dimensions, and other properties as a proportion of their parent element. When you use a percentage value, you're essentially saying, "Make this X% of its container."

For example, if you set `width: 50%` on an element, it will occupy half the width of its parent container. This makes percentages incredibly useful for creating responsive designs that adapt to different screen sizes.

Percentages are ideal for creating fluid layouts that adjust to various screen sizes. For instance, setting a container to `width: 80%` ensures it takes up 80% of its parent's width, regardless of the device.

Using percentages for flexible images is another common practice. By applying `max-width: 100%` to images, you allow them to scale down on smaller screens while maintaining their aspect ratio.

While less common, percentages can also be used for font sizes to create scalable typography. For example, `font-size: 120%` would make the text 20% larger than its parent's font size.

Percentages can be particularly handy for vertical centering. Here's an example of how you might use percentages with the transform property to center an element vertically:

```css
.center-me {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);

  width: 300px;
  height: 300px;
  background-color: red;
}
```

This code positions the element 50% from the top of its container, then uses transform to move it back up by half its own height, effectively centering it vertically.

You will learn more about how absolute positioning and the transform properties work in more detail in future lectures. 

Remember, percentages are always relative to something. For horizontal properties like `width`, they're relative to the parent's width. For vertical properties like `height`, they're usually relative to the parent's height (if specified).

However, be cautious when nesting elements with percentage-based dimensions, as this can lead to unexpected results. Also, keep in mind that percentage-based heights can be tricky if the parent doesn't have a defined height.

In summary, percentages in CSS are powerful tools for creating flexible, responsive designs. Use them when you want elements to scale proportionally to their containers or when you need layouts that adapt seamlessly to different screen sizes.


## What Are ems and rems in CSS, and When Should You Use Them?

### Description

In the previous lecture, we learned about absolute length units like pixels. While absolute units can be helpful in certain situations, there will be times when you want to use relative units.

In this lecture, we will learn about two relative units: `em`s and `rem`s.

`em` units are relative to the font size of the element. If you are using ems for the `font-size` property, the size of the text will be relative to the font size of the parent element.

To better understand how this works, let's take a look at an example:

```html
<p class="para">I am a paragraph element</p>

<div class="blue-box"></div>
```

For the HTML, we have a paragraph and `div` element. The paragraph element has a class of `para`, and the `div` element has a class of `blue-box`.

Here is the accompanying CSS:

```css
.para {
  font-size: 20px;
  margin-bottom: 1.5em;
  border: 2px solid red;
}

.blue-box {
  background-color: blue;
  color: white;
  padding: 10px;
}
```

For the `para` class, we set the `font-size` to `20px` and the `margin-bottom` to `1.5em`. This means that the margin will be 1.5 times the font size of the paragraph element. `1.5em` results in 30 pixels of margin at the bottom of the paragraph. We have also set a `border` of `2px solid red` so you can see the margins better. 

For the `blue-box` class, we set the background color to `blue`, the text color to `white`, and the `padding` to `10px` on all four sides.

From the example, there'll be a clear space between the bottom of the paragraph element and the blue box.

So what happens if we remove the `font-size` property from the `para` class?

Well, the bottom margin will be relative to the font size of the parent element. In this case, the parent element is the body element, which has a default font size of `16px`.

Good use cases for `em`s would be when you are working with modular components like buttons or cards. By using `em` units, you can ensure that all aspects of the component (such as padding, margin, and borders) scale proportionally with the font size, keeping consistent proportions.

So, up until this point, we have been setting the font size for an element using pixels. But that does present some challenges for users.

Inside your browser settings, you can control the default font size.

For those with visual impairments, they may increase the font size to make it easier to read. But if you are setting pixels for the font sizes in your web designs, the text will not scale proportionally with the rest of the content.

One way to address this issue is to use `rem` units for typography. A `rem` unit is relative to the font size of the root element, which is the `html` element. 

By default, the font size of the `html` element is `16px`. If the user increases the font size in their browser settings, the font size of the `html` element will increase, and all rem units will scale proportionally.

Here is an example of using the `rem` unit for the font size instead of pixels:

```css
.para {
  font-size: 1.2rem;
  margin-bottom: 1.5em;
  border: 2px solid red;
}
```

By setting the font size to `1.2rem`, the font size of the paragraph element will be 1.2 times the font size of the root element. If the user hasn't changed the default font size, the font size of the paragraph element will be `19.2px` because it is 1.2 times `16px`.

So when should you use `rem` units? `rem` units are preferred over pixels for typography because they scale proportionally with the user's browser settings. This makes your content more accessible to users with visual impairments.

`rem` units can also help maintain consistent spacing and layout across different elements.


## What Are vh and vw Units, and When Should You Use Them?

### Description

In CSS, `vh` and `vw` are viewport-relative units that allow you to size elements based on the dimensions of the browser window. These units are particularly useful for creating responsive designs that adapt to different screen sizes.

`vh` stands for "viewport height," and `1vh` is equal to 1% of the viewport's height.

Similarly, `vw` stands for "viewport width," and `1vw` is equal to 1% of the viewport's width. 

This means that if you set an element's height to `100vh`, it will occupy the full height of the viewport, regardless of the actual pixel dimensions of the device.

These units are especially handy when you want to create full-screen layouts or elements that maintain a specific proportion of the screen. 

For example, you might want to use them to create a hero section that always fills the entire screen:

```css
.hero {
  height: 100vh;
  width: 100vw;
}
```

This CSS ensures that the hero section will always be exactly the size of the viewport, regardless of the device's screen size.

`vh` and `vw` units can also be used for typography to create responsive text sizes. For instance:

```css
h1 {
  font-size: 5vw;
}
```

This will set the font size of `h1` elements to 5% of the viewport width, allowing the text to scale smoothly with the browser window size.

One of the advantages of `vh` and `vw` units is that they respond to changes in the viewport size in real-time. This means that if a user resizes their browser window, elements sized with these units will adjust accordingly without needing to reload the page. However, it's important to use these units judiciously. Setting font sizes solely with `vw` units, for example, can lead to text becoming too small on narrow screens or too large on wide screens. 

Another consideration is that on mobile devices, the viewport height can change when the browser's address bar appears or disappears, which can cause unexpected layout shifts if you're using `vh` units extensively.

In summary, `vh` and `vw` units are powerful tools for creating responsive layouts and elements that adapt to the viewport size. They're particularly useful for full-screen sections, maintaining aspect ratios, and creating smoothly scaling designs. However, they should be used thoughtfully and often in combination with other CSS techniques to ensure the best user experience across all devices.


## What Is the calc() Function, and How Does It Work?

### Description

With the `calc()` function, you can perform calculations directly within your stylesheets to determine property values dynamically. This means that you can create flexible and responsive user interfaces by calculating dimensions based on the viewport size or other elements.

`calc()` is a CSS function. You'll learn more about functions when you start learning about JavaScript, but in this lecture, you're going to learn the basics that you need to know to understand how `calc()` works.

A function is a block of code that performs a specific task. Some functions are already defined in CSS, so you can use them directly and pass any necessary values to them to customize how their tasks will be performed.

In the world of programming, when we run the task performed by a function, we say that we "call" the function. The values that we pass into the function are known as arguments. 

Like you can see in the code below, to call a function, you write its name followed by the arguments within parentheses, separated by commas. There shouldn't be a space between the name of the function and the opening parenthesis:

```css
function(argument1, argument2, argument3)
```

A function may only need one value to know what to do. In that case, it will only take one argument. That's what happens with the `calc()` function. It takes one argument because it needs to know what to calculate.

For this, you pass something called an expression as an argument. An expression is a combination of values and operators that produces a result.

This is how you can call the `calc()` function. You write the name calc, followed by parentheses, and within the parentheses, you write the expression:

```css
calc(expression)
```

The expression is evaluated to calculate the final result. "Evaluated" just means that the values and operators are converted into a single value behind the scenes. The result is assigned to the CSS property where the calculation is being made.

You can perform calculations on values that represent length, angle, time, percentages, numbers, and colors. You can also combine different units like pixels, percentages, and ems.

With numbers, all the values in the expression, also called the operands, must have their corresponding units, like `px`, `em`, and percentage (`%`). Depending on the operator, different operands may have different units.

You can use the addition (`+`), subtraction (`-`), multiplication (`*`), and division (`/`) operators in the expression.

If there are multiple operands and operators, `calc()` will follow the standard operator precedence rule. You can also add parentheses to establish the order of the operations if needed.

In the example below, you can see a `div` with the text `Hello, World!`:

```html
<div>Hello, World!</div>
```

Using the CSS type selector for selecting the `div`, you can style it with white text and a dark blue background: 

```css
div {
  color: white;
  background-color: #1b1b32;
  width: calc(50% - 20px);
}
```

What's new here is that the width is calculated dynamically. Notice how we are calling the `calc()` function and passing an expression as an argument. The expression has two operands with different units and one operator, the subtraction operator.

Percentage is a relative unit. The value (`50%`) will be determined by the width of the parent container. Then, `20px` is subtracted from the value. The result of this expression will determine the width of the `div`.

The width of the `div` is approximately half the total width of its container, and if you resize the parent container, the width will be recalculated automatically.

That's the key advantage of using `calc()`. You can determine the value of a CSS property dynamically based on different aspects of the application or viewport.

The expression can also contain CSS functions and variables if you need to use them in your calculations. You'll learn more about CSS variables in the next lectures.

Great. Now that you know about the basics of the `calc()` function, let's cover some of its best practices.

First, you must surround the addition (`+`) and subtraction (`-`) operators with whitespace.

For example, the expression below would not be a valid expression because the subtraction operator is immediately before the second operand.

```css
calc(100% -30px)
```

The subtraction (`-`) operator must be surrounded by whitespace, like this. Adding the whitespace will create a valid expression.

```css
calc(100% - 30px)
```

This is not necessary for the multiplication and division operators but it's highly recommended.

You can also nest `calc()` function calls if you need to perform calculations and use those results in other calculations.

Also, if you use the value zero to represent length in the expression that you pass into the `calc()` function, you must include the units. For example, this expression would not be valid:

```css
calc(100% - 0)
```

You would need to add the units, like px.

```css
calc(100% - 0px)
```

You should also know that currently, if you use the multiplication or division operators, one of the operands has to be unitless. For the division operator, specifically the right operand has to be unitless. This would not be a valid expression because both operands have units (pixels). One of the operands, either 5 or 50, must be unitless:

```css
calc(5px * 50px)
```

You would need to omit the units in one of them. Both of these alternatives would be valid:

```css
calc(5 * 50px)
calc(5px * 50)
```

And this is an example with the division operator. This would not be a valid expression since they both have units:

```css
calc(50% / 5%)
```

You should remove the unit from the right operand when you have the division operator:

```css
calc(50% / 5)
```

The `calc()` function can be very helpful for you as a web developer. With this function, you can set property values dynamically to create flexible and responsive designs.


## Module: Pseudo Classes And Elements


### Lecture Block: Lecture Working With Pseudo Classes And Pseudo Elements In Css


## What Are Pseudo-classes, and How Do They Work?

### Description

Pseudo-classes are special CSS keywords that allow you to select an element based on its specific state or position. The element's state or position could include:

- When it's active.
- When it's being hovered over by a mouse.
- When it's the first child of a parent.
- When it's the last child of a parent.
- When a link has been visited.
- When it's disabled.

To use a pseudo-class, you add it to the selector by using a colon (`:`) followed by the name of the pseudo-class: 

```css
selector:pseudo-class {
  /* CSS properties */
}
```

Let's see how you can use a pseudo-class to represent each of the states and positions we already mentioned.

The `:active` pseudo-class lets you select the active state of an element, like clicking on a button:

```css
button:active {
  background: greenyellow;
}
```

The `:hover` pseudo-class defines the hover state of an element. An example would be hovering over a button or link:

```css
a:hover {
  text-decoration: none;
  background: crimson;
}
```

The `:first-child` pseudo-class selects an element that is the first child of its parent element. Here's an HTML example showing a `div` element containing multiple paragraph elements:

```html
<div class="container">
  <p>first child</p>
  <p>second child</p>
  <p>third child</p>
  <p>last child</p>
</div>
```

Here's the CSS that selects the first paragraph element in that `div` container: 

```css
.container p:first-child {
  background: lightcoral;
  padding: 0.4rem;
}
```

The first paragraph element in that `div` will receive the `lightcoral` background color and `padding` of `0.4rem` on all four sides. 

The `:last-child` pseudo-class targets the last element that is the child of its parent. Here is an example of targeting the last paragraph element in the container `div` element:

```css
.container p:last-child {
  background: lightcoral;
  padding: 0.4rem;
}
```

The `:visited` pseudo-class lets you style a link the user has already visited:

```css
a:visited {
  color: purple;
}
```

The `:disabled` pseudo-class lets you style an interactive element in disabled mode:

```css
button:disabled {
  background-color: lightgray;  
}
```

As you can see, pseudo-classes let you style elements based on user interactions, like hovering or visiting a link. This makes your website feel more interactive.

Apart from the pseudo-classes already mentioned, there are others like:

- `:focus`
- `:first-of-type`
- `:last-of-type`
- `:nth-of-type`
- `:modal`
- `:enabled`
- `:checked`
- `:required`, and more.


## What Are Examples of Element User Action Pseudo-classes?

### Description

User feedback is a crucial element of web design. For instance, it's important for users to receive visual cues when they interact with elements on a website, such as hovering over a button or clicking a link. This feedback helps users understand the state of interactive elements, like indicating whether a link has been visited or not.

User action pseudo-classes in CSS are special keywords that allow you to provide this kind of feedback without needing JavaScript or other programming languages.

These pseudo-classes include `:hover`, `:active`, `:focus`, and `:visited`, among others. They enable you to change the appearance of elements based on user interactions, improving the overall user experience.

Let's dive into some of the user action pseudo-classes we have and see how they work.

The `:active` pseudo-class applies styles when an element is activated by the user. For example, when the user clicks a button or a link, it provides immediate visual feedback, showing users that their actions are being recognized.

```css
a:active {
  color: crimson;
}
```

The `:hover` pseudo-class is triggered when a user hovers over an element with their mouse or other pointing device. Developers often use it to create visual feedback for buttons, links, or any element that should respond to user attention. Here's a button a user would hover over before clicking:

```html
<button class="btn">Hover Over Me</button>
```

Here's the CSS that changes the color, background color, and cursor of the button once the user hovers over it:

```css
.btn:hover {
  background-color: darkgreen;
  color: white;
  cursor: pointer;
}
```

The `:focus` pseudo-class applies styles when an element gains focus, typically through keyboard navigation or when a user clicks into a form input. This is not just for feedback but also crucial for accessibility. It ensures that users who rely heavily on keyboards can easily identify which element they are interacting with. 

Here's an input element inside a form element:

```html
<form>
  <input type="text" />
</form>
```

Here's the CSS that gives the input a solid dark green border and a `border-radius` when the user clicks into it:

```css
input:focus {
  outline: 2px solid darkgreen;
  border-radius: 4px;
}
```

The `:visited` pseudo-class targets a link the user has visited. This can be useful for helping users distinguish between pages they have already visited and the ones they are yet to visit. Here is an example of changing the anchor text color to cyan when the link is visited:

```css
a:visited {
  color: cyan;
}
```

The `:checked` pseudo-class in CSS allows you to style form elements such as checkboxes and radio buttons when they are selected (checked). This pseudo-class is useful for customizing the appearance of these elements to enhance user experience, even though browsers provide default styles for them.

Here's the kind of checkbox you usually check to agree to terms on a website:

```html
<form>
  Agree <input class="checkbox" type="checkbox" />
</form>
```

Here's how you can use the `:checked` pseudo-class to indicate to the user that it is checked:

```css
.checkbox:checked {
  appearance: none;
  width: 12px;
  height: 12px;
  background-color: red;
}
```

In this example, we are using the `appearance` property set to `none` to remove the default styling applied by the browser to checkbox inputs. When the user checks the box, it will have a background color of `red`.

Other examples of action pseudo-classes are:

- `:focus-within`: for applying styles to an element when it or any of its descendants have focus.
- `:enabled`: for targeting form buttons or other elements that are currently enabled.
- `:disabled`: for targeting form buttons or other elements that are disabled.
- `:target`: for applying styles to an element that is the target of a URL fragment (the part of a URL after the `#` symbol).


## What Are Examples of Input Pseudo-classes?

### Description

The appearance and behavior of input elements matter when building web forms. A form with inputs that respond to user actions goes a long way in improving user experience, and it should not cause confusion or frustration.

CSS provides several input pseudo-classes that can make your forms more intuitive and user-friendly. Let's look at these pseudo-classes in detail.

The `:focus` pseudo-class allows you to target an input element when a user selects or clicks on it, drawing attention to the active input field. This helps users easily identify where they're currently typing:

```css
input:focus {
  border: 2px solid crimson;
  outline: none;
}
```

As the name implies, the `:hover` pseudo-class is triggered when the user places the cursor over an element. It provides visual feedback before the user interacts with the input, effectively alerting them that the input is ready for action.

```css
input:hover {
  background-color: orange;
}
```

In the example above, the input element background changes to an orange color when the user hovers over it, letting them know that the field is ready for interaction.

The `:checked` pseudo-class lets you style a radio button or checkbox differently when a user selects it. This way, the user can easily see which option they've chosen.

Here is an example:

```html
<form>
  I have read the terms<input class="checkbox" type="checkbox">
</form>
```

```css
.checkbox:checked {
  appearance: none;
  width: 12px;
  height: 12px;
  background-color: coral;
}
```

`:required` targets input elements that have the `required` attribute. It signals to the user that they must fill out the field to submit the form.

The HTML below has a form with two required input elements:

```html
<form action="#">
  <label for="name">Name:</label>
  <input type="text" id="name" name="name" required />

  <label for="email">Email:</label>
  <input type="email" id="email" name="email" required />

  <label for="phone">Phone Number:</label>
  <input type="tel" id="phone" name="phone" />

  <button type="submit">Submit</button>
</form>
```

And this CSS applies an orange border of two pixels to the two required inputs:

```css
input:required {
  border: 2px solid orange;
}
```

When validating forms, you can use the `:valid` pseudo-class to style the input fields that meet the validation criteria, and `:invalid` to style the input fields that do not meet the criteria. Typically, you will use green for a valid input and red for an invalid input. 

Here is an example using the `:valid` pseudo-class:

```css
input:valid {
  border-color: green;
}
```

Here is an example of using the `:invalid` pseudo-class:

```css
input:invalid {
  border-color: crimson;
}
```

The `:disabled` pseudo-class allows you to select and style input elements that are disabled. These elements have the `disabled` attribute, which prevents users from interacting with them. When an input is disabled, it cannot be clicked, focused, or edited.

Here is an example of a label and a disabled input element:

```html
<label for="name">Name:</label>
<input class="text-input" type="text" id="name" name="name" disabled />
```

In the CSS, we are targeting that disabled input and giving it a background color of `lightgray` and changing the cursor pointer to `not-allowed`. 

```css
.text-input:disabled {
  background-color: lightgray;
  cursor: not-allowed;
}
```

The `cursor: not-allowed;` CSS property value changes the appearance of the cursor to indicate that an action is not permitted. 

When applied to an element, it shows a cursor with a circle-slash symbol (usually a circle with a diagonal line through it) to signal to users that the element is not interactive or cannot be clicked or interacted with.

Here are some other examples of input pseudo-classes and what they do:

- `:autofill`: applies styles to input fields that the browser automatically fills with saved data.
- `:optional`: styles input elements that are not required and can be left empty.
- `:in-range` and `:out-of-range`: style elements based on whether their values are within or outside specified range constraints.


## What Are Examples of Location Pseudo-classes?

### Description

Location pseudo-classes are used for styling links and elements that are targeted within the current document. They offer a way to apply styles based on whether a link is visited or whether an element is currently in focus.

Examples of location pseudo-classes are:

- `:link`
- `:visited`
- `:any-link`
- `:local-link`
- `:target`
- `:target-within`

Let's take a deeper look at each of these pseudo-classes.

The `:link` pseudo-class allows you to target all unvisited links on a webpage. You can use it to style links differently before the user clicks on them. For example, you might want to make all unvisited links blue or your website's primary color:

```css
a:link {
  color: magenta;
}
```

In this case, any link the user hasn't clicked yet will appear magenta. Once the user clicks the link, the `:link` style no longer applies, and the `:visited` pseudo-class takes over. The `:visited` pseudo-class comes into play after the user clicks the link, so you can use it to target links the user has already clicked. 

Here is an example of changing the visited link state to the color `purple`:

```css
a:visited {
  color: purple;
}
```

The `:visited` pseudo-class helps users distinguish between links they have visited and those they have not.

The `:any-link` pseudo-class is a combination of the `:link` and `:visited` pseudo-classes. So it matches any anchor element with an `href` attribute, regardless of whether it's visited or not.

Here is an example of changing the link color for the `:any-link` pseudo-class to `crimson`:

```css
a:any-link {
  color: crimson;
}
```

The `:local-link` pseudo-class targets links that point to the same document. It can be useful when you want to differentiate internal links from external ones. Currently, no browser supports the `:local-link` pseudo-class.

The `:target` pseudo-class selects an element that matches the current URL fragment identifier, for example, `#section1`. It's very useful for pages with in-page navigation.

Here's an HTML example that represents an in-page navigation:

```html
<nav id="table-of-contents">
  <ul>
    <li><a href="#section1">Introduction</a></li>
    <li><a href="#section2">Features</a></li>
  </ul>
</nav>

<section id="section1">
  <h2>Introduction</h2>
  <p>This is the introduction section.</p>
</section>

<section id="section2">
  <h2>Features</h2>
  <p>This section describes the features.</p>
</section>
```

Here's the CSS that uses the `:target` pseudo-class to style the section that matches where the user navigates to:

```css
section:target {
  background-color: green;
  border: 2px solid green;
  padding: 10px;
}
```

When the user clicks on one of the navigation links, the background color for that respective section will change to green.


## What Are Examples of Tree-structural Pseudo-classes?

### Description

Tree-structural pseudo-classes allow you to target and style elements based on their position within the document tree. The document tree refers to the hierarchical structure of elements in an HTML document.

Here is a list of tree-structural pseudo-classes:

- `:root`
- `:empty`
- `:nth-child(n)`
- `:nth-last-child(n)`
- `:first-child`
- `:last-child`
- `:only-child`
- `:nth-of-type`
- `:first-of-type`
- `:last-of-type`
- `:only-of-type`

Let's take a closer look at each of the tree-structural pseudo-classes, accompanied by examples.

​​The `:root` pseudo-class is usually the root `html` element. It helps you target the highest level in the document so you can apply a common style to the entire document.        

```css
:root {
  background: black;
  color: aliceblue;
}
```

The `:root` pseudo-class is also commonly used in setting CSS variables:

```css
:root {
  --main-font: 'Arial, sans-serif';
  --primary-color: blue; 
  --secondary-color: green; 
}
```

With CSS variables, you get to store values and reuse them in your stylesheet. You will learn more about these later on.

Empty elements, that is, elements with no children other than white space, are also included in the document tree. That's why there's an `:empty` pseudo-class to target empty elements. For example, this HTML code has two empty list items:

```html
<ul>
  <li>Item 1</li>
  <li></li> <!-- This list is empty -->
  <li>Item 2</li>
  <li></li> <!-- Another empty list -->
  <li>Item 3</li>
</ul>
```

With the `:empty` pseudo-class, you can style the empty list items differently:

```css
:empty {
  background: black;
}
```

The most practical thing to do with the empty list items is probably not displaying them at all:

```css
:empty {
  display: none;
}
```

`:nth-child(n)` allows you to select elements based on their position within a parent, while `:nth-last-child(n)` enables you to select elements by counting from the end. The `n` can be a specific number or a keyword like `odd` or `even`. This is incredibly useful in styling table cells based on position: even and odd.

Here's an HTML example of a fruit price list table:

```html
<table>
  <tr>
    <th>Item</th>
    <th>Price</th>
  </tr>
  <tr>
    <td>Apple</td>
    <td>$1.00</td>
  </tr>
  <tr>
    <td>Banana</td>
    <td>$0.50</td>
  </tr>
  <tr>
    <td>Orange</td>
    <td>$0.80</td>
  </tr>
</table>
```

Here's the CSS using the `:nth-child` pseudo-class to target the table cells based on odd and even positions:

```css
th,
td {
  border: 1px solid lightgray;
  padding: 8px;
}

tr:nth-child(even) {
  background-color: orangered;
}

tr:nth-child(odd) {
  background-color: lightgreen;
}
```

The `:first-child`, `:last-child`, and `:only-child` pseudo-classes all act on items within a parent container or the entire document.

- `:first-child` selects the first element in a parent element or the document.
- `:last-child` selects the last element in a parent element or the document.
- `:only-child` selects the only element in a parent element or the document.

Using the `:first-child` and `:last-child` pseudo-classes will select both `Item 1` and `Item 3` in this HTML:

```html
<ul>
  <li>Item 1</li>
  <li>Item 2</li>
  <li>Item 3</li>
</ul>
```

Here's the CSS:

```css
li:first-child {
  background-color: orangered;
}

li:last-child {
  background-color: lightgreen;
}
```

If you have more unordered lists on the page, you have to be more specific with the selection: 

```css
ul li:first-child {
  background-color: orangered;
}

ul li:last-child {
  background-color: lightgreen;
}
```

To show you how the `:only-child` pseudo-class works, here's an HTML example with two separate `div` elements:

```html
<div class="container">
  <div>This is the only item in this container.</div>
</div>

<div class="container">
  <div>This is one of two items in this container.</div>
  <div>Here is the second item.</div>
</div>
```

Using the `:only-child` pseudo-class ensures only the `div` element with a single child is selected:

```css
.container div:only-child {
  border: 2px solid crimson;
  padding: 10px;
  background-color: lightblue;
}
```

The `:first-of-type` and `:last-of-type` pseudo-classes select the first and last occurrence of a specific element type within its parent. They are useful for applying unique styles to the first or last instance of that element type among its siblings.

In the HTML below, `:first-of-type` and `:last-of-type` applies to the first element and last element within the `section` element:

```html
<section>
  <h2>Introduction</h2>
  <p>This is the first paragraph in the first section</p>
  <p>This is the second paragraph in the first section</p>
</section>
<section>
  <h2>Details</h2>
  <p>This is the first paragraph in the second section.</p>
  <p>This is the second paragraph in the second section.</p>
</section>
```

Here's the CSS:

```css
section p:first-of-type {
  background-color: lightgreen;
}

section p:last-of-type {
  background-color:lightblue;
}
```

`:nth-of-type(n)` allows you to select a specific element within its parent based on its position among siblings of the same type. For instance, in the HTML below, `:nth-of-type(2)` targets the second element in the container:

```html
<div class="container">
  <p>First paragraph</p>
  <h2>First heading</h2>
  <p>Second paragraph</p>
  <p>Third paragraph</p>
  <h2>Second heading</h2>
</div>
```

Here's the CSS:

```css
p:nth-of-type(2) {
  color: red;
  font-weight: bold;
}
```

`:only-of-type` selects an element if it's the only one of its type within its parent. This can be useful for emphasizing single items or ensuring that they are styled differently when they’re not part of a group.

In the HTML below, there are two `div` elements with one having a single element:

```html
<div class="container">
  <p>The only paragraph</p>
</div>

<div class="container">
  <p>The first paragraph</p>
  <p>The second paragraph</p>
</div>
```

Here's the CSS that only applies to the first container:

```css
p:only-of-type {
  border: 4px solid green;
}
```


## What Are Examples of Functional Pseudo-classes?

### Description

Functional pseudo-classes allow you to select elements based on more complex conditions or relationships. Unlike regular pseudo-classes which target elements based on a state, for example, `:hover`, `:focus`, functional pseudo-classes accept arguments within parentheses, hence the name "functional pseudo-classes".

Examples of functional pseudo-classes are:

- `:is()`
- `:where()`
- `:has()`
- `:not()`

Let's take a deeper look at each of these functional pseudo-classes with examples.

The `:is()` pseudo-class is useful when you want to style a group of elements that share some, but not all, characteristics. For example, you might want to style different types of buttons on your website, including `button` elements, links styled as buttons, and `input` elements with types `submit` and `reset`. Here's an HTML example representing that:

```html
<button>Click Me</button>
<a href="#" class="button">Click Me Too</a>
<input type="submit" value="Submit" />
<input type="reset" value="Reset" />
```

Without the `:is()` function, you would have to write a complex selector like this:

```css
button,
a.button,
input[type='submit'],
input[type='reset'] {
  background-color: darkblue;
  color: white;
  border: 1px solid darkblue;
  padding: 10px 20px;
  text-decoration: none;
  border-radius: 5px;
  cursor: pointer;
  display: inline-block;
  margin: 5px;
  font-size: 16px;
  text-align: center;
}

button:hover,
a.button:hover,
input[type='submit']:hover,
input[type='reset']:hover {
  background-color: lightblue;
  border-color: lightblue;
}
```

With the `:is()` function, you can write a more compact and understandable selector like this:

```css
:is(button, a.button, input[type='submit'], input[type='reset']) {
  background-color: darkblue;
  color: white;
  border: 1px solid darkblue;
  padding: 10px 20px;
  text-decoration: none;
  border-radius: 5px;
  cursor: pointer;
  display: inline-block;
  margin: 5px;
  font-size: 16px;
  text-align: center;
}

:is(button, a.button, input[type='submit'], input[type='reset']):hover {
  background-color: blue;
  border-color: blue;
}
```

The `:where()` pseudo-class functions similarly to `:is()`, but it doesn't increase the specificity of your selectors. This makes it ideal for applying styles without affecting the specificity of other rules.

For example, you can use the `:where()` function to apply zero `margin` and `padding` to heading elements. This ensures that the reset won't interfere with more specific styles you might apply later. Here's the HTML for that:

```html
<h1>Page Title</h1>
<h2>Subtitle</h2>
<h3>A point</h3>
```

And this is the CSS:

```css
:where(h1, h2, h3) {
  margin: 0;
  padding: 0;
}
```

Styling a parent element based on its children's states was previously challenging until the `:has()` pseudo-class was introduced. It allows you to apply styles to a parent element based on the presence or state of its child elements.

For example, the CSS below will only apply to any `article` element that has an `h2` in it:

```css
article:has(h2) {
  border: 2px solid hotpink;
}
```

Here's the HTML for that:

```html
<article>
  <h2>Subheading</h2>
  <p>Lorem ipsum dolor sit amet.</p>
</article>

<article>
  <h3>A point</h3>
  <p>Lorem ipsum dolor sit amet.</p>
  <p>Lorem ipsum dolor sit amet.</p>
</article>
```

The `:not()` pseudo-class is ideal for situations where you want to apply styles to a group of elements, excluding one or more specific exceptions. In the CSS below, any button that is not a primary button will have a grey background:

```css
button {
  padding: 10px 20px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
  border: none;
  color: white;
}

button.primary {
  background-color: deepskyblue;
}

button:not(.primary) {
  background-color: grey;
}
```

Here's the HTML for the buttons:

```html
<button class="primary">Primary Button</button>
<button class="secondary">Secondary Button</button>
<button class="danger">Another Secondary Button</button>
```


## What Are Pseudo-elements, and How Do They Work?

### Description

One of the most interesting aspects of CSS is the use of pseudo-elements. In this context, "pseudo" means "not real", so pseudo-elements are virtual or synthetic elements that don't directly match any actual HTML elements. They allow you to style specific parts of an element or insert content without adding extra HTML.

To apply a pseudo-element, attach it to the original element's selector using a double colon (`::`). Note that the selector can be any type, such as a class or ID selector. Here's what the basic syntax of pseudo-elements looks like:

```css
selector::pseudo-element {
  property: value;
}
```

This double colon is what distinguishes pseudo-elements from pseudo-classes, which use a single colon.

Pseudo-elements allow you to style specific parts of an element's content or insert content before or after it, but they cannot exist independently. The element to which a pseudo-element is attached is called its originating element.

Let's start by looking at examples for the `::before` and `::after` pseudo-elements. As their names suggest, `::before` lets you insert content just before the element's content while `::after` lets you insert content after it.

Here is an example of a button element:

```html
<button class="cta-button">Learn More</button>
```

In the CSS, we will use absolute positioning and the `::before` pseudo-element to add a star before the button's `Learn More` text. You will learn more about absolute positioning in future lectures.

```css
.cta-button {
  background-color: lightseagreen;
  color: white;
  border: none;
  padding: 10px 20px;
  cursor: pointer;
  position: relative;
}

.cta-button::before {
  content: "⭐";
  position: absolute;
  left: 3px;
  top: 8px;
  font-size: 0.75rem;
}
```

The `content` property is used to represent the content you wish to add before the button text. In this example, we are adding a star. You'll notice that you can not only insert content but also style it. Here's an example of the `::after` pseudo-element with the same button:

```css
.cta-button {
  background-color: orange;
  border: none;
  padding: 10px 30px;
  cursor: pointer;
  position: relative;
}

.cta-button::after {
  content: '➡️';
  position: absolute;
  right: 5px;
  bottom: 6px;
  font-size: 1.125rem;
  transition: transform 0.3s ease;
}
```

In the `::after` pseudo-element, the `transition` property is used to animate changes over 0.3 seconds with an easing effect, creating a smooth and gradual transformation rather than a sudden one. You will learn more about the `transition` property in future lectures. 

You can also attach a pseudo-class to the content you insert into another content with the `::before` and `::after` pseudo-elements. For example, a hover state for the content. Here's an example:

```css
.cta-button {
  background-color: orange;
  border: none;
  padding: 10px 30px;
  cursor: pointer;
  position: relative;
}

.cta-button::after {
  content: "➡️";
  position: absolute;
  right: 5px;
  bottom: 6px;
  font-size: 1.125rem;
  transition: transform 0.3s ease;
}

.cta-button:hover::after {
  transform: translateX(2px);
}
```

With `transform: translateX(2px)` in the hover state, the content gets pushed to the right by `2px` any time the user hovers on the button. The transition property in the `::after` itself ensures the process takes `0.3s`.

That's what the `transform` property does – it allows you to rotate, skew, scale, or translate an element in a particular direction. You will learn more about that in future lectures.

In the next example, we will look at the `::first-letter` pseudo-element. The `::first-letter` pseudo-element targets the first letter of an element's content, allowing you to style it. Here's an example of some paragraph text:

```html
<p>freeCodeCamp lets you learn to code without having to pay.</p>
```

If we want to style the first letter, we can use the `::first-letter` pseudo-element like this:

```css
p::first-letter {
  font-size: 4rem;
}
```

In the last example, we will look at is the `::marker` pseudo-element which lets you select the marker, bullet or numbering of list items for styling. The `::marker` pseudo-element offers a way to enhance your website's brand identity by customizing list markers to match your color scheme.

Here's an example of an unordered list and an ordered list:

```html
<ul>
  <li>Unordered list item 1</li>
  <li>Unordered list item 2</li>
  <li>Unordered list item 3</li>
  <li>Unordered list item 4</li>
</ul>

<ol>
  <li>Ordered list item 1</li>
  <li>Ordered list item 2</li>
  <li>Ordered list item 3</li>
  <li>Ordered list item 4</li>
</ol>
```

To change the list item's marker color and size, you can use the `::marker` pseudo-element like this:

```css
li::marker {
  color: crimson;
  font-size: 1.5em;
  font-weight: bold;
}
```

In this lecture, we have covered only a few pseudo-elements. But there are many more like the `::placeholder`, `::spelling-error` and `::selection` that I encourage you to explore on your own.


## Module: Css Colors


### Lecture Block: Lecture Working With Colors In Css


## What Is Color Theory in Design?

### Description

Color theory is the study of how colors interact with each other and how they affect our perception. It covers color relationships, color harmony, and the psychological impact of color. Let's start diving into this world. Colors can be classified as either primary, secondary, or tertiary.

Primary colors, yellow, blue, and red, are the fundamental hues from which all other colors are derived.

Secondary colors result from mixing equal amounts of two primary colors. Green, orange, and purple are examples of secondary colors. For example, green is the result of combining yellow and blue.

Tertiary colors result from combining a primary color with a neighboring secondary color. Yellow-Green, Blue-Green, and Blue-Violet, are examples of tertiary colors.

This is a fundamental classification in the world of color theory, but there are other ways to classify colors. They can be classified as warm or cool, based on their temperature.

Warm colors, like reds, oranges, and yellows, evoke feelings of comfort, warmth, and coziness. Cool colors, like blues, green, and purples, evoke feelings of calmness, serenity, and professionalism.

Colors can also be represented through color models. They are essential for describing and reproducing colors in a standard way. Frequently used color models include the RGB model, the HSV model, and the HSL model. They represent colors based on different properties. You will learn more about them in future lectures.

Great. Now that you know more about this, let's talk about a fundamental tool that designers use to represent colors and their relationships. The color wheel is a circular diagram that shows how colors relate to each other. It's an essential tool for designers because it helps them to select color combinations. This is very helpful for creating color palettes and color schemes.

A color scheme is the set of colors chosen for a specific design or project. They are usually based on the principles of color theory. By understanding the relationships between colors on the wheel, you can develop different types of color schemes. Let's see some of them.

Analogous color schemes create cohesive and soothing experiences. They have analogous colors, which are adjacent to each other in the color wheel.

Complementary color schemes create high contrast and visual impact. Their colors are located on the opposite ends of the color wheel, relative to each other.

Color contrast is essential for web accessibility. It ensures that text and other important elements are clearly distinguishable from their background. This is especially important for people with visual disabilities.

In an RGB color wheel, complementary colors are located at the opposite ends of the wheel. For example, magenta is complementary to green and blue is complementary to yellow and so on.

A triadic color scheme has vibrant colors. They are made from colors that are approximately equidistant from each other. If they are connected, they form an equilateral triangle on the color wheel.

And finally, we have the monochromatic color scheme. In this color scheme, all the colors are derived from the same base color by adjusting its lightness, darkness, and saturation. This evokes a feeling of unity and harmony while still creating contrast.

And finally, here are some tips for using color effectively in web development:

- Create a color scheme that defines your website's branding.
- Use colors to evoke the emotions and perceptions that align with your goals.
- Choose colors with enough contrast to make your website accessible for everyone.
- Use color to highlight important elements of your website, like buttons.
- Use color consistently and use it to create a visual hierarchy.

Color theory is a core aspect of design. By understanding color psychology, harmonies, and accessibility, you can create effective designs, evoke emotions, and enhance user experience.


## What Are Named Colors in CSS, and When to Use Them?

### Description

In CSS, colors play a crucial role in designing web pages, enhancing readability, setting the mood, and improving user experience. One of the simplest ways to define colors in CSS is by using named colors. Named colors are predefined color names recognized by browsers. Here is an example of using a named color for a paragraph element:

```css
p {
  color: red;
}
```

In this example, we're using the named color `red` to style the text in a paragraph.

Named colors in CSS are a collection of 140 standard color names like `red`, `blue`, `yellow`, `aqua`, `fuchsia`, `black`, and so on. These names are simple to use and make your code more readable, and they are self-descriptive. 

Named colors are useful for quick prototyping, simple designs, and improving code readability. Here is an another example of using named colors for an `h1` selector:

```css
h1 {
  color: navy;
  background-color: lightgray;
}
```

In this example, the heading text will be styled in navy, with a light gray background. The readability of the code improves since named colors provide an immediate visual understanding of the intended style.

Named colors in CSS are convenient but limited, with only 140 available options. They may not offer the precise shade needed for more detailed designs. 

Named colors in CSS are a great way to apply colors quickly and descriptively. While they are useful for basic designs, prototyping, and improving code readability, their limited range makes them less suitable for complex designs requiring precise color control.

By understanding the strengths and limitations of named colors, you can determine when it’s best to use them over more detailed color models like RGB or HSL, which you will learn about in future lectures.


## What Is the RGB Color Model, and How Does the RGB Function Work in CSS?

### Description

When working with colors in CSS, understanding the RGB color model is essential. RGB stands for Red, Green, and Blue — the primary colors of light. These three colors are combined in different intensities to create a wide range of colors. 

The RGB color model is an additive color model, which means colors are created by combining light at varying intensities. 

The intensity of each color can range from `0` (which means no light) to `255` (which means full light). By mixing different levels of red, green, and blue, you can produce any color you see on your screen. For example:

- Black is represented by `rgb(0, 0, 0)`, which means no light for any of the three colors.
- White is represented by `rgb(255, 255, 255)`, which means full light intensity for all three colors.
- Red is represented by `rgb(255, 0, 0)`, with full intensity for red and none for green or blue.

In CSS, the `rgb()` function allows you to define colors using the RGB color model. The function takes three values, each representing the intensity of red, green, and blue light, respectively. Here is the basic syntax:

```css
element {
  color: rgb(red, green, blue);
}
```

The values for red, green, and blue can range from `0` to `255`, where `0` represents the absence of that color, and `255` represents full saturation. Here is an example of how you might use the `rgb()` function in CSS:

```css
p {
  color: rgb(255, 0, 0);
}
```

This code would change the text color of the paragraph to red because the red value is set to `255`, while green and blue are set to `0`.

CSS also provides the `rgba()` function, which adds a fourth value —alpha— that controls the transparency of the color. The alpha value ranges from `0` (completely transparent) to `1` (completely opaque). Here is an example of using `rgba()`:

```css
div {
  background-color: rgba(0, 0, 255, 0.5);
}
```

This code would apply a semi-transparent blue background to a `div` element because the red and green values are set to `0`, the blue value is set to `255`, and the alpha value is set to `0.5` (50% transparency).

The RGB color model is especially useful for digital media because it directly corresponds to how screens display colors. Monitors and displays use tiny red, green, and blue pixels to create the colors you see. By controlling the intensity of these pixels through RGB values, you can achieve a wide range of colors for your web design.

Additionally, the RGB model is ideal when working with dynamic designs. For instance, if you want to create animations or color effects that require real-time changes, the flexibility of the RGB function allows you to modify colors programmatically.

By understanding the RGB color model and how to use the `rgb()` and `rgba()` functions in CSS, you'll have greater control over how colors are displayed on your web pages. You can create vibrant designs, transparency, and even programmatically adjust colors for dynamic effects.


## What Is the HSL Color Model, and How Does the HSL Function Work in CSS?

### Description

When styling websites, one of the most versatile and intuitive ways to work with color is by using the HSL color model. HSL stands for Hue, Saturation, and Lightness — three key components that define a color. 

The HSL color model represents colors in a way that is more in line with how humans perceive color. In this lecture, we will explore what the HSL color model is and how the `hsl()` function is used in CSS.

The hue is the color type, represented as an angle on the color wheel, which ranges from `0` to `360` degrees. For example, `0` degrees represents red, `120` degrees is green, and `240` degrees is blue. By adjusting the hue, you shift through different colors on the spectrum.

Saturation refers to the intensity or purity of the color. It is measured as a percentage from `0%` (a completely desaturated, grayscale color) to `100%` (the most vibrant form of that color). A color with `100%` saturation is fully vivid, while a color with `0%` saturation appears as a shade of gray.

Lightness determines how light or dark the color is, again measured as a percentage. A lightness value of `0%` will produce black, `50%` will give you the normal tone of the hue, and `100%` will result in white.

In CSS, the `hsl()` function is used to define colors using the HSL color model. Here is the basic syntax:

```css
element {
  color: hsl(hue, saturation, lightness);
}
```

Let's break this down with an example:

```css
p {
  color: hsl(120, 100%, 50%);
}
```

In this case, the hue is `120` degrees, which corresponds to green. The saturation is `100%`, so the green will be fully vivid. The lightness is `50%`, so it's at its normal tone — neither too dark nor too light. As a result, the text color of the paragraph will be a bright green.

One of the main advantages of the HSL color model is its intuitive nature. It makes it easy to adjust a color’s vibrancy or lightness by tweaking the saturation and lightness values without having to alter the core color (hue). 

For instance, if you want to create different shades or tints of the same color, you can simply adjust the lightness value.

```css
div.light {
  background-color: hsl(240, 100%, 80%);
}

div.dark {
  background-color: hsl(240, 100%, 20%);
}
```

Here, both `div` elements are using the same hue (`240` degrees, which is blue), but one has a lightness of `80%` (a lighter shade of blue), and the other has a lightness of `20%` (a darker shade of blue).

Just like the RGB model has an `rgba()` function to include transparency, the HSL model has an `hsla()` function. The fourth parameter in this function represents the alpha value, which controls the opacity of the color. Here is the basic syntax:

```css
element {
  background-color: hsla(hue, saturation, lightness, alpha);
}
```

Let's take a look at an example:

```css
div {
  background-color: hsla(0, 100%, 50%, 0.5);
}
```

This code would give the `div` a semi-transparent red background, where the hue is set to `0` degrees (red), saturation is `100%`, lightness is `50%`, and alpha is `0.5` (50% opacity).

The HSL color model is particularly useful when you need to create color schemes and adjust shades or tints easily. 

Because HSL separates the hue from saturation and lightness, you can keep a consistent color theme while tweaking lightness for shadows or highlights. This level of flexibility makes HSL a favorite for designers and developers alike.

Additionally, HSL makes color values more readable and understandable when compared to other methods like hex codes or RGB. You can more clearly see the intent behind the color and adjust accordingly, especially when experimenting with different designs.

With the HSL color model, you gain more flexibility in controlling color tones, saturation, and lightness, making it a powerful tool for creating rich and dynamic designs in CSS.


## What Are Hex Codes, and How Do They Work in CSS?

### Description

When working with CSS to style a webpage, one of the most common methods for defining colors is by using hex color values. Hexadecimal color values, or hex codes, are a concise way to represent colors in the RGB color model. In this lecture, we'll explore what hex codes are, how they work in CSS, and when to use them.

A hex code (short for hexadecimal code) is a six-character string used to represent colors in the RGB color model. The "hex" refers to the base-16 numbering system, which uses digits `0` to `9` and letters `A` to `F`. 

In the context of colors, hex codes specify the amounts of red, green, and blue (RGB) that make up a particular color. Each hex code starts with a hash symbol (`#`), followed by six characters that define the intensity of red, green, and blue in the color. 

For example, the hex code for black is `#000000`, and the hex code for white is `#FFFFFF`. The first two characters represent the red value, the next two represent green, and the last two represent blue.

In CSS, you can apply colors to elements by using hex codes. Here is the basic syntax:

```css
element {
  color: #RRGGBB;
}
```

Here, `#RRGGBB` is a placeholder for the actual hex code. The `RR`, `GG`, and `BB` pairs each represent the intensity of red, green, and blue, respectively. 

These pairs can range from `00` (the lowest intensity) to `FF` (the highest intensity). The higher the number, the more of that color will be present in the final mix. For example, let's apply some hex colors to a few elements:

```css
h1 {
  color: #FF5733; /* A reddish-orange color */
}
p {
  background-color: #4CAF50; /* A shade of green */
}
```

In the first case, `#FF5733` is a reddish-orange color. Here’s the breakdown:

- `FF` is the highest value for red (fully saturated).
- `57` is a moderate amount of green.
- `33` is a small amount of blue.

In the second case, `#4CAF50` is a shade of green:

- `4C` is a low value for red.
- `AF` is a strong value for green.
- `50` is a moderate value for blue.

Hex codes are popular because they are precise and easy to use. They allow you to fine-tune your colors, making them ideal for designs where consistency is important. 

Most design software, such as Adobe Photoshop or Figma, provides hex codes for the colors you select, which makes it easy to copy and paste these values directly into your CSS files.

In web development, hex codes are often used for defining text colors, backgrounds, borders, and other visual elements. For example:

```css
body {
  background-color: #F0F0F0; /* Light gray background */
}
button {
  background-color: #007BFF; /* A shade of blue */
  color: #FFFFFF; /* White text */
}
```

This ensures that your colors remain consistent across your entire website or application.

In some cases, you may notice hex codes written in shorthand format, using only three characters instead of six. This is possible when both characters in each color pair are the same. For instance, `#FF5733` cannot be shortened, but `#FFFFFF` (white) can be written as `#FFF`.

```css
h2 {
  color: #FFF; /* White in shorthand */
}
```

The shorthand `#FFF` is equivalent to `#FFFFFF`. Similarly, `#000` would represent black which is `#000000` in full form.

Hex codes are popular for their precision and compatibility, allowing for over 16 million colors across all browsers. They're ideal when you need specific branding colors, want to control exact shades that aren't easily defined by named colors or HSL, or when you're copying colors from design software that provides hex codes by default.


## What Are Linear and Radial Gradients, and How Do They Work in CSS?

### Description

In a previous lecture, you learned how to start working with linear and radial gradients. In this lecture, we are going to dive deeper into how to work with the CSS properties to create more visually appealing and complex designs.

Gradients in CSS allow you to create smooth transitions between two or more specified colors. They are often used to add depth, texture, and visual interest to web designs without the need for image files. 

CSS supports two main types of gradients: linear gradients and radial gradients.

Linear gradients create a gradual blend between colors along a straight line. You can control the direction of this line and the colors used. Here's a basic example of a linear gradient:

```css
.linear-gradient {
  background: linear-gradient(to right, red, blue);
  height: 40vh;
}
```

This creates a gradient that transitions from red on the left to blue on the right. The `to right` parameter specifies the direction of the gradient. You can use other directions like `to left`, `to top`, `to bottom`, or even specify angles like `45deg`.

You can also use multiple color stops in a linear gradient:

```css
.multi-color-gradient {
  background: linear-gradient(to right, red, yellow, blue);
  height: 40vh;
}
```

This creates a gradient that transitions from red to yellow to blue, evenly spaced across the element.

Radial gradients, on the other hand, create circular or elliptical gradients that radiate from a central point. Here's an example:

```css
.radial-gradient {
  background: radial-gradient(circle, red, blue);
  height: 40vh;
}
```

This creates a circular gradient that starts with red in the center and transitions to blue at the edges. You can also specify the shape and size of radial gradients:

```css
.custom-radial-gradient {
  background: radial-gradient(ellipse at top left, red, blue);
  height: 40vh;
}
```

This creates an elliptical gradient starting from the top left corner of the element. Both linear and radial gradients allow you to specify color stops at precise positions. For example:

```css
.precise-gradient {
  background: linear-gradient(to right, red 20%, yellow 40%, blue 80%);
  height: 40vh;
}
```

This creates a gradient where red takes up the first `20%`, then transitions to yellow at `40%`, and finally to blue at `80%`.

Gradients can be used wherever you'd use an image in CSS. This makes them versatile for creating backgrounds, buttons, or even text effects when combined with other CSS properties.

Remember, while gradients can enhance the visual appeal of your website, it's important to ensure sufficient contrast for accessibility, especially when using gradients behind text.


## Module: Styling Forms


### Lecture Block: Lecture Best Practices For Styling Forms


## What Are Some Best Practices for Styling Text Inputs?

### Description

As with all text elements you need to ensure the styles you apply to the text input are accessible. This means the font needs to be adequately sized and the color needs to have sufficient contrast with the background.  

The placeholder, however, is often forgotten. It's important to remember that this is also text and you will likely need to change the styling to ensure it's readable.

Another thing to keep in mind is that you should allow the user to modify the input. For example, if it's a text area you should not remove the ability to resize it. The input should also scale accordingly when the user zooms the page.

Input elements are also focusable. When you are editing your styles you should take care that you preserve a noticeable indicator when the element has focus such as a bold border. Additionally there is the error state to consider. When the user's text does not pass the input validation there is a visual indicator that shows there is something wrong. As you give your element your personal flair you want to be sure that state is still noticeable and that it does not look similar to the focus indicator. With all this in mind you can now create captivating user forms.


## When Should You Use appearance: none to Deal with Issues Styling Search Inputs and Checkboxes?

### Description

Let's learn when to use `appearance: none` to address styling issues for search input, checkboxes and radio buttons.

Browsers apply default styling to a lot of elements. In the case of input elements your ability to style them with CSS can feel rather restricted. So, you may want to use `appearance: none` to hide aspects of the default element and build your own instead. For example, this would hide the default checkboxes for a checkbox input allowing you to use custom indicators like a green tick and a red X to show the state. For a search input, WebKit based browsers will show a default search icon and a cancel button. Hiding these allows you to create your own indicators that would appear on all browsers. 

WebKit is a software engine that helps web browsers display websites. Browsers like Safari use WebKit to make sure web pages look and work correctly. This `appearance: none` CSS property gives you complete control over the styling, but it does come with some things to look out for. The default interactive components of input elements include features such as focus and error indicators which you will need to ensure aren't lost.

Creating consistent cross-platform styling is a great reason to use this property. You can also use it to ensure that tap targets on a mobile device are large enough or that the colors of a checkbox have enough contrast.


## What Are Common Issues When Styling Special Input Elements?

### Description

Let's learn about some of the common issues when trying to style special input elements like the `datetime-local` and `color` inputs.

These special types of inputs rely on complex pseudo-elements to create things like the date and color pickers. This presents a significant challenge for styling these inputs. One challenge is that the default styling is entirely browser-dependent, so the CSS you write to make the picker look the way intend may be entirely different on another browser. 

Another may be the complexity of the pseudo-element. Consider the date selector; there are a lot of moving parts here and the complex structure of the pseudo-element might pose a significant challenge in applying styling to the right areas.

Of course, with these complex elements, you also run the risk of accidentally losing important functionality when you manually style them. Not only could you lose important indicators like the focus state or selected item but you could potentially break the selector entirely.  

For these reasons many developers rely on JavaScript libraries or custom components entirely instead of using the browser's built-in components.


## Module: Css Box Model


### Lecture Block: Lecture Working With Css Transforms Overflow And Filters


## What Is Overflow in CSS, and How Does It Work?

### Description

Overflow refers to the way elements handle content that exceeds or overflows the size of the containing element. For example, the text content of a `div` element can overflow out of its borders.

Overflow is two-dimensional, the x-axis determines horizontal overflow, and the y-axis determines vertical overflow. 

Let's fix the overflow on our example using the `overflow-y` CSS property. First we can hide the overflow entirely with `hidden` like this: 

```css
div {
  overflow-y: hidden;
}
```

TThis resolves the overflow problem but now the extra content becomes completely unreachable. Instead we can use scroll to force the element to become scrollable:
  
```css
div {
  overflow-y: scroll;
}
```

Now this turns the container into a scrollable element, allowing all the content to be viewed by scrolling the element independently of the page scroll. We could also let the browser handle it on its own with `auto` value. It's worth noting that vertical scrolling is generally considered okay while horizontal scrolling might be questioned as it's generally not a common design decision.

With this knowledge, you can now control how your content overflows giving you more power over the layout of your pages.


## What Is the CSS Transform Property, and How Does It Work?

### Description

The CSS `transform` property is a powerful tool that allows you to modify the visual presentation of elements on your webpage without affecting the layout of other elements. It enables you to apply various transformations to elements such as rotating, scaling, skewing, or translating (moving) them in 2D or 3D space.

The `transform` property works by applying a mathematical transformation to an element's coordinate system. This means you can manipulate an element's shape and position while keeping it's original place and document flow intact.

Let's explore some common transform functions. Here's an example of a box element:

```css
body {
  border: 2px solid black;
}

.box {
  width: 200px;
  height: 200px;
  background-color: red;
}
```

We have set the `body` to have a solid black border so that you can see the `.box` element nested inside the `body` element.

The `translate` function moves an element from its current position. Here's an updated example using the `translate` function:  

```css
body {
  border: 2px solid black;
}

.box {
  width: 200px;
  height: 200px;
  background-color: red;
  transform: translate(50px, 100px);
}
```

This CSS rule will move the element with the class `box` 50 pixels to the right and 100 pixels down from its original position.

The `rotate` function rotates an element around a fixed point and this is an example of using the `rotate` function for the `.box` element from earlier:  

```css
.box {
  margin: 100px;
  width: 200px;
  height: 200px;
  background-color: red;
  transform: rotate(45deg);
}
```

This will rotate the element forty five degrees clockwise.

The `scale` function allows you to change the size of an element. Here's an example:  

```css
.box {
  margin: 100px;
  width: 200px;
  height: 200px;
  background-color: red;
  transform: scale(1.5, 2);
}
```

This will make the element one and a half times wider and twice as tall as its original size.

You can combine multiple transformations in a single declaration:  

```css
.box {
  margin: 100px;
  width: 200px;
  height: 200px;
  background-color: red;
  transform: translate(50px, 50px) rotate(45deg) scale(1.5);
}
```

This will move the element 50 pixels to the right and down, rotate it 45 degrees, and scale it to be one and a half times its original size.

While the `transform` property is powerful for creating visually appealing designs, it's important to consider accessibility when using it. Here are some important accessibility concerns to keep in mind. 

Screen readers may not accurately convey transformed content. For example, if you use `transform` to rearrange the visual order of elements, screen readers will still read the content in the original DOM order. This can lead to confusion for users relying on screen readers.

When using `scale` to resize text be cautious not to make it too small or too large. Extremely small text can be difficult to read while overly large text might overflow its container and become unreadable. It's generally better to use proper font styling techniques for text resizing.

If you are using `transform` for animations effects, be mindful of users who are sensitive to motion. Excessive or rapid animations can cause discomfort or even trigger seizures for some people. Consider providing a way for users to reduce or turn off animations. When using 3D transforms, remember that not all users perceive depth in the same way. Ensure any critical information conveyed through 3D effects is also available in a 2D format or through text.

If you are using `transform` to hide or reveal content, make sure the content is still accessible to screen readers and keyboard navigation. Hidden content should be truly hidden such as by using `display: none;` or `visibility: hidden;`, rather than just being visually moved offscreen. 

When applying `transform` to interactive elements like buttons or links, ensure that the clickable area remains intuitive and easily targetable. A drastically transformed button might be visually confusing or difficult to click especially for users with motor impairments.

In conclusion, while the CSS `transform` property is a powerful for creating visually dynamic web designs, it's essential to use it responsibly with accessibility in mind. Always test your transformed elements with various assisted technologies and consider providing alternative ways to access information or functionality that might be affected by transforms.


## What Is the CSS Box Model, and How Does It Work?

### Description

The CSS box model is a fundamental concept for web development. It defines how HTML elements are structured and positioned. If you understand this model you will be able to control the size, spacing and appearance of the elements on your website.

In the CSS box model, every element is surrounded by a box. This box consists of four elements: the content area, the padding, the border, and the margin. 

The content area is the innermost part of the box. It's the space that contains the actual content of an element like text or images.

The padding is the area immediately after the content area. It's the space between the content area and the border of an element. With the padding you can add space around the content to improve it's readability. You can set different values for the top, right, bottom and left padding with the `padding` property.  

This is an example with the `padding` shorthand property, where we set the top padding to fifteen pixels, the right padding to five pixels, the bottom padding to two pixels and the left padding to eight pixels:  

```css
padding: 15px 5px 2px 8px;
```

The border is the outer edge or outline of an element in the CSS box model. It's the visual boundary of the element. You can customize the border style, width, color and other properties using the `border` property. Here's an example where we set the border to a width of five pixels, a solid state and a color of blue: 

```css
border: 5px solid blue;
```

If you omit a value the default property of that value will be used. That's `medium` for the width, `none` for the style and the current color for the color. 

You can set this three properties directly in the shorthand `border` property if you want all sides to be exactly the same. But if you want to assign a different style to each side you can use the `border-width`, `border-style` and `border-color` properties. 

```css
border-width: 2px 4px 7px 12px;
border-style: dashed solid solid dashed;
border-color: blue red green black;
```

You can write up the four values for each one of these properties. They will be applied in a clockwise sequence starting from the top. If you only write one value it will be applied to all four sides.

Finally, the margin is the space outside the border of an element. It determines the distance between an element and other elements around it. You can set different margin values for the top, right, bottom and left sides of the element using the `margin` property.  

So in this example the top margin is three pixels, the right margin is twelve pixels, the bottom margin is nine pixels and the left margin is seven pixels:  

```css
margin: 3px 12px 9px 7px;
```

These four components are essential for calculating the total width and height of an element.

In the next few lectures, you will learn more about how this is handled by the browser and how you can customize it. The CSS box model is a fundamental concept for web development.  

Understanding how this component interact and contribute to an element's dimensions is essential for implementing web designs.


## What Is Margin Collapsing, and How Does It Work?

### Description

Margin collapsing is a fundamental concept in CSS that often confuses newcomers to web development.

This behavior occurs when the vertical margins of adjacent elements overlap, resulting in a single margin equal to the larger of the two.

Understanding margin collapsing is important for precise control over spacing and layout in web design. So, let's get into how margin collapsing works and explore some common scenarios where it occurs.

In CSS when two vertical margins come into contact with each other they'll collapse, this means that instead of adding together the larger margin wins and determines the space between the elements. This behavior applies only to vertical margins top and bottom and not horizontal margins, not the left and right. So, here's an example to illustrate this concept:

```html
<style>
  .box1 {
    margin-bottom: 20px;
    background-color: lightblue;
  }
  .box2 {
    margin-top: 30px;
    background-color: lightgreen;
  }
</style>

<div class="box1">Box 1</div>
<div class="box2">Box 2</div>
```

In this example, you might expect the total space between `.box1` and `.box2` to be 50 pixels (20 pixels plus 30 pixels). However, due to margin collapsing the actual space will be 30 pixels, which is the larger of the two margins.

As we saw in the previous examples, margins of the adjacent sibling elements will collapse. This is the most straight forward case of margin collapsing. Let's explore more cases where margin collapsing can occur. 

Margins can also collapse between a parent element and its first or last child. If there's no border, padding, inline content, or clearance to separate the parent's margin from the child's, they will collapse.

```html
<style>
  .parent {
    margin-top: 40px;
    background-color: lightyellow;
  }
  .child {
    margin-top: 30px;
    background-color: lightpink;
  }
</style>

<div class="parent">
  <div class="child">Child element</div>
</div>
```

In this case you might expect the child to be 70 pixels from the top (40 pixels plus 30 pixels). However, the margins collapse and the larger margin 40 pixels is used.

If an element has no content, padding, or border, its top and bottom margins can collapse into a single margin. 

```html
<style>
  .empty-block {
    margin-top: 20px;
    margin-bottom: 10px;
    height: 0;
  }
  .next-block {
    background-color: lightgray;
  }
</style>

<div class="empty-block"></div>
<div class="next-block">Next block</div>
```

In this example the `empty-block`s top and bottom margins collapse into a single 30 pixels margin, the larger of the two.

Here's another example of preventing collapse using padding: 

```html
<style>
  .parent {
    margin-top: 40px;
    padding-top: 1px;
    background-color: lightyellow;
  }
  .child {
    margin-top: 30px;
    background-color: lightpink;
  }
</style>

<div class="parent">
  <div class="child">Child element</div>
</div>
```

In this case the one pixel padding on the parent prevents the margin from collapsing resulting in a total space of 71 pixels from the top of the parent to the top of the child content.

Understanding margin collapsing is important for precise control over layout and spacing in CSS. While it can sometimes lead to unexpected results, it's a feature designed to create more aesthetic and consistent spacing in documents. By knowing when margin collapsing occurs and how to prevent it when necessary, you can create more predictable and maintainable layouts in your web designs.


## What Is the Difference Between content-box and border-box?

### Description

The `box-sizing` property can be set to either `content-box` or `border-box` to control how the width and height of elements are calculated. Here you can see the `box-sizing` property and the two possible values: 

```css
box-sizing: content-box;
```

```css
box-sizing: border-box;
```

This property can be set on the universal selector (`*`) to apply to all the elements in the document:

```css
* {
  box-sizing: border-box;
}
```

The value of the `box-sizing` property is `content-box` by default, but you can choose `border-box` if you need to. We will explore `content-box` first and then we will go into `border-box`.

To understand how this models work, you need to be familiar with the four core concepts from the CSS box model. Let's review them quickly. The content area is the space occupied by the element's content. The padding is the space between the content area and the border. The border is the outline that surrounds the content area and the padding. The margin is the space outside the border that separates the element from other elements.

In the `content-box` model, the width and height that you set for an element determines the dimensions of the content area but they don't include the padding, border or margin. You should use `content-box` when you need to have precise control over the dimensions of the content area. So, when you set the width and height of an element with `width` and `height` properties, you are only setting the dimensions of the content area. `width` is the width of the content, `height` is the height of the content. 

To find the total width of the element, what you will really see on the screen, you will still need to add the left and right padding, and the left and right borders. So, the total width equals the total width plus the padding left, plus padding right, plus border left, plus border right. 

Likewise, the total height of an element can be found by adding the content height, the top and bottom border padding, and the top and bottom borders. So, the total height equals the content height plus padding top, plus padding bottom, plus border top, plus border bottom. 

For example, here we have a CSS type selector for all the `div` elements. 

```css
div {
  width: 300px;
  height: 200px;
  padding: 20px;
  border: 4px solid black;
}
```

In this case, if `content-box` is used the content area will have a width of 300 pixels and a height of 200 pixels. However, the total width, what you will see on the screen, will be the result of adding the width of the content area, which is 300 pixels, plus the padding on both sides (40 pixels), and the borders on both sides (8 pixels). 

Likewise, the total height will be the result of adding the height of the content area (200 pixels), plus the top and bottom padding (40 pixels), plus the top and bottom borders (8 pixels).

Great! Now let's explore `border-box`. They are a bit different, with `border-box` the width and height of an element include the content area, the padding, and the border, but they don't include the margin. You should use `border-box` when you need to keep a fixed element size regardless of changes in padding or borders. It's also helpful for responsive web design since the content area will adjust automatically to fit the dimensions.

The padding and border are inside the box, so when you set the `width` and `height` properties of an element, you're really setting the width and height of the inner part of the box. Here's our `div` example with the same properties and values that we had before: 

```css
div {
  width: 300px;
  height: 200px;
  padding: 20px;
  border: 4px solid black;
}
```

With `border-box` the value of the `width` property will be the result of adding the width of the content area, the left and right padding, and the left and right border. So, the width equals the width of the content, plus the left padding, plus the right padding, plus the left border, plus the right border.

Likewise, the value of the `height` property is the result of adding the height of the content area, the top and bottom padding, and the top and bottom border. Height equals the height of the content, plus top padding, plus bottom padding, plus top border, plus bottom border. The margin is not included in the width or height.

If you check the size of the `div` in the browser using the `content-box` and `border-box` you will notice that there's a very important difference. These are the two `div`s in HTML:

```html
<div id="red-div"></div>
<div id="blue-div"></div>
```

We assign them `id`s to select them individually in CSS. These are the CSS rules for the `#red-div` and the `#blue-div`:

```css
#red-div {
  box-sizing: content-box;
  width: 300px;
  height: 200px;
  padding: 20px;
  border: 4px solid black;
  margin: 10px;
  background-color: red;
}

#blue-div {
  box-sizing: border-box;
  width: 300px;
  height: 200px;
  padding: 20px;
  border: 4px solid black;
  margin: 10px;
  background-color: blue;
}
```

You can see that they both have the same `width`, `height`, `padding`, `border` and `margin`. The only differences are the colors and the value of the `box-sizing` property. This small difference has a very important impact on the final dimensions. 

Choosing between `content-box` and `border-box` really depends on the specific needs of your project. While `border-box` is becoming increasingly popular for its simplicity and flexibility, understanding both models is important for implementing effective CSS layouts.


## What Is a CSS Reset, and What Are Some Common Examples?

### Description

A CSS reset is a stylesheet that removes all or some of the default formatting that web browsers apply to HTML elements. For example, you might have noticed that certain elements, like paragraphs and headings, already have margins by default even if you don't define them explicitly in your custom stylesheets. 

You will also see this with various properties in a wide range of HTML elements. Different browsers may also apply different default styles to HTML elements. The default styles in Google Chrome may not be exactly the same as in Mozilla Firefox or Microsoft Edge. This can result in inconsistent styles across browsers which you should avoid as much as possible.

To handle this, a CSS reset removes the default styles. By removing all or some of the default styles, you can get a consistent baseline for your design and minimize the potential inconsistencies across browsers and devices. Removing default styles can also make the styling process easier because you will only see the styles that you have applied explicitly in your custom stylesheets. There are two main approaches to CSS resets: you can either define custom CSS resets or use third-party CSS resets.

Custom CSS resets are stylesheets that you create from scratch to fit the need of your project. This way you can control the specific styles that will be reset with a lot of room for flexibility. However, you also need to invest time to develop and maintain the stylesheets. Here's an example of a very common CSS rule for resetting the margin and padding of all HTML elements:

```css
* {
  margin: 0;
  padding: 0;
}
```

It's usually written at the top of the CSS stylesheet. The asterisk star selector is a wildcard selector that matches all HTML elements, so they will have a default margin of zero and a default padding of zero on all four sides. This will give you a starting point and then you can customize them in more specific CSS selectors further down in the stylesheet.

You can use this approach to select any HTML element and reset its default styles, just create a custom stylesheet and use the appropriate CSS selectors to match the elements and set the styles. 

But this can be a time intensive process if you want to save time you can also use a third-party CSS reset. These stylesheets are already pre-built so you can just download them and add them to your project directly. A great example of a third-party CSS reset is `Normalize.css`. This stylesheet normalizes styles for a wide range of HTML elements  while still keeping some useful default styles especially those that are important for accessibility. It also corrects bugs and style inconsistencies.

Another option is `sanitize.css`. This is a CSS library that you can use to ensure that default styles will be consistent across all major modern browsers. This library is developed alongside `Normalize.css` so they evolve together. It also has individual stylesheets that you can download for specific purposes like normalizing forms and typography.

There are many options available but you should choose the ones that best fit the needs of your project. You can also combine both approaches using third-party CSS resets with custom resets.

When working with CSS resets, it's also important to take accessibility into account. Your web application should be accessible to everyone. So, you shouldn't reset styles that might be helpful for screen readers or other assistive technologies. You should also consider the impact that these additional stylesheets may have on your applications performance, because they have to be downloaded before the custom styles are applied. 

By removing the default styles, CSS resets give you a blank starting point to implement your design. This results in a more uniform and consistent user experience across browsers and across devices.


## What Is the CSS Filter Property, and What Are Common Examples?

### Description

The CSS `filter` property is a powerful tool that allows you to apply  graphical effects to elements on a web page. It's particularly useful for adjusting the visual presentation of images, backgrounds and even text without modifying the original asset.

The `filter` property can be used to create various effects, such as blurring, color shifting, and contrast adjustments. Let's discuss how the filter property works and explore some common examples. The basic syntax for a `filter` property is straightforward:

```css
selector {
  filter: function(amount);
}
```

Here `function` represents the specific filter effect you want to apply, and `amount` is typically a value that determines the intensity of the effect. Now let's look at some common filter functions and their uses.

```css
img {
  filter: blur(5px);
}
```

The `blur` function applies a gaussian blur to the element, the amount is specified in pixels and represents the radius of the blur. This CSS rule will apply a 5 pixel blur to all images on the page. The `blur` effect can be useful for creating depth in your design or for obscuring parts of an image. 

The `brightness` function adjusts the brightness of the element. A value of `0%` will make the element completely black, while values over `100%` will increase the brightness. 

```css
.bright-image {
  filter: brightness(150%);
}
```

This CSS rule increases the brightness of elements with the class `bright-image` by `50%`. Brightness adjustments can be used to make images pop or create a washed-out effect.

The `grayscale` function converts the element to grayscale. The amount is defined as a percentage, where `100%` is completely grayscale and `0%` leaves the image unchanged.

```css
.gray-image {
  filter: grayscale(100%);
}
```

This rule will convert elements with the class `gray-image` to complete grayscale. `grayscale` can be used to create a vintage look or de-emphasize certain elements on a page.

The `sepia` function applies a sepia tone to the element. Like grayscale, it uses a percentage value: 

```css
.old-photo {
  filter: sepia(80%);
}
```

This rule applies an `80%` sepia effect to elements with the class `old-photo`. The sepia effect is great for creating a vintage or old-timey look.

The `hue-rotate` function applies the hue rotation to the element. The value is defined in degrees, and represents a rotation around the color circle. 

```css
.color-shift {
  filter: hue-rotate(90deg);
}
```

This rule rotates the hue of elements with the class `color-shift` by `90` degrees. Hue rotation can be used to create psychedelic effects or to adjust the overall color scheme of an image.

One of the most powerful aspects of the `filter` property is the ability to combine multiple effects. You can apply several filters to the same element by separating them with spaces: 

```css
.multi-filter {  
  filter: contrast(150%) brightness(110%) sepia(30%);  
}
```

This rule applies increased contrast, slightly increased brightness, and a subtle sepia effect to elements with the class `multi-filter`. 

By combining filters you can create complex and unique visual effects tailored to your design needs. The CSS filter property is a versatile tool that allows for creative visual manipulation of web elements. 

While we have covered some of the most common filter functions, there are others available, such as `contrast`, `invert`, and `saturate`. As with any powerful feature, it's important to kind of be careful with how you use the filters to enhance your design without overwhelming your users or compromising accessibility.


## Module: Css Flexbox


### Lecture Block: Lecture Working With Css Flexbox


## What Is CSS Flexbox, and When Should You Use It?

### Description

CSS flexbox is a one-dimensional layout model that allows you to arrange elements in rows and columns within a container. You can also control their order and orientation. Web developers use it to create responsive websites and web applications that adapt to different screen sizes and orientations. We refer to flexbox as a one-dimensional layout model because it focuses on arranging elements along a single axis at a time. The axis can be either horizontal or vertical. 

There are two key concepts that you should know about before you start working with flexbox: flex container and flex item.

A flex container is an HTML element with a flex layout. You can arrange and align elements in various ways within a flex container. To make an HTML element a flex container, you need to add `display: flex` to its CSS styles.

Flex items are the direct children of a flex container. These elements can be arranged and aligned within a flex container based on its properties. They can also shrink or expand to fit the available space.

This is an example with a `main` container and three child `div` elements:

```html
<main>
  <div id="first-div"></div>
  <div id="second-div"></div>
  <div id="third-div"></div>
</main>
```

If you set only the `width`, `height`, and `background-color` of these `div` elements in the CSS stylesheet, every child element will be placed on its own row because the container is not flex by default. That is:

```css
div {
  width: 80px;
  height: 50px;
}

#first-div {
  background-color: #4d70b2;
}

#second-div {
  background-color: #5c4db2;
}

#third-div {
  background-color: #4da3b2;
}
```

But if you add `display: flex` to the `main` container, the `div` elements will be rearranged to fit on the same row and they will shrink if necessary:

```css
main {
  display: flex;
}
```

By default, a flex container will be a block-level element, so the container itself will be on its own row relative to other elements and containers.

Now that you know more about flex containers and flex items, you should also know about flex properties. These properties determine how flex items will be arranged, resized, and distributed within the flex container. Some of the most commonly used ones are `flex-direction`, `justify-content`, `align-items`, and `flex-wrap`.

Great. Now let’s talk a little bit about the flex model. This model defines how flex items are arranged within a flex container. Every flex container has two axes:

- The main axis.
- The cross axis.

The orientation of these axes determines how different properties will affect the layout and distribution of the flex items. By default, the main axis of a flex container is horizontal and the cross axis is vertical. Flex items are arranged in the direction of the main axis. The cross axis is perpendicular to the main axis.

The `flex-direction` property sets the direction of the main axis. The default value of `flex-direction` is `row`, which places all the flex items on the same row, in the direction of your browser's default language (left to right or right to left):

```css
flex-direction: row; /* Default */
```

To reverse the items in the row, you can use `flex-direction: row-reverse`:

```css
flex-direction: row-reverse; 
```

This will reverse the order of the flex items. If you want to align the flex items vertically instead, you just need to set `flex-direction` to `column` in the flex container. This will change the direction of the main axis:

```css
flex-direction: column;
```

Now the `div` elements will be aligned vertically because the main axis will be vertical and the cross axis will be horizontal. You can also reverse the order of the flex items vertically with `flex-direction: column-reverse`:

```css
flex-direction: column-reverse;
```

CSS flexbox is a powerful layout model that provides a flexible and efficient way to arrange elements within a container. By understanding the key concepts of flex containers, flex items, and the various flex properties, you can create dynamic and responsive websites that adapt to different screen sizes and orientations.


## What Are Some Common Flex Properties, and How Do They Work?

### Description

Flex properties are properties that you can apply to flex containers to determine the distribution of child elements. We'll cover some of the most commonly used ones: `flex-wrap`, `justify-content`, and `align-items`.

Let's start with `flex-wrap`. This property determines how flex items are wrapped within a flex container to fit the available space. `flex-wrap` can take three possible values: `nowrap`, `wrap`, and `wrap-reverse`. `nowrap` is the default value—flex items won't be wrapped onto a new line, even if their width exceeds the container's width.

In the code below, we have three `div` elements. Let's focus on the `width`. The `main` container bordered in red has a `width` of `200px`, while its three child `div` elements combined have a `width` of `240px` (`80px` each):

```css
main {
  width: 200px;
  display: flex;
  border: 2px solid red;
}

div {
  width: 80px;
  height: 50px;
}

#first-div {
  background-color: #4d70b2;
}

#second-div {
  background-color: #5c4db2;
}

#third-div {
  background-color: #4da3b2;
}
```

The width of the `div` elements exceeds the width of their container, but by default they will be shrunk to fit the available space. If you do want to wrap them when they exceed the width of their container, you can set `flex-wrap: wrap` on the flex container:

```css
flex-wrap: wrap;
```

The `div` elements will be rearranged in rows when they exceed the width of their container. You can wrap flex items in reverse order with `flex-wrap: wrap-reverse`. The `flex-flow` property is a shorthand property for `flex-direction` and `flex-wrap`. In this example, we set `flex-direction` to `column` and `flex-wrap` to `wrap-reverse`:

```css
flex-flow: column wrap-reverse;
```

Great. Now let's talk about `justify-content`. `justify-content` aligns the child elements along the main axis of the flex container. If you assign the value `flex-start` to `justify-content`, the flex items will be aligned to the start of the main axis. This could be horizontal or vertical:

```css
justify-content: flex-start;
```

With `justify-content: flex-end`, flex items are aligned to the end of the main axis, horizontally or vertically. To center the flex items along the main axis, you can use `justify-content: center`. To distribute the elements evenly along the main axis, you can use `justify-content: space-between`. This will add some space between the flex items if needed.

`justify-content: space-around` distributes flex items evenly within the main axis, adding a space before the first item and after the last item. This additional space is half of the space between each pair of adjacent items. If there's only one item to distribute, it will be centered.


And last but not least, we have `justify-content: space-evenly`, which distributes the items evenly along the main axis. The space between the items and the space before and after the first and last elements, are exactly the same:

```css
justify-content: space-evenly;
```

Great. Now you know how to distribute flex items along the main axis. But you may also want to distribute them along the cross axis. Remember that the cross axis is perpendicular to the main axis. You can do this with the `align-items` property. To center the items along the cross axis, you just need to add `align-items: center` to the flex container: 

```css
align-items: center;
```

In this example, the flex items are centered along the cross axis, which is vertical by default. If the cross axis is horizontal, they will be centered horizontally instead. In contrast, `align-items: flex-start` aligns the items to the start of the cross axis:

```css
align-items: flex-start;
```

The opposite is `align-items: flex-end`. This will align flex items to the end of the cross axis, vertically or horizontally. To stretch the flex items along the cross axis, you can use `align-items: stretch`. This also works with elements that are automatically sized, such as those without set `width` or `height`, or with only a minimum `width` or `height`. The flex items will stretch to fill the container in the direction of the cross axis.

And finally, you can use the `align-self` property to assign a different alignment on the cross axis to an individual flex item. For example, you can stretch it with `align-self: stretch`. You can center it with `align-self: center`. You can align it to the start of the cross axis with `align-self: flex-start`. Or you can align it to the end of the cross axis with `align-self: flex-end`.

There are other flex properties and values that you can choose from to create the responsive layout that you envision, but these are the most commonly-used ones. With these CSS flex properties and your new knowledge of the CSS flex model, you can start creating responsive layouts to create a smooth and inclusive user experience across devices.


## Module: Css Typography


### Lecture Block: Lecture Working With Css Fonts


## What Are the Fundamentals of Typography?

### Description

Typography is the art of choosing the right fonts and format to make text visually appealing and easy to read. "Type" refers to how the individual characters are designed and arranged. By choosing the right fonts for your project, you can evoke emotions, establish hierarchy, and reinforce your brand's identity.

We'll start by talking about typefaces and fonts. A typeface is the overall design and style of a set of characters, numbers, and symbols. It's like a blueprint for a family of fonts. A font is a specific variation of a typeface with specific characteristics, such as size, weight, style, and width.

Two very important examples of typefaces are Serif and Sans Serif. The Serif typeface has a classical style with small lines at the end of characters. Serif typefaces are commonly used for printed materials, like books. Some examples are Times New Roman, Georgia, and Garamond. 

In contrast, the Sans Serif typeface has a more modern look, without the small lines at the end of characters. Sans Serif typefaces are commonly used in digital design because they are easy to read on screen. Some examples include Helvetica, Arial, and Roboto. There are other typeface classifications, like Script, Blackletter, Monospaced, and Decorative.

We mentioned that typefaces are like blueprints for fonts, right? Well, fonts can also be grouped if they share a similar design. Different weights and styles can be combined. For example, Times New Roman includes variations like Times New Roman Bold, Times New Roman Italic, and Times New Roman Bold Italic. These variations within the same font family typically include:

- Weight: The thickness of the characters, including light, regular, bold, and black.
- Style: The slant and orientation of the characters, like italic and oblique.
- Width: The horizontal space occupied by characters, condensed and expanded.

Great. Now let's explore the fundamental elements of typography:

- The baseline is the imaginary line on which most characters rest. 
- The cap height is the height of uppercase letters, measured from the baseline to the top. 
- The x-height is the average height of lowercase letters, excluding ascenders and descenders.
- Ascenders are the parts of lowercase letters that extend above the x-height, such as the tops of the letters `h`, `b`, `d`, and `f`.
- Descenders are the parts of lowercase letters that extend below the baseline, such as the tails of `y`, `g`, `p`, and `q`.

There are more advanced concepts too, like kerning, tracking, and leading.

Kerning is how space is adjusted between specific pairs of characters to improve their readability and aesthetics. For example, reducing the space between the letters `A` and `V`. Tracking is how space is adjusted between all characters in a block of text. It's essentially the distance between the characters. It affects how dense and open the text will be. Leading is the vertical space between lines of text. It's measured from the baseline of one line to the baseline of the next line.

Being familiar with these concepts is essential for choosing the right font for your project. 

Line length can also have a significant impact on readability. If the text is too narrow, readers will need to refocus too often. If the text is too wide, they may experience fatigue. You should find the optimal line length for comfortable reading.

With typography, you can also create a visual hierarchy, helping readers understand what parts of the text or user interface are most important. Larger fonts usually indicate that text is more important. Making the text bold is also helpful for emphasizing it.

Underlining text or presenting it in italics is helpful for highlighting key points. Providing accurate spacing around the text can highlight its importance. And color contrast can bring readers' attention to specific parts of the text.

Having basic knowledge of typography is essential for designing visually engaging applications. By understanding fonts, spacing, and hierarchy, you can create visual experiences that enhance the readability of your content and reinforce your brand's identity


## What Are Some Best Practices for Working with Typography in Your Designs?

### Description

Typography is the art and technique of arranging type to communicate effectively. It involves formatting text and selecting appropriate fonts. In this lecture, you will learn best practices for using typography in a way that enhances readability, hierarchy, and accessibility. 

Let's start with readability. You should choose clear and simple fonts to make your designs easy to understand. This is particularly important for the main text of your website. Users are more likely to engage with your content if the font is easy to read. Some frequently used fonts for web development are Roboto, Open Sans, Poppins, Lato, and Barlow. But there are many to choose from and you will definitely find one that fits your needs.

Text should also be large enough for everyone to read it. You should try to keep lines relatively short. The specific number of characters per line really depends on your project. But keeping lines short will make the content easier to read.

You can use font size to create a visual hierarchy for headings, subheadings, paragraphs, and other elements. For example, the main heading on a webpage should have a larger font, followed by subheadings with smaller font sizes. This will give every element in the hierarchy a specific font size that helps users navigate through the structure visually.

You should use two or three fonts at most to create a visual consistency. Using too many fonts can make the text more difficult to read and weaken your branding's identity. This can also impact the user experience by increasing the load time of the website.

Once you choose these two or three fonts, use them consistently across different pages and elements. These fonts should be consistent with the overall design of your web application, product, or service. You should also use whitespace to create a visual balance and enhance readability.

For accessibility purposes, you should follow the Web Content Accessibility Guidelines. These guidelines set the recommended contrast ratio for text. A higher contrast ratio makes text easier to read, especially for people with visual disabilities.

You should also provide options to adjust font size and avoid complex fonts as much as possible. As a general rule, you should use simple fonts whenever possible. If your content is easy to read, users are more likely to engage with it. A final tip for working with typography is making sure that your fonts are displayed correctly on different screen sizes and devices.

Typography is a powerful tool for creating beautiful designs and engaging user experiences. By understanding the fundamentals of typography and applying these best practices, you can create effective designs.


## What Are Font Families and How Do They Work?

### Description

A font family is a group of fonts that share a common design. All the fonts that belong to the same family are based on the same core typeface, but they also have variations in their style, weight, and width. You can think of them as siblings who share similar characteristics but also have some differences. For example, Arial is a font family that includes variations like Arial Bold and Arial Italic.

In CSS, you can set the font family with the `font-family` property. That is, you write the property followed by a colon, a space, and the font family that will be assigned:

```css
font-family: Arial;
```

But what if the font family is not found? You can specify multiple font families in order of priority, from highest to lowest, by separating them with commas. These alternative fonts will act as fallback options. In this example, Arial is a primary font and Lato is an alternative font:

```css
font-family: Arial, Lato;
```

The browser will render the first font (Arial) if it's found on the device. If not, the second font (Lato) will be rendered.

You should also know how this process works behind the scenes. The selection process doesn't stop if the first font is available. The font family is chosen one character at a time, so if a font lacks a specific character, the browser looks for it in the lower-priority fonts. Interesting, right?

In the context of web development, you'll also find generic font families. They're very important. A generic font family is a default font that web browsers will render when the higher priority fonts are not available. To ensure that the content is still readable, the browser replaces the original font with the most appropriate font found, based on the generic font family specified. Some of the most commonly used ones are: 

- serif
- sans-serif
- monospace
- cursive
- fantasy 

But there are more options to choose from. In the code below, we have three alternative font families:

```css
font-family: Arial, Lato, sans-serif;
```

Arial has the highest priority. If Arial is not found, then the browser will try to render Lato. If neither is found, the browser will use the generic sans-serif font family, selecting a font with these characteristics from those installed on the user's system.

You should always include a generic font family at the end of the font-family list. Keep in mind that the generic font may look different from the font that you originally envisioned in your design, so it's always helpful to check how these fallback fonts look on different browsers.

To make the user experience as consistent as possible, it's also recommended to use web-safe fonts. These font families are usually installed on most devices, so they're very likely to be found and rendered correctly for most users. You'll learn more about them in the next lectures.

Font families are essential in the world of web design. By using the font-family property, you can instantly transform the look and feel of your text.


## What Are Web Safe Fonts?

### Description

Web-safe fonts are a subset of fonts that are very likely to be installed on a computer or device. They are widely supported across different operating systems and web browsers, so it's very likely that they will be rendered and displayed consistently. Let's see how this works.

Browsers are responsible for interpreting and displaying fonts on a website. When the browser has to render a font, it tries to find the font file on the user's system. But if the font is not found, it will usually fall back to a default system font. This ensures that the content is still readable, even if the specific font that should be rendered on the website is missing.

However, the fallback font selected by the browser may look very different from the font that was originally supposed to be rendered. This can have a critical impact on the overall design and user experience. To avoid this, you should use web-safe fonts whenever possible. You have two options. You can either use them as your primary fonts or you can use custom fonts with a web-safe font as a fallback option. This way, you can control how the website will look in case the custom font is not found.

Let's check out some examples of web-safe fonts. In a previous lecture, you learned that sans-serif fonts are commonly used for web development because they don't have small "feet" or lines at the end of the characters, so they're easy to read on screen. Some examples of web-safe sans-serif fonts are:

- Arial
- Verdana
- Trebuchet MS

In contrast, serif fonts do have small "feet" at the end of the characters, so they're commonly used for traditional print. But if you ever need to use them for web development purposes, web-safe serif fonts include:

- Times New Roman
- Georgia

By using web-safe fonts, you can make sure that your design looks consistent across devices and platforms. They can also enhance accessibility for users with visual disabilities, since they are simple and easy to read. And finally, web-safe fonts can reduce page load time, since they don't have to be downloaded if they're already installed.

Now that you know what web-safe fonts are, you can start using them and assigning them as fallbacks to create reliable user experiences across browsers and platforms.


## What Is the @font-face At-Rule, and How Does It Work?

### Description

Before we dive in, you should know what an at-rule is in CSS. At-rules are statements that provide instructions to the browser. You can use them to define various aspects of the stylesheet, such as media queries, keyframes, font faces, and more. You'll learn more about concepts like media queries and keyframes in future lectures. This time, you'll learn about the `@font-face` at-rule.

With `@font-face`, you can define a custom font by specifying the font file, format, and other important properties, like weight and style. This is the basic syntax. You can see `@font-face` followed by a block enclosed by curly brackets:

```css
@font-face {
  /* Descriptors */
}
```

Within the curly brackets, you will need to include descriptors to customize your font face. Let's see some of the most commonly used ones. The font-family descriptor specifies the name that you will use throughout the stylesheet to refer to that font. For example, let's say that you define this `@font-face rule`. It has the `font-family` descriptor defined and its value is `MyCustomFont`:

```css
@font-face {
  font-family: "MyCustomFont";
}
```

In that case, you would need to use that name in your stylesheet wherever you want to assign that custom font family to all the elements matched by a CSS selector. For example, you would use it as the value of `font-family`:

```css
body { 
  font-family: "MyCustomFont"; 
}
```

But for the `@font-face` at-rule to be valid, you also need to specify the `src`. This contains references to the font resources. It's basically a list of external references or locally-installed font face names separated by commas. It can also include hints about the format and technology of the font resources.

In the code below, the `src` is defined. The value is a list of URLs separated by commas and placed on separate lines to improve readability:

```css
@font-face {
  font-family: "MyCustomFont"; 
  src: url("path/to/font.woff2"),
    url("path/to/font.woff"),
    url("path/to/font.otf");
}
```

You can call the `url()` function to include a file in your stylesheet. In this case, we are including the font files. You'll need to write the file path within parentheses and quotation marks, including the file extension. To improve readability, you can write each resource on a different line, but the last one should end with a semicolon.

For each font resource, you can also specify the format. This is optional. It's a hint for the browser on the font format. If the format is omitted, the resource will be downloaded and the format will be detected after it's downloaded. If the format is invalid, the resource will not be downloaded.

Possible font formats include `collection`, `embedded-opentype`, `opentype`, `svg`, `truetype`, `woff`, and `woff2`.

Here's an example with font formats. Notice how we write the specific format within parentheses and quotes:

```css
@font-face {
  font-family: "MyCustomFont"; 
  src: url("path/to/font.woff2") format("woff2"),
    url("path/to/font.otf") format("opentype"),
    url("path/to/font.woff") format("woff");
}
```

In this example, you can see that we're specifying the WOFF2 format, the OpenType format, and the WOFF format.

woff stands for "Web Open Font Format." The difference between WOFF and WOFF2 is the algorithm used to compress the data. OpenType is a format for scalable computer fonts developed by Microsoft and Adobe that allows users to access additional features in a font. It's widely used across major operating systems.

In addition to specifying the format, you can also specify the technology of the font resource. This is optional too. Here's an example where we specify the technology of the second font resource.

```css
@font-face {
  font-family: "MyCustomFont"; 
  src: url("path/to/font.woff2") format("woff2"),
    url("path/to/font.otf") format("opentype") tech(color-COLRv1),
    url("path/to/font.woff") format("woff");
}
```

These are the fundamentals of the `@font-face` rule. With this at-rule, you can specify the font file to define custom fonts for your unique designs.


## How Do You Work with External Fonts Like Font Squirrel and Google Fonts?

### Description

An external font is a font file that is not included directly within your project files. They're usually hosted on a separate server. A server is a computer that provides data or services to other computers over a network. You will learn more about servers in future lectures. External fonts give you more flexibility because you can use custom fonts that may not be installed on the user's device.

Google Fonts and Font Squirrel are popular online resources for finding and using free fonts for web development purposes. You can incorporate them into your projects very easily.

Let's start with Google Fonts. This is a Google service that offers a collection of fonts, many of which are designed specifically for web development. On the Google Fonts user interface, you can see many different elements. Let's go through them one by one. On the left sidebar, you will find:

- A section to see, find, and filter fonts.
- A special section on Noto, a collection of high-quality fonts with various weights, widths, and styles that are perfect for communicating in more than 1,000 languages and over 150 writing systems.
- A section where you can find and download icons for your web projects.
- A section where you can learn more about fonts and their best practices, followed by frequently asked questions.

To add a Google Font to your website, you should go to the first section (Fonts). You can customize the preview text on the left sidebar, where it says "Preview." Just write the text that you would like to see and it will be updated automatically. This is helpful to preview the font with the text that you already have in mind for your website. You can also adjust the font size and filter the fonts based on their characteristics. 

To see more information about a font, just click on it and you will see important information about the font, like who designed it, preview text, and different styles, like light, regular, medium, bold, and black. If you click on the options at the top, you can go to the type tester, see individual glyphs, and learn more about the font and its license.

You can customize the font size of the preview text with the blue slider located next to the field where you can enter the preview text. Once you're ready to add the font to your project, click on the blue "Get font" button at the top. You'll be taken to a summary page where you'll see the fonts that you currently have selected. You can have multiple fonts selected simultaneously.

Next, you have to choose if you would like to download the font files to add them to your project as local files or if you would like to use them as external fonts and download them from Google's servers when a user enters your website. Click on "Download all" if you want to download them but if you prefer to use them as external fonts on Google's servers, click on "Get embed code." If you click on "Get embed code," you'll see the instructions that you should follow to add these external fonts to your project.

For web development projects, you have two options. You can either use a `link` element or `@import`. If you choose the `link` element option, you can copy and paste the HTML snippet and the CSS rules to add them to your project. You should embed the code in the `head` element of your HTML file and add the CSS rules that fit your needs. For example, this is what you would add to your HTML file to add all Roboto styles:

```html
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel="stylesheet">
```

And this is the CSS:

```css
.roboto-thin {
  font-family: "Roboto", sans-serif;
  font-weight: 100;
  font-style: normal;
}

.roboto-light {
  font-family: "Roboto", sans-serif;
  font-weight: 300;
  font-style: normal;
}

.roboto-regular {
  font-family: "Roboto", sans-serif;
  font-weight: 400;
  font-style: normal;
}

.roboto-medium {
  font-family: "Roboto", sans-serif;
  font-weight: 500;
  font-style: normal;
}

.roboto-bold {
  font-family: "Roboto", sans-serif;
  font-weight: 700;
  font-style: normal;
}

.roboto-black {
  font-family: "Roboto", sans-serif;
  font-weight: 900;
  font-style: normal;
}

.roboto-thin-italic {
  font-family: "Roboto", sans-serif;
  font-weight: 100;
  font-style: italic;
}

.roboto-light-italic {
  font-family: "Roboto", sans-serif;
  font-weight: 300;
  font-style: italic;
}

.roboto-regular-italic {
  font-family: "Roboto", sans-serif;
  font-weight: 400;
  font-style: italic;
}

.roboto-medium-italic {
  font-family: "Roboto", sans-serif;
  font-weight: 500;
  font-style: italic;
}

.roboto-bold-italic {
  font-family: "Roboto", sans-serif;
  font-weight: 700;
  font-style: italic;
}

.roboto-black-italic {
  font-family: "Roboto", sans-serif;
  font-weight: 900;
  font-style: italic;
}
```

There's a CSS rule for each font style. Each rule assigns the custom fonts with fallback fonts in case the custom fonts are not loaded properly.

If you choose the `@import` option instead, you will need to add that rule to your CSS file. Here is an example:

```css
@import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap');
```

The CSS rules are exactly the same.

If you only want to include specific font styles, you also have the option to remove them from these snippets. The HTML and CSS snippets will be updated automatically. 

And this is Google Fonts. It's one of the most popular options for finding free and open source fonts for web development projects.

Another great option is Font Squirrel, where you can find and download the custom fonts that you envision for your design. If you search for a font and click on a result, you'll see more details about the font, including specimens, test drive, glyphs, and Webfont kit. You can also see samples of the different styles and variations of the font, like thin, light, medium, bold, and black.

Once you've decided on a font that you want to use in your project, go to the "Webfont Kit" tab. Here, you can check if the font's license allows you to use it in `@font-face` CSS embeddings. You can also choose the subset and format.

Clicking on the "Download @font-face Kit" button will download a compressed (zip) file. If you unzip it, you'll find a "web fonts" folder, the license as a text file, and an HTML file with instructions on how to use web fonts. The web fonts folder will have all the font files that you need for your project. You will find them grouped into specific folders for the different fonts styles.

If you open the HTML file on a browser, it has instructions on how to add the fonts to your project, how to include them in the stylesheet with the `@font-face` declaration, and how to use them in the CSS rules.

This is how you can add custom Font Squirrel fonts to your project. You can also host them on a separate server and use them as external fonts. External fonts are very helpful for customizing the overall look and design of your website. They can make your website truly unique.

However, you should also keep in mind that using multiple external fonts can increase the load time of the website, affecting its overall performance. You should always strive to find a balance between style and efficiency.


## What Is the text-shadow Property, and How Does It Work?

### Description

CSS doesn't apply any shadows to the text by default. This is an example of a paragraph without any shadows. But if you do need to add shadows, you can use the `text-shadow` property.

```css
text-shadow: /* Values */
```

In CSS, you can describe a shadow through a combination of its `X` offset, `Y` offset, blur radius, and color. First, you need to specify the `X` and `Y` offset, which represent the horizontal and vertical distance of the shadow from the text, respectively. These values are required.

Here's an example of how to apply an `X` and `Y` offset on a shadow. We apply the `text-shadow` property with an x-offset of `3px` and a y-offset of `2px`:

```html
<p>Hello, World!</p>
```

```css
p {
  text-shadow: 3px 2px;
}
```

In the browser, the text and the shadow will look similar but we can also customize the color of the shadow by specifying the value before or after the offset. Let's set the shadow color. We will use a hexadecimal color here but you can use any valid color format. 

```css
p {
  text-shadow: 3px 2px #00ffc3;
}
```

We are writing the color after the offset but you can also write the color before the offset if you prefer. It's equivalent:

```css
p {
  text-shadow: #00ffc3 3px 2px;
}
```

In the browser, the shadow will have a specific color, so we can distinguish it very easily from the text. Now that we can differentiate the shadow from the text, it's also important to see how positive and negative values affect the shadow offset. Positive values of the `X` offset and `Y` offset will move the shadow right and down, respectively, while negative values will move the shadow left and up. Here's an example that uses negative values instead:

```css
p {
  text-shadow: -3px -2px #00ffc3;
}
```

Now the shadow will move left and up in relation to the text. Great. But the shadow is not looking very nice, because it looks exactly like the original text but placed behind it. To make it look nicer, we need to add a third value, the blur radius. This value is optional but makes the shadow look a lot smoother and more subtle. The default value of the radius blur is zero. The higher the value, the bigger the blur, which means that the shadow becomes lighter.

Here, we are setting the blur radius to `3px` and we're back to positive values for the offset:

```css
p {
  text-shadow: 3px 2px 3px #00ffc3;
}
```

Now it's starting to look like a shadow. It's more blurry and subtle, so we can focus on the main text while the shadow adds some style in the background. From here, we can tweak the values a little bit until we find a combination of offset, color, and blur radius that fits our needs.

It's also helpful to know that the text can have more than one shadow. You just need to write them in the same `text-shadow` property separated by commas. They will be applied in layers, from front to back, with the first shadow at the top.

Here's an example of a paragraph with three shadows applied in layers. Notice that all these shadows are defined in the same `text-shadow` property and separated by commas:

```css
p {
  text-shadow: 
    3px 2px 3px #00ffc3, 
    -3px -2px 3px #0077ff, 
    5px 4px 3px #dee7e5;
}
```

`text-shadow` is a powerful CSS property for making your text stand out. It can also enhance the overall design of your web application. By choosing the offset, blur, and color, you can create a wide range of shadow effects.


## Module: Css And Accessibility


### Lecture Block: Lecture Best Practices For Accessibility And Css


## What Are Some Tools to Check for Good Color Contrast on Sites?

### Description

When designing websites, ensuring good color contrast is crucial for accessibility and readability. Several tools are available to help developers and designers check and maintain appropriate color contrast ratios on their sites. One popular tool is WebAIM's Color Contrast Checker.

This online tool allows you to input the foreground and background colors of your design and instantly see if they meet the Web Content Accessibility Guidelines (WCAG) standards. It's user-friendly and provides immediate feedback on whether your color choices pass or fail the contrast requirements.

To use WebAIM's Color Contrast Checker, simply visit their website and enter the hexadecimal codes for your foreground and background colors. The tool will then calculate the contrast ratio and indicate whether it meets the WCAG 2.0 level AA or AAA standards. Here's an example of how you might use color values in your CSS:

```css
body {
  background-color: #FFFFFF;
  color: #333333;
}
```

In this example, we've set a white background (`#FFFFFF`) and dark gray text (`#333333`). You can input these color codes into the WebAIM tool to check their contrast ratio.

Another valuable tool is the TPGi Colour Contrast Analyzer. This desktop application offers more advanced features compared to online tools. It allows you to analyze entire web pages, not just individual color pairs. You can use its color picker to select colors directly from your screen, making it easier to check contrast ratios for existing designs.

The TPGi Colour Contrast Analyzer also provides simulations for different types of color vision deficiencies, helping you ensure your design is accessible to users with various forms of color blindness.

To use the TPGi Colour Contrast Analyzer, download and install the application on your computer. Once installed, you can use its eyedropper tool to select colors from your screen and instantly see the contrast ratio. This is particularly useful when working with complex designs or checking contrast on live websites.

Both these tools are invaluable for creating accessible and readable websites. They help ensure that your text is legible against its background, which is essential for all users but particularly important for those with visual impairments. Remember, while these tools are extremely helpful, they should be used in conjunction with manual testing and user feedback. Different contexts and user needs may require adjustments beyond what automated tools can suggest.

By regularly using tools like WebAIM's Color Contrast Checker and the TPGi Colour Contrast Analyzer, you can create designs that are not only visually appealing but also inclusive and accessible to a wider audience. This attention to detail in color contrast can significantly improve the user experience of your website for all visitors.


## What Are Best Practices for Hiding Content So It Doesn't Become Inaccessible?

### Description

Hiding content on a webpage is a common practice in web development, but it's crucial to do it in a way that doesn't compromise accessibility. Different hiding techniques can have varying impacts on how assistive technologies interpret and present the content to users. Let's explore some best practices for hiding content while maintaining accessibility. One common method to hide content is using `display: none`. Here's an example:

```css
.hidden {
  display: none;
}
```

While this effectively hides the content visually, it also removes it from the accessibility tree. The accessibility tree is a structure used by assistive technologies, such as screen readers, to interpret and interact with the content on a web page. It represents the content and its semantic meaning in a way that assistive technology can understand and present to the user.

Using `display: none` means that screen readers and other assistive technologies won’t be able to access this content, as it is not included in the accessibility tree. Therefore, it is important to use this method only when you want to completely remove content from both visual presentation and accessibility. 

Another approach to hiding content is using `visibility: hidden`:

```css
.hidden {
  visibility: hidden;
}
```

`visibility: hidden` hides the content visually but keeps it in the document flow, meaning it still occupies space on the page. Like `display: none`, `visibility: hidden` also removes content from the accessibility tree. This means that assistive technologies, like screen readers, will not be able to access the hidden content. Only use `visibility: hidden` when you want to hide content from everyone, including people who use assistive technology.

For content that should be hidden visually but remain accessible to screen readers, you can use a technique often referred to as "visually hidden" or "screen reader only". Here is an example using the `.sr-only` CSS class which is a common technique used to visually hide content while keeping it accessible to screen readers:

```css
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}
```

In this example, we are using properties like `position`, `clip`, and `white-space`, which you will learn about in future lectures. For now, just know that this CSS rule effectively hides the content visually while keeping it accessible to screen readers. It's useful for providing additional context to screen reader users without affecting the visual layout. 

For toggling content visibility, consider using the `hidden` attribute:

```html
<div hidden>This content is hidden</div>
```

The `hidden` attribute is supported by most modern browsers and hides content both visually and from the accessibility tree. It can be easily toggled with JavaScript. Lastly, be cautious about hiding important content. If information is crucial for understanding or using the website, it should be visible and accessible to all users. Only hide content when doing so genuinely enhances the user experience. By following these best practices, you can ensure that your content remains accessible to all users, regardless of how they interact with your website.


## Module: Css Positioning


### Lecture Block: Lecture Understanding How To Work With Floats And Positioning In Css


## What Are Common Use Cases for Using Floats, and How Do They Work?

### Description

Floats in CSS are a technique originally designed to allow text to wrap around an element, such as an image. Over time, however, developers found new ways to use floats, applying them to layout design in creative ways. While modern layout methods like Flexbox and Grid are now more commonly used, understanding floats is still important, especially when working with older code or needing to achieve specific layout effects.

When an element is floated, it's taken out of the normal document flow and pushed to the left or right of its container. The content that follows will wrap around the floated element, filling the remaining space. One classic use is wrapping text around images, where an image is floated to one side, and text wraps around it. This technique is still widely used, especially in articles and blogs where images need to be placed alongside text. Here is the code example:

```html
<body>
  <div class="container">
    <img src="https://via.placeholder.com/150" alt="Placeholder Image">
    <p> This is an example of text flowing around a floated image.</p>
  </div>
</body>
```

```css
.container {
  border: 1px solid black;
}

img {
  float: left;
  margin-right: 20px;
}
```

In the above example, the container doesn't wrap around the floated image. The image is out of the normal document flow, and the container collapsed to zero height because it doesn't "see" the floated children elements. 

Floats were also popular for creating multi-column layouts before Flexbox and Grid became widespread. By floating elements next to each other, developers could create columns that aligned horizontally. However, when using floats, it's important to handle the problem of collapsing parent elements when their child elements are floated. The clearfix technique solution is applied to the class container element to fix this issue.

```css
/* Clearfix CSS */
.container::after {
  content: "";  
  display: block;
  clear: both;
}
```

- `::after` is a pseudo-element that adds an invisible block after the content of the container.
- `content: ""` ensures the pseudo-element is present but doesn’t display any content.
- `display: block` makes the pseudo-element a block-level element.
- `clear: both` ensures the pseudo-element clears both sides of any floated elements above it.

The clearfix technique ensures the parent element wraps around its floated children properly. Clearfix forces the parent container to "see" the floated child elements by adding a clear property after the floated content.

While floats are no longer the go-to method for complex layouts due to more modern techniques like Flexbox and Grid, they still play an essential role in certain scenarios. Whether you're wrapping text around images or working on legacy projects, understanding how floats work and how to clear them properly is key to maintaining well-structured and responsive layouts.


## What Is Relative Positioning, and How Does This Differ from the Default Static Positioning?

### Description

In CSS, positioning allows us to control how elements are laid out on a page. Two common types of positioning are static positioning and relative positioning. By default, elements are statically positioned. This means they follow the normal flow of the document, one after another, from top to bottom, left to right. 

Static positioning is the default for all elements and doesn't need any special declaration in CSS. You won’t notice anything different when using static positioning because it just keeps elements where they naturally occur in the document. Here is an example of a paragraph using default static positioning:

```html
<p>This paragraph is statically positioned.</p>
```

When rendered in the browser, this paragraph will appear in its natural position, following the normal document flow. No special styling is applied to move it, and it remains where it would naturally appear in the layout.

Relative positioning, on the other hand, allows an element to be shifted from its normal position without disrupting the flow of the document. Think of it as moving the element from its default static position by giving it new coordinates. Here is how you might apply relative positioning:

```css
<head>
  <style>
    body {
      border: solid 1px black;
    }
    .relative {
      position: relative;
      top: 30px;
      left: 30px;
    }
  </style>
</head>
<body>
  <p class="relative">This paragraph is positioned relatively.</p>
</body>
```

In this example, the paragraph will appear `30px` down and `30px` to the right from its original position. However, the space it would have occupied in the normal flow remains preserved. Relative positioning is very useful when you want to move an element slightly without affecting the rest of the layout.


## What Is Absolute Positioning, and How Does It Work?

### Description

Absolute positioning allows you to take an element out of the normal document flow, making it behave independently from other elements. When an element is positioned absolutely, it is placed in its own layer, completely separate from everything else in the layout. This makes it useful for creating floating UI features such as modals, tooltips, or dropdown menus, which can overlap other elements on the page.

By default, absolutely positioned elements are placed relative to the closest positioned ancestor. If no positioned ancestor is found, the element will be positioned relative to the initial containing block, which is usually the browser's viewport. You can move the absolutely positioned element around using the `top`, `bottom`, `left`, and `right` properties to specify how far away it should be from the edges of its containing element.

For example, setting `top: 30px` and `left: 30px` will move the element `30px` away from the top and left edges of the containing block. Here's an example of how to apply absolute positioning to an element in CSS:

```css
<body style="background-color: #eeeeee;">
  <div class="positioned">Absolutely Positioned</div>
</body>
```

```css
.positioned {
  position: absolute;
  top: 30px;
  left: 30px;
  background-color: coral;
}
```

When this code is applied, the element will be removed from the normal document flow and placed `30px` away from the top and left of its containing block.

Absolute positioning can be especially helpful for creating elements that are meant to float over the rest of the content, like overlays or modal windows. However, since the element is removed from the document flow, it can also create gaps or cause other elements to collapse together if not handled properly.


## What Is Fixed and Sticky Positioning, and How Does It Differ from Absolute Positioning?

### Description

Fixed and sticky positioning are two important CSS positioning strategies, each offering distinct behaviors compared to absolute positioning. When an element is positioned with `position: fixed`, it is removed from the normal document flow and placed relative to the viewport, meaning it stays in the same position even when the user scrolls. This is often used for elements like headers or navigation bars that need to remain visible at all times. For example, if you want a heading to stay fixed at the top of the page, you can use the following code:

```css
h1 {
  position: fixed;
  top: 0;
  width: 500px;
  background: white;
  padding: 10px;
}
```

In this example, the `h1` element will stick to the top of the viewport, and even when the user scrolls, it will remain in place. This is especially useful for creating persistent UI elements, like sticky headers or always-visible navigation.

`position: sticky` behaves as a hybrid between relative and fixed positioning. Initially, the element behaves as though it's positioned relatively, staying within the flow of the document. However, once the user scrolls the element past a certain point, it "sticks" to the viewport (usually the top) and behaves as though it is fixed. This is great for creating elements like sticky navigation bars, which only become fixed once the user scrolls to a certain position. Here's how you can apply sticky positioning:

```css
.positioned {
  position: sticky;
  top: 30px;
  left: 30px;
}
```

In this example, the `.positioned` element will behave normally until the user scrolls it `30px` away from the top, at which point it will "stick" to the top of the viewport.

Here are some key differences between absolute, fixed and sticky positioning:

- Absolute positioning removes an element from the document flow and positions it relative to the nearest positioned ancestor, or the initial containing block if none exists. The element stays in that position regardless of scrolling.
- Fixed positioning also removes the element from the document flow but fixes it relative to the viewport, meaning it will stay visible in the same spot even as the page is scrolled.
- Sticky positioning keeps the element in the normal flow initially but allows it to stick in place after scrolling past a defined threshold.

These strategies allow you to create layouts that include floating elements, sticky headers, and more dynamic UI components, enhancing user experience by making important information always accessible.


## What Is the Z-Index Property, and How Does It Work to Control the Stacking of Positioned Elements?

### Description

The `z-index` property in CSS is used to control the vertical stacking order of positioned elements that overlap on the page. When multiple elements are stacked on top of each other, the `z-index` value determines which element appears on top. The higher the `z-index` value, the closer the element is to the viewer, while lower values place the element farther back in the stack.

However, the `z-index` only works on elements that are positioned, which means the element must have a position value other than `static`, such as `relative`, `absolute`, or `fixed`. The default `z-index` value is `auto`, which places the element in the default stacking order. Let's take a look at an example with three boxes:

```html
<div class="container">
  <div class="box1">Box 1</div>
  <div class="box2">Box 2</div>
  <div class="box3">Box 3</div>
</div>
```

Now, we can apply some styles to position the boxes to overlap on each other like this:

```css
.container {
  position: relative;
  width: 300px;
  height: 300px;
  border: 1px solid black;
}

.box1 {
  position: absolute;
  z-index: 1;
  background: lightcoral;
  top: 20px;
  left: 20px;
  width: 100px;
  height: 100px;
}

.box2 {
  position: absolute;
  z-index: 3;
  background: gold;
  top: 40px;
  left: 40px;
  width: 100px;
  height: 100px;
}

.box3 {
  position: absolute;
  z-index: 2;
  background: lightgreen;
  top: 60px;
  left: 60px;
  width: 100px;
  height: 100px;
}
```

For the container, the positioning will be set to `relative` and all of the boxes nested inside will be set to `absolute` positioning. Each box has a different value for the `z-index` which results in the boxes being layered on top of each other.

You can think of `z-index` as a way to create layers on a webpage, and elements with higher `z-index` values will be placed above those with lower values. This is especially useful for controlling how overlapping elements behave in complex layouts, such as modals, pop-ups, or tooltips.


## Module: Attribute Selectors


### Lecture Block: Lecture Working With Attribute Selectors


## What Is the Attribute Selector, and How Can It Be Used to Target Links with the href and title Attributes?

### Description

The attribute selector in CSS is a powerful tool that allows you to target HTML elements based on their attributes. This means you can apply styles to elements that have specific attributes or even certain values for those attributes. 

It's particularly useful when you want to style elements dynamically or when class names alone don't provide enough specificity.

For example, you can use the attribute selector to target all links that have an `href` attribute. This is especially handy when you want to apply a uniform style to all links on a page. 

Here's how you can use the attribute selector to target links with the `href` attribute:

```css
a[href] {
  color: blue;
  text-decoration: underline;
}
```

This CSS rule will apply a blue color and an underline to any link that includes an `href` attribute, ensuring that all clickable links are styled consistently.

But attribute selectors can be more specific. Suppose you want to target only the links that have a `title` attribute. The `title` attribute often provides additional information about the link, and you might want to style these links differently to indicate that they have extra information available. Here's how you can do it:

```css
a[title] {
  font-weight: bold;
  text-decoration: none;
}
```

This rule applies bold text and removes the underline from any link with a `title` attribute. It's a great way to visually differentiate these links from others on the page.

You can also combine attribute selectors to get even more precise. For example, if you want to style links that have both `href` and `title` attributes, you can do this:

```css
a[href][title] {
  color: green;
}
```

In this case, only links that contain both `href` and `title` attributes will be styled with green text. This level of control is what makes attribute selectors so powerful in CSS.

Another example for an attribute selector is to match a single value within a space-separated list of values in an attribute.

Here is an example of an anchor element with multiple classes:

```html
<a href="https://example.com" class="btn primary large">Visit Example Site</a>
```

To target this specific anchor element, you can use the following selector:

```css
a[class~="primary"] {
  color: red;
  font-weight: bold;
}
```

The `[attr~=value]` syntax is used here to target all anchor elements where the class attribute contains the word `"primary"`.

If you need to target an element where the attribute value is prefixed by a specific value, then you can use the `[attr^=value]` syntax. Here is an example:

```css
a[href^="https://"] {
  color: green;
  text-decoration: underline;
}
```

In this example, the `a[href^="https://"]` selector will target all anchor elements where the `href` attribute value starts with `"https://"`. 

To target elements where the attribute value ends with a specific value, you can use the `[attr$=value]` syntax. Here is an example:

```css
a[href$=".jpg"] {
  color: darkgreen;
  text-decoration: underline dotted;
}
```

In this example, the `a[href$=".jpg"]` selector will target all anchor elements where the `href` attribute value ends with `.jpg`. 

Using attribute selectors not only enhances the styling of your webpage but also improves accessibility by making interactive elements like links more distinguishable based on their attributes.


## How to Use the Attribute Selector to Target Elements with the lang and data-lang Attributes?

### Description

When building multilingual websites or handling custom data attributes, you often need to style elements based on the language they contain or specific data values. 

The `lang` and `data-lang` attributes are commonly used for these purposes, and the attribute selector in CSS allows you to apply styles based on these attributes effectively.

The `lang` attribute is used in HTML to specify the language of the content within an element. You might want to style elements differently based on the language they are written in, especially on a multilingual website. 

Here's an example of how you can use the attribute selector to target elements with a specific `lang` attribute:

```css
p[lang="en"] {
  font-style: italic;
}
```

This CSS rule applies italic styling to any paragraph element where the `lang` attribute is set to English (`en`). This could be useful for emphasizing English text in a document that includes multiple languages.

Similarly, you can use the attribute selector to target elements with a `data-lang` attribute. 

Custom data attributes like `data-lang` are commonly used to store additional information in elements, such as specifying the language used within a specific section of text. 

Here's how you can use CSS to target and style elements based on the `data-lang` attribute:

```css
div[data-lang="fr"] {
  color: blue;
}
```

In this case, any `div` element with a `data-lang` attribute set to French (`fr`) will have its text color changed to blue. This allows you to quickly identify and style sections of content based on the language information stored in the `data-lang` attribute.

Attribute selectors like these provide a powerful way to apply conditional styling based on the metadata embedded within your HTML, making your web pages more dynamic and context-aware.


## How to Use the Attribute Selector to Target Ordered List Elements with the type Attribute?

### Description

When working with ordered lists in HTML, the `type` attribute allows you to specify the style of numbering used, such as numerical, alphabetical, or Roman numerals. 

The `type` attribute can be set on an `ol` (ordered list) element to control the numbering format:

- `1` for numerical lists (such as 1, 2, 3, ...),

- `A` for uppercase alphabetical lists (such as A, B, C, ...),

- `a` for lowercase alphabetical lists (such as a, b, c, ...),

- `I` for uppercase Roman numerals (such as I, II, III, ...),

- `i` for lowercase Roman numerals (such as i, ii, iii, ...).

Here's how you can use the attribute selector to target an ordered list with a specific `type` attribute:

```css
ol[type="A"] {
  color: purple;
  font-weight: bold;
}
```

In this example, the CSS rule will apply purple text and bold font weight to any ordered list that uses uppercase alphabetical numbering, which is specified by `type="A"`.

Similarly, you can target ordered lists that use lowercase Roman numerals by selecting those with `type="i"`:

```css
ol[type="i"] {
  color: green;
}
```

This rule will change the text color to green for any ordered list that uses lowercase Roman numerals.

The ability to style ordered lists based on their `type` attribute gives you greater control over the appearance of lists in your document, allowing for customization based on how content is structured.


## Module: Responsive Design


### Lecture Block: Lecture Best Practices For Responsive Web Design


## What Is Responsive Web Design, and What Is Its Relationship to Tools Like CSS Grid and Flexbox?

### Description

Responsive web design is an approach to web development that aims to create websites that provide an optimal viewing and interaction experience across a wide range of devices, from desktop computers to mobile phones.

The core principle of responsive design is adaptability – the ability of a website to adjust its layout and content based on the screen size and capabilities of the device it's being viewed on.

Responsive design typically relies on three main components - fluid grids, flexible images, and media queries:

- Fluid grids use relative units like percentages instead of fixed units like pixels, allowing content to resize and reflow based on screen size.

- Flexible images are set to resize within their containing elements, ensuring they don't overflow their containers on smaller screens.

- And, media queries allow developers to apply different styles based on the characteristics of the device, primarily the viewport width. You will learn more about media queries in future lectures.

The relationship between responsive web design and tools like CSS Grid and Flexbox is symbiotic. While responsive design is a concept or approach, CSS Grid and Flexbox are practical tools that make implementing responsive designs much easier and more efficient.

In previous lectures you learned how to work with Flexbox and in future lectures you will learn how to work with CSS Grid. But for now, here is a brief introduction into CSS Grid.

CSS Grid, is a two-dimensional layout system that allows for more complex arrangements. It's excellent for creating overall page layouts as well as smaller component layouts.

Here's an example of how CSS Grid can be used responsively:

```css
.grid-container {
  display: grid;
  grid-template-columns: 1fr;
  gap: 20px;
}

@media (min-width: 768px) {
  .grid-container {
    grid-template-columns: 1fr 1fr;
  }
}

@media (min-width: 1024px) {
  .grid-container {
    grid-template-columns: 1fr 1fr 1fr;
  }
}
```

In this example, the grid starts with a single column on small screens, switches to two columns on medium-sized screens, and then to three columns on larger screens. This demonstrates how Grid can create responsive layouts that adapt to different screen sizes.

Both Flexbox and Grid offer significant advantages over older layout methods like floats or table-based layouts. They provide more flexibility and control, require less code, and are designed with responsiveness in mind. They allow developers to create complex, responsive layouts with relative ease, making them invaluable tools in implementing responsive web design.

It's worth noting that Flexbox and Grid are often used together in responsive designs. Flexbox is typically used for components and one-dimensional layouts, while Grid is used for overall page structure and two-dimensional layouts. The choice between them often depends on the specific layout needs of the design.

In addition to Flexbox and Grid, other CSS features play important roles in responsive design.

The `calc()` function, for instance, allows for mixing units and performing calculations, which can be very useful in creating flexible layouts.

Responsive images are another crucial aspect of responsive web design. The `srcset` attribute and `picture` element in HTML5 allow for serving different image files based on device capabilities, ensuring that users don't download unnecessarily large image files on devices with smaller screens or lower resolution.

In conclusion, responsive web design is an approach that aims to create websites that work well on any device.

While it's a design philosophy rather than a specific technology, it relies heavily on CSS features like media queries, and is greatly facilitated by modern layout tools like Flexbox and Grid. These tools provide the flexibility and control needed to create truly responsive designs, allowing websites to adapt seamlessly to the ever-growing variety of devices used to access the web.


## How Do Media Queries Work, and What Are Some Common Media Types and Features?

### Description

Media queries are a fundamental component of responsive web design, allowing developers to apply different styles based on the characteristics of the user's device or browser. They provide a way to tailor the presentation of content to a variety of devices without changing the content itself.

At its core, a media query consists of a media type and one or more expressions that check for specific conditions. If these conditions are true, the corresponding styles are applied. This mechanism allows for the creation of responsive designs that adapt to different screen sizes, resolutions, and device capabilities.

The basic syntax of a media query in CSS looks like this:

```css
@media mediatype and (feature: value) {
  /* CSS rules go here */
}
```

In this structure, mediatype specifies the type of media the query applies to, and the feature: value pair defines the condition that must be met for the styles to be applied.

Media types describe the general category of a device. Let's talk about the most commonly used media types:

- `all` is suitable for all devices. This is the default if no media type is specified.

- `print` is intended for paged material and documents viewed on a screen in print preview mode.

- `screen` is intended primarily for screens.

In the past, there were more media types. like `handheld` and `tv`, but most of these have been deprecated in favor of using features to more precisely target devices.

Media features describe specific characteristics of the user agent, output device, or environment. Let's talk about some of the most commonly used media features. The `width` and `height` refers to the viewport width and height, and are often used with `min-` or `max-` prefixes for range queries. Here is an example:

```css
@media screen and (min-width: 768px) {
  /* Styles for screens at least 768px wide */
}
```

`aspect-ratio` describes the ratio between the width and height of the viewport. Here is an example:

```css
@media screen and (aspect-ratio: 16/9) {
  /* Styles for screens with a 16:9 aspect ratio */
}
```

The `orientation` feature indicates whether the device is in landscape or portrait orientation. Here is an example:

```css
@media screen and (orientation: landscape) {
  /* Styles for landscape orientation */
}
```

The `resolution` feature describes the resolution of the output device in dots per inch (dpi) or dots per centimeter (dpcm). Here is an example:

```css
@media screen and (min-resolution: 300dpi) {
  /* Styles for high-resolution screens */
}
```

The `hover` feature tests whether the primary input mechanism can hover over elements. Here is an example:

```css
@media (hover: hover) {
  /* Styles for devices that support hover */
}
```

The `prefers-color-scheme` feature detects if the user has requested a light or dark color theme. Here is an example:

```css
@media (prefers-color-scheme: dark) {
  /* Styles for dark mode */
}
```

Media queries can also combine multiple conditions using logical operators. The `and` operator is used to combine multiple media features, while `not` and `only` can be used to negate or isolate media queries. Here's an example that combines multiple features:

```css
@media screen and (min-width: 768px) and (orientation: landscape) {
  /* Styles for landscape screens at least 768px wide */
}
```

It's also possible to target multiple queries in a comma-separated list, which functions like an "or" operator:

```css
@media screen and (min-width: 768px), print {
  /* Styles for screens at least 768px wide OR for print */
}
```

When working with media queries, it's important to consider the cascade. Media queries don't increase specificity – they just group conditional rules. The normal rules of the CSS cascade still apply within each media query.

In practice, media queries are often used to create responsive layouts. A common pattern is to define a base style for mobile devices and then use media queries to enhance the layout for larger screens:

```css
/* Base styles for mobile */
.container {
  width: 100%;
  padding: 15px;
}

/* Styles for tablets */
@media screen and (min-width: 768px) {
  .container {
    width: 750px;
    margin: 0 auto;
  }
}

/* Styles for desktops */
@media screen and (min-width: 1024px) {
  .container {
    width: 960px;
  }
}
```

This approach, known as "mobile-first" responsive design, ensures that the base styles are suitable for mobile devices, with enhancements added for larger screens.

In conclusion, media queries are a powerful tool in CSS that allow for the creation of responsive, adaptable web designs. By understanding how to use different media types and features, developers can create websites that provide optimal user experiences across a wide range of devices and preferences. As web technologies continue to evolve, staying updated with new media features can help in creating more nuanced and user-friendly responsive designs.


## What Are Media Breakpoints, and What Are Common Breakpoints in Modern Design?

### Description

Media breakpoints are specific points in a website's design where the layout and content adjust to accommodate different screen sizes. These breakpoints are crucial in responsive web design, allowing developers to create websites that look and function well across various devices, from mobile phones to large desktop monitors.

In CSS, media breakpoints are implemented using media queries. These queries allow you to apply different styles based on the characteristics of the device, most commonly the viewport width. For example, you might set a breakpoint at 768 pixels to differentiate between mobile and tablet layouts.

Here's a simple example of how a media query with a breakpoint might look in CSS:

```css
/* Styles for screens wider than 768px */
@media screen and (min-width: 768px) {
  body {
    font-size: 1.125rem;
  }
}
```

When the screen width is 768 pixels or larger, the font size increases to `1.125rem` which is 18 pixels. This demonstrates how breakpoints can be used to adjust the design for different screen sizes.

When it comes to choosing breakpoints, there's no one-size-fits-all solution. The appropriate breakpoints for your website will depend on your specific design and content. However, there are some common breakpoints that many designers use as starting points in modern web design.

A popular set of breakpoints corresponds to common device categories:

- Small devices (smartphones): up to 640px.

- Medium devices (tablets): 641px to 1024px.

- Large devices (desktops): 1025px and larger.

Some designers prefer a more granular approach, using breakpoints like:

- Extra small devices: up to 576px.

- Small devices: 577px to 768px.

- Medium devices: 769px to 992px.

- Large devices: 993px to 1200px.

- Extra large devices: 1201px and larger.

It's important to note that these are not strict rules, but rather common practices.

The trend in modern responsive design is moving towards a more fluid approach, where designs adapt smoothly across a wide range of screen sizes, rather than making dramatic changes at set breakpoints.

Here are some other common examples for breakpoints:

- Extra small device: under 576px.

- Small device: more than or equal to 576px.

- Medium device: more than or equal to 768px.

- Large device: more than or equal to 992px.

- Extra large device: more than or equal to 1200px.

- Extra extra large device: more than or equal to 1400px.

These breakpoints are widely used and can serve as a good starting point for many projects. However, it's crucial to remember that the best breakpoints for your project should be determined by your content and design, not by arbitrary numbers or device sizes.


## What Is the Mobile First Approach in Responsive Web Design?

### Description

The mobile-first approach is a design philosophy and development strategy in responsive web design that prioritizes creating websites for mobile devices before designing for larger screens. This approach has gained significant traction in recent years, becoming a cornerstone of modern web development practices.

At its core, the mobile-first approach involves designing and developing the mobile version of a website as the primary step. This version serves as the foundation, which is then progressively enhanced for larger screens and devices with more capabilities. This methodology stands in contrast to the traditional approach, where websites were initially designed for desktop computers and subsequently scaled down or modified to fit smaller screens.

The principle behind mobile-first design is to ensure that the most essential content and functionality are available and optimized for the smallest screens first. This forces designers and developers to focus on the core content and features, leading to a more streamlined and efficient user experience across all devices.

One of the primary drivers behind the adoption of the mobile-first approach is the dramatic shift in internet usage patterns. With mobile devices now accounting for over half of global web traffic, designing for mobile first ensures that websites cater to a large and growing user base.

This approach aligns with the current digital landscape where many users primarily access the internet through their smartphones.

Performance optimization is another crucial aspect of the mobile-first approach. Mobile devices often have less processing power and may be connected to slower networks compared to desktop computers.

By designing for mobile first, developers are encouraged to optimize performance from the outset. This focus on efficiency benefits not only mobile users but also translates to improved performance across all devices. The limited screen space on mobile devices necessitates careful content prioritization.

Designers must make critical decisions about what content is absolutely essential and how to present it effectively on a small screen. This constraint often results in a more focused and user-friendly experience, which can then be expanded upon for larger screens without losing the core essence of the content.

Implementing a mobile-first approach typically involves using CSS media queries to progressively enhance the design for larger screens. Here's an example of how this might look in practice:

```css
/* Base styles for mobile */
body {
  font-size: 16px;
}

.container {
  width: 100%;
  padding: 10px;
}

/* Styles for larger screens */
@media screen and (min-width: 768px) {
  body {
    font-size: 18px;
  }

  .container {
    width: 750px;
    margin: 0 auto;
    padding: 20px;
  }
}

@media screen and (min-width: 1024px) {
  .container {
    width: 960px;
  }
}
```

In this example, we start with base styles suitable for mobile devices. We then use media queries with `min-width` to add or modify styles for larger screens. This exemplifies the essence of mobile-first design in CSS: beginning with styles for the smallest screens and then progressively enhancing for larger ones.

The mobile-first approach also aligns well with search engine optimization (SEO) strategies. Google, for instance, uses mobile-first indexing, meaning it predominantly uses the mobile version of the content for indexing and ranking.

By prioritizing the mobile experience, websites can potentially improve their search engine rankings and visibility. While the mobile-first approach offers numerous benefits, it's not without challenges. Designing for mobile first can sometimes constrain creativity for larger screens, and it may be difficult to conceptualize complex features on mobile devices initially.

Additionally, convincing stakeholders to prioritize mobile design can be challenging, especially if they're accustomed to seeing desktop designs first.

Despite these challenges, the mobile-first approach remains a powerful strategy in responsive web design. It encourages efficiency, focuses on core content and functionality, and aligns with current user behavior.

As mobile internet usage continues to grow, the mobile-first approach is likely to remain a fundamental principle in creating effective, user-friendly websites that perform well across all devices.


## Module: Css Variables


### Lecture Block: Lecture Working With Css Variables


## What Are CSS Custom Properties, and How Do They Work?

### Description

CSS custom properties, also known as CSS variables, are entities defined by CSS authors that contain specific values to be reused throughout a document. They are a powerful feature that allows for more efficient, maintainable, and flexible stylesheets.

The syntax for declaring a custom property is straightforward. It begins with two dashes (`--`) followed by the property name:

```css
:root {
  --main-color: #3498db;
}
```

In this example, we're declaring a custom property named `--main-color` with a value of `#3498db`. The `:root` pseudo-class is commonly used to declare global custom properties, as it represents the highest-level parent in the DOM tree.

To use a custom property, you employ the `var()` function:

```css
.button {
  background-color: var(--main-color);
}
```

This sets the background color of elements with the class `button` to the value stored in `--main-color`.

One of the key features of custom properties is that they follow the CSS cascade. This means that you can redefine them for specific elements or contexts:

```css
.alert {
  --main-color: #e74c3c;
  background-color: var(--main-color);
}
```

In this case, elements with the class `alert` will use a different `--main-color` value, overriding the global definition.

Custom properties also support fallback values. If a custom property is not defined or is invalid, you can provide a fallback value:

```css
.text {
  color: var(--text-color, black);
}
```

Here, if `--text-color` is not defined, the `color` will default to `black`.

Custom properties are particularly useful in creating themeable designs. You can define a set of properties for different themes:

```css
:root {
  --bg-color: white;
  --text-color: black;
}

.dark-theme {
  --bg-color: #333;
  --text-color: white;
}

body {
  background-color: var(--bg-color);
  color: var(--text-color);
}
```

Switching themes becomes as simple as adding or removing a class from the `body` element.

Custom properties can also be used with media queries to create responsive designs:

```css
:root {
  --container-width: 100%;
}

@media (min-width: 768px) {
  :root {
    --container-width: 750px;
  }
}

.container {
  width: var(--container-width);
}
```

This approach allows for more maintainable responsive layouts, as you can change values in one place rather than throughout your stylesheet. This can significantly reduce repetition in your stylesheets, especially for frequently used, complex values.

Custom properties can also reference other custom properties:

```css
:root {
  --primary-color: #3498db;
  --button-bg: var(--primary-color);
}
```

This allows for creating relationships between different style aspects, making it easier to maintain consistent themes across your site.

While custom properties offer many advantages, it's important to be aware of their browser support. They are well-supported in modern browsers, but older browsers may not recognize them. Always have a fallback plan when using cutting-edge features.

In conclusion, CSS custom properties provide a powerful way to create more dynamic, flexible, and maintainable stylesheets. They allow for the creation of themeable designs, simplify responsive layouts, and enable runtime manipulation of styles. 

As web development continues to evolve, custom properties are becoming an increasingly important tool in a developer's toolkit, offering new possibilities for creating adaptable and efficient CSS.


## What Is the @property Rule, and How Does It Work with Fallbacks?

### Description

The `@property` rule is a powerful CSS feature that allows developers to define custom properties with greater control over their behavior, including how they animate and their initial values. 

This rule provides a way to enhance the functionality of CSS custom properties and offers more flexibility in their application.

The basic syntax of the `@property` rule is as follows:

```css
@property --property-name {
  syntax: '<type>';
  inherits: true | false;
  initial-value: <value>;
}
```

The `--property-name` is the name of the custom property you're defining. Like all custom properties, it must start with two dashes. `--property-name` can be things like `<color>`, `<length>`, `<number>`, `<percentage>`, or more complex types.

`syntax` defines the type of the property. 

`inherits` specifies whether the property should inherit its value from its parent element. 

`initial-value` sets the default value of the property.

Here's a practical example of using the `@property` rule:

```css
@property --main-color {
  syntax: '<color>';
  inherits: false;
  initial-value: #3498db;
}

.button {
  background-color: var(--main-color);
}
```

In this example, we're defining a custom property `--main-color` as a `color` value, setting it to not inherit, and giving it an initial value of `#3498db`.

One of the key benefits of the `@property` rule is that it allows for animation of custom properties, which wasn't possible before:

```css
@property --gradient-angle {
  syntax: '<angle>';
  inherits: false;
  initial-value: 0deg;
}

.gradient-box {
  width: 100px;
  height: 100px;
  background: linear-gradient(var(--gradient-angle), red, blue);
  transition: --gradient-angle 0.5s;
}

.gradient-box:hover {
  --gradient-angle: 90deg;
}
```

The code above creates a gradient that smoothly animates when the element is hovered over, something that wasn't achievable with standard custom properties.

Now, let's discuss how the `@property` rule works with fallbacks. 

Fallbacks are crucial in CSS to ensure that styles degrade gracefully in browsers that don't support certain features. With the `@property`, fallbacks work on two levels: for the rule itself and for the use of the custom property.

For browsers that don't support the `@property` rule, you can provide a fallback by declaring the custom property in the traditional way:

```css
:root {
  --main-color: #3498db;
}

@property --main-color {
  syntax: '<color>';
  inherits: false;
  initial-value: #3498db;
}
```

In this case, browsers that support `@property` will use the more strictly defined version, while others will fall back to the standard custom property declaration.

When using the custom property, you can provide a fallback value using the `var()` function, just as you would with standard custom properties:

```css
.button {
  background-color: var(--main-color, #3498db);
}
```

This ensures that even if the `--main-color` property is not defined or is invalid, the button will still have a background color.

The `@property` rule also allows for more complex fallback scenarios. For instance, you can use it to provide type-safe fallbacks:

```css
@property --padding {
  syntax: '<length>';
  inherits: false;
  initial-value: 10px;
}

.box {
  padding: var(--padding);
}
```

In this case, if someone tries to set `--padding` to an invalid value, like a color, the browser will fall back to the initial value of `10px`, maintaining type safety.

It's worth noting that the `@property` rule itself is not yet universally supported. As of mid-2023, it's supported in Chrome, Edge, and Opera, with Firefox support behind a flag. For broader browser support, it's important to provide fallbacks and use feature detection.

In conclusion, the `@property` rule represents a significant advancement in how we work with custom properties in CSS. It provides more control and enables new possibilities like animation of custom properties. However, it's important to use it judiciously and always provide appropriate fallbacks to ensure a good experience across all browsers. As with any cutting-edge web technology, the key is to enhance the experience for browsers that support it while ensuring basic functionality for those that don't.


## Module: Css Grid


### Lecture Block: Lecture Working With Css Grid


## What Is CSS Grid, and How Does It Differ from Flexbox?

### Description

CSS Grid is a powerful layout system that allows web developers to create complex and responsive web page layouts with ease.

Imagine you're arranging furniture in a room – CSS Grid is like having an invisible grid on your floor that helps you position everything precisely where you want it.

When we build websites, we often need to arrange different elements on the page.

Before CSS Grid, this was sometimes tricky, especially for complex layouts. CSS Grid simplifies this process by dividing your web page into rows and columns, creating a grid-like structure.

Let's imagine you were working with a container `div` with several items nested inside like this:

```html
<div class="container">
  <div class="item">Item 1</div>
  <div class="item">Item 2</div>
  <div class="item">Item 3</div>
  <div class="item">Item 4</div>
  <div class="item">Item 5</div>
  <div class="item">Item 6</div>
</div>
```

If you wanted to style those elements in a grid format, you can set the `display` to `grid` and apply columns like this:

```css
.container {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  grid-gap: 20px;
}

.item {
  background-color: lightgray;
  padding: 20px;
  text-align: center;
  border: 1px solid #ccc;
}
```

In this code, we're telling the browser to create a grid with three equal-width columns, that's what the `1fr 1fr 1fr` means, and we're adding a 20-pixel gap between each grid item.

Now, you might be wondering: "What about Flexbox? Isn't that also used for layouts?"

You're right! Flexbox is another CSS layout model, and it's quite useful too. But there are some key differences.

Flexbox is one-dimensional, while Grid is two-dimensional. This means Flexbox works great for laying things out in a single row or column, while Grid excels at creating layouts with both rows and columns.

Flexbox is content-first, meaning it adjusts the layout based on the content. Grid, on the other hand, is layout-first, allowing you to create the layout and then place items into it. Grid gives you more precise control over placement. You can tell an item exactly which row and column to occupy.

Here's a Flexbox example for comparison:

```css
.container {
  display: flex;
  justify-content: space-between;
}
```

This creates a flex container where the items are spaced evenly along the main axis.

Both Grid and Flexbox have their strengths, and often, the best layouts use a combination of both. You might use Grid for the overall page layout, and then use Flexbox for aligning items within each grid area.

In summary, CSS Grid is a powerful tool that allows for precise, two-dimensional layouts. While it might seem complex at first, with practice, it becomes an invaluable tool for creating responsive and complex web layouts.


## How Can You Create Flexible Grids with the fr Unit?

### Description

In the previous lecture, you were introduced to CSS grid which can be used to create complex and fluid layouts in your web pages. In this lecture, we will explore how to create flexible grid layouts using the `fr` unit.

Let's start with this HTML markup which is going to represent our grid container:

```html
<div class="grid-container">
  <div class="col"></div>
  <div class="col"></div>
  <div class="col"></div>
  <div class="col"></div>
</div>
```

Inside the CSS, we set the display property to grid for the container.

```css
html,
body {
  width: 100%;
  height: 100%;
}

.grid-container {
  display: grid;
  grid-template-columns: 25% 25% 25% 25%;
  gap: 15px;
  background-color: darkgray;
  height: 100%;
}

.col {
  background-color: darkslateblue;
}
```

`grid-template-columns` is used to set the size for each column. In this case, each column size will be `25%` of the container. Then the gap property is used to create space around each column.

So far we have been using percentages for the column size but we can also use the `fr` unit.

The `fr` unit is a fractional unit which represents a fraction of the space for the grid container.

Here is what the code will look like when it is refactored to use `fr` units instead of percentages.

```css
html,
body {
  width: 100%;
  height: 100%;
}

.grid-container {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr;
  gap: 15px;
  background-color: darkgray;
  height: 100%;
}

.col {
  background-color: darkslateblue;
}
```

Each column will take up one fraction of the available space. Since there are four columns, each column will have an equal share of the space available in the grid container.

As you start to build your grid layouts, you will find yourself wanting to use `fr` units more often because they provide a flexible, proportional way to distribute space, allowing you to create responsive layouts that adapt to varying screen sizes without needing to manually adjust pixel values.


## How Can You Create Gaps Between Tracks in a Grid?

### Description

In the previous lectures, we talked a little bit about how to create space between grid items. But in this lecture, we will dive into more detail about how to use the `row-gap`, `column-gap` and `gap` properties in a grid layout.

But first we need to review what a track is in CSS grid. A track is the space between two neighboring grid lines. These lines are automatically created when you use CSS Grid. In this context, tracks generally refer to the rows and columns that make up the grid layout.

To create gaps between columns in a CSS Grid, you can use the `column-gap` property. Acceptable values for this property include pixels, the `em` unit, percentages, or the `normal` keyword.

If you use the `normal` value for the `column-gap` property, then the result will be `0` for grid layouts and `1em` for multi-column layouts.

Here is an example of the markup for a four column grid layout:

```html
<div class="grid-container">
  <div></div>
  <div></div>
  <div></div>
  <div></div>
</div>
```

For the CSS, we set the display to grid and the `column-gap` property to 10 pixels:

```css
.grid-container {
  display: grid;
  height: 100px;
  grid-template-columns: 1fr 1fr 1fr 1fr;
  column-gap: 10px;
}

.grid-container div {
  background-color: darkblue;
}
```

If we wanted to change the example to have two rows of blue boxes and create more space between the rows, we can use the `row-gap` property:

```css
.grid-container {
  display: grid;
  grid-template-columns: 1fr 1fr;
  column-gap: 10px;
  row-gap: 30px;
}

.grid-container div {
  height: 100px;
  background-color: darkblue;
}
```

In this revised example, we are setting the `row-gap` property to 30 pixels and changing the `grid-template-columns` to use just two `1fr` units instead of four to create two rows of boxes.

Just like the `column-gap` property, acceptable values for the `row-gap` property can include percentages, `em`, and pixels.

If you want to use a shorthand for creating gaps between rows and columns, you can use the `gap` property. Here is the basic syntax:

```css
gap: row-value optional-column-value;
```

If you specify one value for the `gap` property, then that value will be applied to both rows and columns. If you specify two values, then the first value will go to the row and the second will be applied to the column:

```css
.grid-container {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 30px 10px;
}

.grid-container div {
  height: 100px;
  background-color: darkblue;
}
```

Acceptable values for the `gap` shorthand property include percentages, pixels, `em` and even `calc()` values. But you cannot use `fr` units here.

The `row-gap`, `column-gap`, and `gap` properties provide flexible ways to control spacing between items in a CSS Grid layout. By using these properties, you can easily create visually appealing grids with consistent and adjustable gaps between rows and columns.


## How Can You Repeat Track Listings in a Grid Layout?

### Description

In the previous lectures, we have been working with the `grid-template-columns` property and setting the value to a few fractional units.

```css
.grid-container {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr;
  column-gap: 10px;
}
```

While the following code is completely valid, there is an easier way to repeat a section or all of your track listings.

The `repeat()` function is used to repeat a section or all of the tracks for columns or rows. This function takes in a repeat count and the tracks you wish to repeat.

Here is a revised version of the earlier example using the repeat function:

```css
.grid-container {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  column-gap: 10px;
}
```

There won't be a change for the styles in the browser, but this is a more concise way to write repeated values for the columns.

The `repeat()` function will accept any valid pattern that you can use for rows or columns.

In this example, we have HTML markup for a grid container:

```html
<div class="grid-container">
  <div class="box"></div>
  <div class="box"></div>
  <div class="box"></div>
  <div class="box"></div>
</div>
```

Then we are using the `repeat()` function to set the first and third columns to 20 pixels and the second and fourth columns to one fractional unit.

```css
.grid-container {
  display: grid;
  grid-template-columns: repeat(2, 20px 1fr);
  column-gap: 10px;
}

.grid-container div {
  height: 100px;
  background-color: darkblue;
}
```

Sometimes, you might opt to write out each individual value instead of using the `repeat()` function. But there are times when this function comes in handy, especially when you want to repeat a particular pattern for a track listing.


## What Is the Difference Between an Implicit and Explicit Grid?

### Description

Implicit grid refers to the rows and columns automatically created by the browser when placing items in a grid layout – those not explicitly defined using `grid-template-rows` or `grid-template-columns`.

The properties that control the columns and rows created implicitly by the browser are `grid-auto-columns` and `grid-auto-rows`.

Implicit grid also refers to the additional rows and columns the browser automatically generates when you place an item outside the explicitly defined rows and columns.

For instance, let's say you define only two explicit columns in a grid layout this way:

```css
.grid-container {
  display: grid;
  grid-template-columns: 100px 100px; /* Only 2 explicit columns */
}

.grid-item {
  background-color: burlywood;
  border: 1px solid orangered;
  padding: 0.5rem;
  margin: 0.5rem;
}
```

But you have six items in the grid container:

```html
<div class="grid-container">
  <div class="grid-item">Item 1</div>
  <div class="grid-item">Item 2</div>
  <div class="grid-item">Item 3</div>
  <div class="grid-item">Item 4</div>
  <div class="grid-item">Item 5</div>
  <div class="grid-item">Item 6</div>
</div>
```

What happened?

Two items filled the first row using the two explicit columns – `Item 1` in the first column and `Item 2` in the second column.

The next items start a new row with `Item 3` going in the first column of the second row and `Item 4` in the second column of the second row, and so on.

As you've already seen, explicit grids are the areas of the grid you intentionally set up. That is, the rows and columns you explicitly define for a grid layout using the `grid-template-rows` and `grid-template-columns` properties.

Here is a table summarizing the differences between implicit and explicit grids:

| **Feature**          | **Explicit Grid**                                                                  | **Implicit Grid**                                                                          |
|----------------------|------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------|
| **Size control**     | Fully customizable using  ` grid-template-rows `  and  ` grid-template-columns ` . | Controlled by  ` grid-auto-rows `  and  ` grid-auto-columns ` , or defaults to  ` auto ` . |
| **Default Behavior** | Does not change unless explicitly defined.                                         | Automatically adapts to items placed outside the explicit grid.                            |
| **Complexity**       | Requires more planning for layout structure.                                       | Easier to implement for unstructured or variable content.                                  |
| **Flexibility**      | Rigid structure with defined rows and columns.                                     | Flexible and adapts to dynamically placed content.                                         |
| **Performance**      | Potentially more performant as the layout is predefined.                           | May require additional browser computations for implicit grid generation.                  |
| **Use case**         | Useful when the grid structure is predictable and defined upfront.                 | Useful for dynamic layouts where content is unknown or changes frequently.                 |


## What Is the minmax() Function and How Does It Work?

### Description

The `minmax()` function defines the range for the size of a grid track, specifying how much space a row or column can occupy.

Remember that you can set the track size with units like `px` (pixels), `rem`, or even `em`, and with fractional units (`fr`).

The `minmax()` function takes things a bit further by allowing you to set a minimum size and a maximum size for the grid track.

Here's the syntax of the `minmax()` function:

```css
minmax(min, max)
```

`min` is the minimum size of the grid track, which can be set using pixels, percentage, or `auto`. And `max` is the maximum size of the grid track which you can set with the same units.

The two values work together this way:

- The `min` value ensures the grid track will never shrink below a set size.

- The `max` value limits how large the grid track can grow.

The grid track size adjusts dynamically between the `min` and `max` values based on content and container size.

Let's look at a practical example with this HTML:

```html
<div class="grid-container">
  <div>
    <h2>Item 1</h2>
  </div>
  <div>
    <h2>Item 2</h2>
  </div>
</div>
```

And the grid CSS:

```css
.grid-container {
  display: grid;
  grid-template-columns: minmax(150px, 300px) 1fr;
  gap: 20px;
}

.grid-container > div {
  background: crimson;
  padding: 20px;
  text-align: center;
}
```

What's happening here? 

The first `column, minmax(150px, 300px)`, will always be at least `150px` and at most `300px`, depending on the available space.

On the other other hand, the second column, `1fr`, will take up any available remaining space in the grid container since there are no additional columns to share the space with.

The advantage of the `minmax()` function over fixed sizes and even `fr` units is that it is more flexible, making it ideal for adaptability and responsiveness.


## How Do the grid-column and grid-row Properties Work?

### Description

The `grid-column` and `grid-row` properties let you specify the horizontal and vertical placement of grid items within a grid layout.

In other words, they both allow you to control where a grid item begins and ends by referencing grid lines. These grid lines are the boundaries that separate rows and columns you have already defined using the `grid-template-rows` and `grid-template-columns` properties.

Let's take a look at the syntaxes of both `grid-row` and `grid-column`, and also a practical example.

Here's the syntax of the `grid-row` property:

```css
grid-row: <start-line> / <end-line>;
```

And of `grid-column`:

```css
grid-column: <start-line> / <end-line>;
```

`<start-line>` is the grid line where the item starts and `<end-line>` is the grid line where the item ends. Both are 1-indexed, that is, you start counting them from 1, not 0.

Remember, grid lines for rows are generated based on the number of rows specified in the `grid-template-rows` property. The same applies to columns with the `grid-template-columns` property.

For the practical example, let's start with the lines generated by the browser when you use both the `grid-template-rows` and the `grid-template-columns` properties.

This is the HTML for that example:

```html
<div class="grid">
  <div class="item1">1</div>
  <div class="item2">2</div>
  <div class="item3">3</div>
  <div class="item4">4</div>
</div>
```

Here's the CSS with four equal columns and three equal rows:

```css
.grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr); /* 4 equal columns */
  grid-template-rows: repeat(3, 100px); /* 3 equal rows */
  gap: 10px;
}

.grid > div {
  display: grid;
  place-items: center;
  background: crimson;
  color: white;
  font-size: 4rem;
}
```

Inspecting the grid container (the class `grid`) shows that each row and column is bounded by two lines – a start line at the beginning of the row or column, and an end line at the end of the row or column.

You can target these lines to start using the `grid-row` and `grid-column` properties to determine where you should place an item.

Here's how you can make the first grid item occupy the first two columns:

```css
.item1 {
  grid-column: 1 / 3;
}
```

With this, you're saying the first grid item should start at column 1 and end just before column 3.

The first item will now occupy two columns, and the fourth item gets pushed to the second row. Cool!

If you also want the first item to occupy two rows, you can specify a `grid-row` of `1 / 3`:

```css
.item1 {
  grid-column: 1 / 3;
  grid-row: 1 / 3;
}
```

You can also use the `span` keyword to tell the grid item which row and column to span across. For example, `1 / 3` is the same as `1 / span 2`:

```css
.item1 {
  grid-column: 1 / span 2;
  grid-row: 1 / span 2;
}
```

You can continue to apply this technique to any item on the grid and place them wherever you want. 

Continuing the process, here's how we made a masonry layout with the items.

This is the new HTML with three additional items:

```html
<div class="grid">
  <div class="item1">1</div>
  <div class="item2">2</div>
  <div class="item3">3</div>
  <div class="item4">4</div>
  <div class="item5">5</div>
  <div class="item6">6</div>
  <div class="item7">7</div>
</div>
```

The new CSS:

```css
.grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr); /* 4 equal columns */
  grid-template-rows: repeat(4, 100px); /* 4 equal rows */
  gap: 10px;
}

.grid > div {
  display: grid;
  place-items: center;
  background: crimson;
  color: white;
  font-size: 4rem;
}

.item1 {
  grid-column: 1 / span 2;
}

.item4 {
  grid-column: 1 / span 3;
}

.item6 {
  grid-column: 1 / span 2;
}

.item7 {
  grid-column: 3 / span 2;
}
```


## How Can You Position Items on the Grid Using the grid-template-areas Property?

### Description

The `grid-template-areas` property lets you design a visual grid layout by using named labels.

You then assign the labels to specific grid items using the grid-area property. So, in other words, those named labels are also called "grid area names".

Here's the basic syntax of the `grid-template-areas` property:

```css
grid-template-areas:
 'header header header'
 'left-sidebar main right-sidebar'
 'footer footer footer';
```

Here are the points to take away from the basic syntax:

- Values like `header` and `main` are the names of the grid areas.

- Each space-separated value within a string corresponds to a column.

- Each string represents a row in the grid.

So, in the syntax, we have a 3 by 3 grid container.

After defining the template, you then have to use the `grid-area` property and the named labels (or areas) as values to tell CSS that a specific element belongs in that area of the grid.

The `grid-area` property connects the grid item to the named region you define in the `grid-template-areas`.

A popular way to demonstrate the capabilities of the `grid-template-areas` property is by creating the classic Holy Grail layout.

If you don't know what it is, the Holy Grail layout is a web design pattern with a header, footer, two sidebars, and a main content area. It ensures the main content takes priority, while sidebars and other sections adjust responsively within the layout.

Many solutions exist to implement the holy grail layout, but using `grid-template-areas` and the `grid-area` property is the most straightforward way to create it.

Here's the HTML for the holy grail layout:

```html
<div class="grid-container">
  <div class="header">
    <h2>Header</h2>
  </div>
  <div class="sidebar-left">
    <h2>Left Sidebar</h2>
  </div>
  <div class="main"><h2>Main Content</h2></div>
  <div class="sidebar-right">
    <h2>Right Sidebar</h2>
  </div>
  <div class="footer">
    <h2>Footer</h2>
  </div>
</div>
```

Please note that both the `grid-template-areas` and `grid-area` properties can be used independently of each other.

The `grid-template-areas` property is specifically used to define a visual layout by mapping out named grid areas within the grid container.

On the other hand, the `grid-area` property is used to position individual grid items, either by specifying their row and column positions or by referencing the named areas defined with the `grid-template-areas` property.


### Lecture Block: Lecture Debugging Css


## How Can You Use the DevTools Inspection Tool and CSS Validators to Debug Your CSS?

### Description

Developer tools, inspection tools, and CSS validators are essential resources for debugging CSS issues and ensuring your stylesheets are error-free and optimized.

These tools provide invaluable insights into how your CSS is being applied and can help identify potential problems.

Let's start with browser developer tools, commonly known as DevTools. Most modern browsers, including Chrome, Firefox, and Safari, come with built-in DevTools. To access them, you can right-click on an element on your webpage and select "Inspect" or use keyboard shortcuts like `F12` or `Cmd+Option+I` (on macOS).

DevTools allow you to inspect and modify your CSS in real-time. The Styles pane shows all the CSS rules applied to the selected element, including inherited styles.

You can toggle individual properties on and off, edit values, and even add new rules directly in the browser. This immediate feedback is incredibly useful for experimenting with different styles without modifying your source code.

The inspection tool, which is part of DevTools, allows you to hover over elements on your page and see their box model, including margins, borders, padding, and content area. This is particularly useful for diagnosing layout issues or understanding why elements are positioned in a certain way.

CSS validators are another important tool for debugging. The W3C CSS Validator is a popular choice. It checks your CSS against the official specifications and reports any errors or warnings. To use it, you can either upload your CSS file, input your CSS directly, or provide a URL to validate.

For example, let's say you are working with the following CSS:

```css
.container {
  width: 100%;
  height: 200px
  background-color: #F0F0F0;
}
```

The validator would point out that there's a missing semicolon after the `height` property. This kind of error can be easy to overlook but can cause significant issues in your stylesheet.

When debugging responsive designs, the device emulation feature in DevTools is invaluable. It allows you to simulate how your site looks on various screen sizes and devices. This can help you identify breakpoint issues or styles that don't scale well across different viewport sizes.

Remember, effective CSS debugging often involves a combination of these tools. You might start by using a validator to catch any syntax errors, then use DevTools to inspect specific elements and experiment with changes. The device emulation tool can then help ensure your styles work across different screen sizes.

By mastering these tools, you can significantly speed up your CSS debugging process and create more robust, error-free stylesheets.

Regular use of these debugging techniques will not only help you solve immediate issues but also improve your overall understanding of CSS and how it interacts with your HTML.


## Module: Css Animations


### Lecture Block: Lecture Animations And Accessibility


## What Are CSS Animations, and How Do They Work?

### Description

CSS animations allow you to create dynamic, visually engaging effects on web pages without the need for JavaScript or complex programming. They provide a way to smoothly transition elements between different styles over a specified duration.

At its core, a CSS animation consists of two main components: the `@keyframes` rule and the animation property.

The `@keyframes` rule defines the stages and styles of the animation. It specifies what styles the element should have at various points during the animation. 

Here's an example:

```css
@keyframes slide-in {
  0% {
    transform: translateX(-100%);
  }
  100% {
    transform: translateX(0);
  }
}
```

This `@keyframes` rule, named `slide-in`, defines an animation that moves an element from left to right. The percentages represent the progress of the animation, with `0%` being the start and `100%` being the end.

The `translateX` function in your `@keyframes` animation is controlling the horizontal position of an element as it animates into view.

To apply this animation to an element, you use the `animation` property:

```css
.sliding-element {
  animation: slide-in 2s ease-out;
}
```

This applies the `slide-in` animation to the element with a duration of 2 seconds and an `ease-out` timing function.

The `animation` property is actually a shorthand for several individual properties:

`animation-name` which specifies the `@keyframes` rule to use.

`animation-duration` which sets how long the animation should take to complete.

`animation-timing-function` which defines how the animation progresses over time - such as `ease`, `linear`, `ease-in-out`.

`animation-delay` which specifies a delay before the animation starts.

`animation-iteration-count` which sets how many times the animation should repeat.

`animation-direction` which determines whether the animation should play forwards, backwards, or alternate.

`animation-fill-mode` which specifies how the element should be styled before and after the animation.

`animation-play-state` which allows you to pause and resume the animation.

You can use these properties individually for more precise control:

```css
.complex-animation {
  animation-name: color-change;
  animation-duration: 3s;
  animation-timing-function: linear;
  animation-delay: 1s;
  animation-iteration-count: infinite;
  animation-direction: alternate;
}

@keyframes color-change {
  0% {
    background-color: red;
  }
  50% {
    background-color: blue;
  }
  100% {
    background-color: green;
  }
}
```

This creates an animation that continuously transitions an element's background color between red, blue, and green.

CSS animations can be triggered by various events, such as hovering over an element:

```css
.button {
  background-color: blue;
  transition: background-color 0.3s;
}

.button:hover {
  background-color: red;
}
```

While this example uses the `transition` property, which is simpler for basic effects, it demonstrates how CSS can create interactive, animated elements.

It's important to note that while CSS animations are powerful, they should be used in moderation. Overuse of animations can lead to poor performance and may be distracting or problematic for users with certain accessibility needs. Always consider providing options to reduce or disable animations for users who prefer less motion.

CSS animations offer a way to create engaging, interactive web experiences without relying on JavaScript. By understanding the principles of `@keyframes` and `animation` properties, you can bring your web designs to life in a performant and accessible manner.


## What Are Accessibility Concerns Around Using Animations, and How Can prefers-reduced-motion Help?

### Description

Animations can greatly enhance the visual appeal and user experience of a website. However, they can also pose significant accessibility challenges for certain users. It's crucial to understand these concerns and implement solutions to ensure your website remains accessible to all users.

One of the primary accessibility concerns with animations is that they can cause discomfort or even physical harm to some users. People with vestibular disorders or motion sensitivity may experience dizziness, nausea, or headaches when exposed to certain types of movement on screen.

Additionally, animations can be distracting for users with cognitive disabilities or attention disorders. Rapid flashing or strobing effects are particularly problematic. They can trigger seizures in people with photosensitive epilepsy. As a general rule, avoid any content that flashes more than three times per second.

Another issue is that animations can make it difficult for some users to focus on or read content. This is especially true for users with low vision or reading difficulties who may struggle to track moving text or shifting layouts.

To address these concerns, CSS provides the `prefers-reduced-motion` media query. This feature allows web developers to detect if the user has requested minimal animations or motion effects at the system level.

Here's how you can use `prefers-reduced-motion`:

```css
@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    scroll-behavior: auto !important;
  }
}
```

This CSS code snippet effectively disables most animations and transitions for users who have indicated a preference for reduced motion. Let's break it down:

The `@media` query rule checks if the user prefers reduced motion. If true, it applies the enclosed styles.

Inside the media query, we're targeting all elements (`*`) and overriding animation and transition properties.

We set `animation-duration` and `transition-duration` to an extremely small value (`0.01ms`). This essentially turns off the animations while still allowing them to complete, which can be important for certain functionality.

`animation-iteration-count: 1` ensures that any looping animations only play once.

`scroll-behavior: auto` disables smooth scrolling effects.

The `!important` declaration is used to ensure these rules take precedence over other animation styles.

It's important to note that while this method effectively reduces motion, it's a blanket approach. For more precise control, you might want to define specific reduced-motion alternatives for your animations.

Here's an example of a more targeted approach:

```css
.animated-element {
  transition: transform 0.3s ease-in-out;
}

@media (prefers-reduced-motion: reduce) {
  .animated-element {
    transition: none;
  }
}
```

In this case, we're only disabling the `transition` for a specific element when reduced motion is preferred. This allows you to provide alternative, less motion-intensive experiences for users who need them.

Remember, the goal is not to completely remove all motion from your site, but to provide options that allow all users to comfortably interact with your content. Some motion can still be beneficial for usability and feedback, even for users who prefer reduced motion.

When implementing animations, consider using them thoughtfully rather than just for decoration. Avoid large, unexpected movements and provide controls to pause, stop, or hide animations when possible. Importantly, use the `prefers-reduced-motion` query to offer a low-motion alternative, ensuring your content remains accessible and comfortable for all users, including those sensitive to motion.

By being mindful of these accessibility concerns and utilizing tools like `prefers-reduced-motion`, you can create engaging, animated experiences that are inclusive and accessible to all users.


## Module: Review Css


# Chapter: Javascript


## Module: Code Editors


### Lecture Block: Lecture Working With Code Editors And Ides


## What Is a Code Editor and IDE?

### Description

You might think these are the same thing, but not quite. A code editor is any application that allows you to edit code files. An IDE, or Integrated Development Environment, is a full application that allows you to compile, run, and debug your code while you edit it.

Perhaps some examples might be helpful.

First, let's consider a few popular IDEs. Visual Studio is an integrated development environment by Microsoft that provides a comprehensive suite of tools for building, debugging, and deploying applications across various platforms.

Another IDE is XCode. Xcode is an integrated development environment by Apple designed for creating, coding, and debugging applications for macOS, iOS, watchOS, and tvOS.

And another IDE would be Android Studio. Android Studio is an integrated development environment by Google specifically designed for building, debugging, and testing Android applications.

Those are just a few examples of IDEs. Now, let's take a look at a few popular code editors.

Visual Studio Code is a lightweight, open-source code editor by Microsoft that supports a wide range of programming languages and provides features like debugging, syntax highlighting, and version control through extensions.

Another popular editor would be Sublime Text. Sublime Text is a fast, versatile text editor known for its sleek interface, powerful features, and support for a wide range of programming languages through customizable syntax highlighting and plugins.

And another one is Notepad++. This is a free, open-source, text and source code editor for Windows that offers syntax highlighting, code folding, and a range of plugins to enhance productivity and customization.

You may have noticed how the code editors focus primarily on the text contents of the file, where the IDEs expose various tools to manage your code.

These examples are all local programs you can run on your computer, but there are also cloud-based editors that you can use.

A cloud-based editor is an online tool that allows users to write, edit, and manage code or text directly through a web browser without needing to install software locally.

Let's take a look at a few cloud-based editors.

Replit is an online platform that provides a collaborative environment for coding, allowing users to write, run, and share code in various programming languages directly from a web browser.

Another popular cloud-based editor is GitHub Codespaces. This is a cloud-based development environment that provides instant access to a fully-configured code editor and development tools directly from GitHub, enabling seamless coding and collaboration.

And another one is Gitpod. Gitpod is a cloud-based development environment that integrates with GitHub and GitLab, offering instant, customizable workspaces for coding, building, and debugging directly from your browser.

And there are many more options. Some options, such as Visual Studio Code, are highly extensible and can work with multiple different project types and languages. Other options might be specifically tailored to a small subset of languages or project types.

The application you use might be different for specific projects. You should explore the options to see what will work best for your needs.


## How to Install Visual Studio Code onto Your Computer

### Description

To install VS Code, you'll want to visit their website to get the appropriate installer for your operating system. Make sure you visit the VS Code website, and not the Visual Studio website.

For Windows, you can download an EXE installer. Once you've downloaded it, run the file and the setup wizard will take you through the installation process.

For Mac, you can download a zip archive which contains a `.app` that you can run. You can also install VS Code via homebrew.

Open up the Terminal app on your Mac and run the following command:

```sh
brew install --cask visual-studio-code
```

On Linux, you can download a `.deb` or `.rpm` file directly. Once you have it installed, you can use the appropriate executable, or CLI command (typically `code`), to launch the application. And now you're ready to code.


## How to Create a Project and Run Your Code Locally in VS Code

### Description

To get started, you should know that VS Code considers projects to be "workspaces". The workspace is whichever directory you opened in VS Code.

To begin, you will need to use a command line interface to create a new directory for your new project. A directory is another name for the folder.

Command-line interfaces, or CLI for short, allow you to interact with your operating system through text-based commands. You will learn more about these tools in future lectures.

If you are on Windows, you can use the Command Prompt or PowerShell. If you are on a Mac, you can open up your Terminal app.

Once the command line is open, navigate to the home directory by typing in the `cd ~` command and hitting `enter` on your keyboard. Then type in the `mkdir my-project` command and hit `enter`. `mkdir`, or "make directory" is the command used to create a new directory. You should then open your new directory with VS Code. 

There are also some other graphical ways to create a new directory.

Depending on your operating system, you might have a context menu (or right-click option) to open VS Code directly from your file explorer. You could also choose to double-click on the VS Code application. If you feel comfortable with the command line you can run the command `code /path/to/folder`.

Once it's open, you should see a new blank workspace.

To create a new file, click on the `File` menu at the top-left corner and select `New File...`. Then name your file `index.html` and click on `Save`.

Now you should see your new file in the explorer tab. Try adding some HTML to your `index.html` file.

Now you might be tempted to open the HTML file in your browser directly. While that can work, it can also lead to all sorts of unexpected bugs, such as CSS not loading properly.

Instead, you should put your HTML file behind a proper web server. That can sound like an intimidating task if you are new to coding, but there's actually a way to do this right from VS Code.

You'll need to grab the _Live Server_ extension first, which is available for free in the marketplace.

Click on the extensions tab in the left hand corner and type in `Live Server` in the search bar.

Once you have this installed, you should see a `Go live` button in your status bar. Make sure you have your HTML file open, and then click it.

Your new page should open automatically in a new tab in the browser. If it doesn't then you can go directly to `http://localhost:5500/`

Congratulations! You've now set up your very own project in VS Code, and can view your changes with live server.


## What Are Several Useful Keyboard Shortcuts for Maximizing Productivity in VS Code?

### Description

You're likely already familiar with some of the basic shortcuts, which are inherited from your operating system. Shortcuts like `Ctrl + S` to save, `Ctrl + C` to copy, and `Ctrl + V` to paste all work in VS Code.

But there's a few that are application specific and can still level up your productivity. It's worth noting that some of these shortcuts may differ by operating system.

For example, `Shift + Alt + F` will run your configured formatter (such as prettier, for a JavaScript project) on the currently opened file.

Or `Ctrl + Shift + F` (Windows), or `Cmd + Shift + F` (Mac), to search the text contents of all the files in your workspace. Then `Ctrl + Shift + H` (Windows), or `Cmd + Shift + H` (Mac), if you want to run a find-and-replace.

If you need to remove a line, `Ctrl + Shift + K` (Windows), or `Cmd + Shift + K` (Mac), will delete it.

Need some extra room for all your code? `Ctrl + B` (Windows), or `Cmd + B` (Mac), will hide the sidebar - which has the file list and extensions menu.

Or maybe you just can't see your code? `Ctrl + plus` (Windows), or `Cmd + plus` (Mac), will increase the scaling of the editor, and `Ctrl + minus` (Windows), or `Cmd + minus` (Mac), will decrease it.

Finally, if you forget any of these shortcuts, you always have `Ctrl + Shift + P` (Windows), or `Cmd + Shift + P` (Mac), which opens the command palette for you to select whatever you may need.

With this knowledge, and maybe a little practice, you are well on your way to becoming a VS Code power user.


## What Are Some Good VS Code Extensions You Can Use in Your Editor?

### Description

_Better Comments_ is an extension that offers special highlighting for specific code comments. For example, it will call out "TODO" comments, as well as syntax to indicate questions or warnings.

_Code Spell Checker_ offers indication when you have spelled something incorrectly in your code. Because it is designed for code files, it will account for things like camel case.

_Error Lens_ will help you catch any highlighted errors in your code. Rather than having to rely on the underline that VS Code shows by default, this extension highlights the entire line and displays the error message.

_Indent Rainbow_ adds color to your different levels of indentation. In combination with VS Code's native bracket pair colorization, this can dramatically help identify what scope your code is in.

Or maybe you're looking for something a bit more practical? Consider an AI assistant, like _GitHub Copilot_ or _Tabnine_, to offer you inline suggestions as you are writing your code.

An icon pack, such as _VS Code Great Icons_, can help make your file tree cleaner and easier to parse at a glance. And an extension like _Colorize_ can help you understand the values in your CSS properties.

You'll also want language-specific extensions for your projects. If you are using JavaScript, you will likely want _ESLint_ and _Prettier_ to lint and format your code. If you are using TypeScript, you might want _Pretty Typescript Errors_ for easier to read messages.

Finally, you can also have a bit of fun with your editor. _VS Code Pets_ offers configurable virtual pets to keep you company while you squash some bugs.

_Power Mode_ will create flashy effects when you achieve a high enough "combo" by writing more code.

_Discord Presence_ will let you show off what you're working on to all of your friends.

And there are so many more extensions out there. Feel free to explore the extension marketplace and see what works best for you.


## Module: Javascript Variables And Strings


### Lecture Block: Lecture Introduction To Javascript


## What Is JavaScript, and How Does It Work with HTML and CSS?

### Description

JavaScript is a powerful programming language that brings interactivity and dynamic behavior to websites.

While HTML and CSS are markup languages used to structure content and style elements on a page, JavaScript goes beyond those by enabling more complex functionality, such as handling user input, animating elements, and even building full web applications.

For example, when you click a button, submit a form, or hover over a menu, JavaScript determines how the page behaves.

Here's an example of how these three work together:

```html
<!DOCTYPE html>
<html>
<head>
  <style>
    h1 {
      color: green;
    }
  </style>
</head>
<body>
  <h1>Hello, World!</h1>
  <button onclick="alert('Button clicked!')">Click me</button>
</body>
</html>
```

In this example, HTML is used to define the content: a heading (an `h1` tag) and a button (the `button` tag).

CSS is used to apply styles to the heading, such as making the text green. JavaScript is used to display an alert message when the button is clicked.

To sum up, HTML provides structure, CSS adds styling, and JavaScript enables behavior, creating a complete and interactive web experience.


## What Is a Data Type, and What Are the Different Data Types in JavaScript?

### Description

In JavaScript, a data type refers to the kind of value a variable holds.

A variable is a named container that stores a value of a specific data type, allowing you to reference and manipulate it throughout your code. Data types help the program understand the kind of data it's working with, whether it's a number, text, or something else.

JavaScript has several basic data types that you'll use in your programs. We'll explore each data type in greater detail in future lectures. For now, here is a brief introduction of the different data types in JavaScript.

The first data type we will look at is the `Number` type.

A `Number` represents both integers and floating-point values. Examples of integers include `7`, `19`, and `90`. Examples of floating point numbers include `3.14` and `5.2`. A floating point number is a number with a decimal point.

The next data type is a `String`.

A `String` is a sequence of characters, or text, enclosed in quotes. Here are two examples:

```js
"Hello, world"
```

```js
'JavaScript'
```

Another data type used in JavaScript is the `Boolean` type.

A `Boolean` represents one of two possible values: `true` or `false`. You can use a boolean to check if a page is loading, or if a user is logged in or not.

The next two data types used in JavaScript are `undefined` and `null`.

`undefined` means a variable has been declared but hasn't been given a value yet. `null` means the variable has been intentionally set to "nothing" and does not hold any value. We will explore more on how this works in future lectures.

The next data type we will look at is the `Object` type.

An `Object` is a more complex data type that can hold collections of key-value pairs. Let's break this down. The key (also called a property name), is like a label for the data, whereas the value, is the actual data you want to store. Here is an example:

```js
let book = {
  title: "The Great Gatsby",
  author: "F. Scott Fitzgerald",
  year: 1925
};
```

In this object, `title`, `author`, and `year` are the keys (or property names). `The Great Gatsby`, `F. Scott Fitzgerald`, and `1925` are the corresponding values.

Each key-value pair in an object is called a property. So we can say that this book object has three properties. This is just a basic introduction to objects and their properties. In future lectures, we'll go deeper into more advanced concepts.

The last two data types are the `Symbol` and `BigInt` data types.

A `Symbol` is a special type of value in JavaScript that is always unique and cannot be changed. It's often used to create unique labels or identifiers for properties:

```js
// Creating two symbols
const symbol1 = Symbol('mySymbol');
const symbol2 = Symbol('mySymbol');
console.log(symbol1 === symbol2); // Outputs: false
```

In this example, we create two symbols with the same description, but they are unique.

`BigInt` is used for very large numbers that exceed the limit of the `Number` type:

```js
const bigNumber = 1234567890123456789012345678901234567890n;
console.log(bigNumber);
// Outputs: 1234567890123456789012345678901234567890n
```

In this example, we create a `BigInt` by adding `n` at the end of a very large number.

Understanding these data types helps you handle and work with various kinds of data in your programs, as each type has its own characteristics and behaviors.


## What Are Variables, and What Are Guidelines for Naming JavaScript Variables?

### Description

In JavaScript, variables act as containers for storing data that you can access and modify throughout your program.

You can think of variables as boxes that hold values. With variables, you can keep track of things like numbers or text and refer to these values whenever you need them in your program.

One way to declare a variable in JavaScript, is to use the `let` keyword. You will learn more about the `let` keyword as well as other ways to declare variables in future lectures.

Here's an example of using `let` to declare a variable called `age`:

```js
let age;
```

Right now, the `age` variable does not have a value assigned to it. To assign a value to a variable you will need to use the assignment operator like this:

```js
let age = 25;
```

The assignment operator looks like an equals sign (`=`) but it doesn't check for equality. You'll learn about the correct operators for checking equality in future lectures.

The assignment operator is used to assign a value to a variable. This process of assigning a value to a variable is known as initialization.

One advantage of using the `let` keyword to declare variables is that you can reassign values to them. In programming, reassignment means giving a new value to a variable that already has one.

Here is an example of reassigning the value for the `age` variable:

```js
age = 30;
```

Now the `age` variable holds the value of `30`. Notice that the `let` keyword wasn't needed again because the `age` variable was already declared, so there's no need to declare it a second time.

When using reassignment, you only need to reference the variable name. Reassignment is useful because it allows you to update and change the value stored in a variable as your program runs. A good example of this would be updating points in a game.

Naming variables may seem straightforward, but there are some rules and best practices to ensure your code is readable and functional.

Your variable names should describe what the data represents. For example, instead of using a name like `x`, a more descriptive name such as `age` or `points` makes your code easier to understand.

Variables in JavaScript must begin with a letter, an underscore (`_`), or a dollar sign (`$`). They cannot start with a number.

Variable names are case-sensitive, meaning the word `age` in all lowercase and the word `Age` with a capital `A` are considered different variables.

This is why it's important to stick with a consistent naming convention like camelCase. camelCase is where the first word is all lowercase and each subsequent word starts with an uppercase letter.

Here is an example of using the camelCase naming convention for a variable:

```js
let thisIsCamelCase;
```

There are certain keywords in JavaScript that you cannot use as variable names, such as `let`, `const`, `function`, or `return`, as they are reserved for the language itself.

You should also avoid using special characters like exclamation points (`!`) or at (`@`) symbols, in your variable names. It is best to keep variable names readable by using letters, numbers, underscores, or dollar signs.

By following these guidelines, your code will be cleaner and more manageable as it grows in complexity.


## How Do let and const Work Differently When It Comes to Variable Declaration, Assignment, and Reassignment?

### Description

When working with JavaScript, you'll often declare variables to store data that you plan to use throughout your program.

In modern JavaScript, `let` and `const` are the preferred ways to declare variables, but they differ in how they handle value assignment and reassignment.

In this lecture, we'll explore how `let` and `const` differ in variable declaration, assignment, and reassignment.

The `let` keyword allows you to declare variables that can be updated or reassigned later. You can think of `let` as a flexible container – once you've stored a value in it, you can change that value as needed throughout your program.

Here's an example of declaring and assigning a variable with `let`:

```js
let score = 10;
```

In this case, the variable `score` is declared and assigned the value `10`. If you want to update the value later, you can easily do that:

```js
score = 20;
```

Now, `score` holds the value `20`. This makes `let` particularly useful when you know the value of a variable will change as your program runs.

On the other hand, `const` is used to declare variables that are constant. Once you assign a value to a variable declared with `const`, you cannot reassign it.

This makes `const` ideal for values that you don't want to change accidentally during the execution of your program.

Here's an example of declaring and assigning a variable with `const`:

```js
const maxScore = 100;
```

Once `maxScore` is assigned the value `100`, it cannot be changed:

```js
maxScore = 200; // This will result in an error
```

Trying to reassign a value to a `const` variable will throw an error in your JavaScript console, as `const` variables are immutable once they are assigned.

You can declare a `let` variable without immediately assigning it a value, and you can assign it a value later:

```js
let age;
age = 25;
```

Variables declared with `const` must be assigned a value at the time of declaration. If you try to declare a `const` variable without assigning it a value, you will get an error:

```js
const age; // Error: Missing initializer in const declaration
```

You should use `let` when you need to declare variables that will be reassigned later. For example, tracking a changing score or updating a value over time in your program.

Use `const` when you want to declare variables that should remain constant, like configuration values or settings that shouldn't be changed accidentally.

You can also use the `var` keyword, but it's not as recommended anymore. The `var` is kind of like `let`, except it has a wider scope, which is more likely to cause problems in your program.


## What Is a String in JavaScript, and What Is String Immutability?

### Description

In JavaScript, a string is a sequence of characters used to represent text data. Strings are one of the primitive data types in the language, along with numbers, booleans, `null`, and `undefined`.

To create a string in JavaScript, you can use single quotes (`'`), or double quotes (`"`).

Here is an example of creating two variables that hold string values:

```js
let singleQuotes = 'This is a string';
let doubleQuotes = "This is also a string";
```

Even though you can use single or double quotes to create strings, it's important to be consistent. If a string begins with a single quote, it must also end with a single quote.

The same applies to double quotes. The following example will throw an error because it starts with a double quote and ends with a single quote:

```js
const improperStr = "Do not do this';
```

Another thing to take into account is that strings are immutable. In programming, immutability means that once something is created, it cannot be changed. So, when you create a string, you can't change its characters directly. Instead, you would create a new string if you want to make changes.

Here is an example of assigning a new string to a `developer` variable:

```js
let developer = "Jessica";
developer = "Quincy";
```

Since strings are immutable, we can't update the first string directly. That is why we are assigning a new string to the `developer` variable.

Strings are an important part of programming, and in future lectures, you will learn advanced techniques for manipulating them and harnessing their full potential to create dynamic and interactive applications.


## What Is String Concatenation, and How Can You Concatenate Strings with Variables?

### Description

In JavaScript, working with text is an essential part of coding, and often, you'll need to combine or join pieces of text together. This process is called string concatenation.

In this lecture, we'll focus on how string concatenation works, specifically using the `+` operator, the `+=` operator, and the `concat()` method.

The `+` operator is one of the simplest and most frequently used methods to concatenate strings. It allows you to join multiple strings or combine strings with variables that hold text.

Here's an example:

```js
let firstName = "John";
let lastName = "Doe";

let fullName = firstName + " " + lastName; // John Doe
```

In this example, we used the `+` operator to concatenate the `firstName` and `lastName` variables along with a space (`" "`) to create the full name.

One disadvantage of using the `+` operator for string concatenation is that it can lead to spacing issues if you don't carefully manage the spacing between the concatenated strings.

Here is an example where a space is missing:

```js
let firstName = "John";
let lastName = "Doe";

let fullName = firstName + lastName; // "JohnDoe"
```

Whenever you use the `+` operator to concatenate strings, it is important to double check for any potential spacing issues.

If you need to add or append to an existing string, then you can use the `+=` operator. This is helpful when you want to build upon a string by adding more text to it over time.

Here's an example of appending one string to another using the `+=` operator:

```js
let greeting = 'Hello';
greeting += ', John!';

// greeting is now the string Hello, John!
```

It is important to remember that strings are immutable which means once a string is created you can not alter it.

In this case, the original string of `Hello` is not modified. Instead, greeting now references the new string of `Hello, John!`

Another way you can concatenate strings is to use the `concat()` method.

Before we begin learning about the `concat()` method, it is important to first understand what a method and a function are at a higher level.

In programming, a function is a reusable block of code that performs a specific task and can be called with various inputs. A method, on the other hand, is a type of function that is associated with an object, meaning it operates on the data contained within that object.

In future lectures, we will dive much deeper into how functions, objects, and methods work in JavaScript. But for now, it is important to understand that JavaScript has dozens of methods you can use, like the `concat()` method.

Here's an example of using the `concat()` method to join two strings together:

```js
let str1 = 'Hello';
let str2 = 'World';

let result = str1.concat(' ', str2); // Hello World
```

In this example, we use the `concat()` method to join `str1`, a space (`' '`), and `str2` into a single string.

To conclude, `+` operator is best for simple concatenation, especially when you need to combine a few strings or variables.

The `+=` operator is useful when building up a string step by step or appending new content to an existing string variable.

Finally, the `concat()` method is beneficial when you need to concatenate multiple strings together.


## What Is console.log Used For, and How Does It Work?

### Description

In JavaScript, `console.log()` is a simple yet powerful tool used to display messages or output information to the browser's console. It's mostly used by developers to debug and inspect code while working on their programs.

You can use `console.log()` to log text or variables to the console and ensure your code is running correctly.

To use `console.log()`, you call the method with the value or message you want to output inside the parentheses. Here are some examples:

```js
console.log("Hello, world!");

let num = 5;
console.log(num);
```

The first example prints `Hello, world!` in the browser's console, while the second example prints the value `5`.

Here is another example of working with `console.log()`:

```js
let name = "Alice";
console.log("Hello, " + name + "!"); // Outputs: Hello, Alice!
```

The `console.log()` method helps you monitor your code as it runs, making it easier to spot mistakes and understand how your program behaves.


## What Is the Role of Semicolons in JavaScript, and Programming in General?

### Description

In JavaScript, and many other programming languages, semicolons help delineate statements and improve code readability.

In JavaScript, a semicolon (`;`) is used to indicate the end of a statement.

Just as a period (`.`) marks the end of a sentence in English, a semicolon signifies the end of an executable line of code. This allows the JavaScript engine to distinguish between separate commands.

For example:

```js
let variableOne = 5;  // Declare a variable and assign a value
let variableTwo = 10; // Declare another variable and assign a value
```

In this code, the semicolons at the end of each line mark the end of each statement. Without them, the JavaScript engine might have trouble interpreting where one statement ends and another begins.

Semicolons are primarily used to mark the end of a statement. This helps the JavaScript engine understand the separation of individual instructions, which is important for correct execution.

```js
let a = 1;   // Statement ends here
let b = 2;   // Another statement starts here
```

While JavaScript has Automatic Semicolon Insertion (ASI) that can add semicolons automatically, explicitly including them improves code clarity and helps prevent errors that may arise from unexpected ASI behavior.

Semicolons are used in many programming languages, including C, C++, and Java.

Semicolons mark the end of statements or instructions, helping the compiler or interpreter parse the code correctly. A compiler translates high-level programming language code into machine-readable code, which creates an executable file.

By clearly delineating statements, semicolons contribute to the readability and maintainability of code. Semicolons help prevent ambiguities in code execution and ensure that statements are correctly terminated.

Semicolons are a fundamental part of JavaScript and many other programming languages.

They mark the end of statements, improve code readability, and help avoid errors related to Automatic Semicolon Insertion.

By understanding and using semicolons properly, you can write more reliable and maintainable code.


## What Are Comments in JavaScript, and When Should You Use Them?

### Description

Comments in programming are used to provide additional context for the code or leave notes for yourself and others.

Comments are lines or blocks of text that are ignored by the JavaScript engine when your code is executed. They are there solely for the benefit of people reading the code, whether that's you or someone else.

JavaScript provides two ways to add comments to your code: single-line comments and multi-line comments.

Single-line comments are created using two forward slashes (`//`). Here is an example:

```js
// I am a single line comment in JavaScript
```

This type of comment is great for brief explanations or clarifications.

Here is a real world example from the freeCodeCamp curriculum project files:

```js
// This is to allow English to build without having to download the i18n files.
// It fails when trying to resolve the i18n-curriculum path if they don't exist.
const curriculumLocale = process.env.CURRICULUM_LOCALE ?? 'english';
const I18N_CURRICULUM_DIR = path.resolve(
  __dirname,
  curriculumLocale === 'english' ? '.' : 'i18n-curriculum/curriculum'
);
```

Do not worry about trying to understand what the code is actually doing because it is more advanced than what you have learned so far. Instead, focus on the comment left by the developer. This comment provides important context for why this code exists.

Comments like this are important for those working on teams for two reasons:

1. Other developers working on the project will understand the purpose of this code.

1. It helps prevent unnecessary changes or deletions without consulting the team, which could lead to bugs or issues.

Another type of comment is multi-line comments. Here is the basic syntax:

```js
/*
 I am a multiline comment.
 This is helpful for longer explanations.
*/
```

Multi-line comments are useful when you need to write longer descriptions, explanations, or notes in your code.

Let's take another look at the freeCodeCamp curriculum project files to see how multiline comments can be used in the real world.

```js
/* Since there can be more than one way to complete a certification (using the
legacy curriculum or the new one, for instance), we need a certification
field to track which certification this belongs to. */
const dupeCertifications = [
  {
    certification: 'responsive-web-design',
    dupe: '2022/responsive-web-design'
  }
];
const hasDupe = dupeCertifications.find(
  cert => cert.dupe === meta.superBlock
);
```

Just like before, ignore all of the JavaScript code because it uses concepts that haven't been taught yet. Instead, focus on the comment left by the developer.

A developer on the team, or even a new contributor working on the project, can understand why this piece of code is here and have the full context before working on this area of the project.

While comments are useful in programming, it is important to avoid over-commenting. You don't need to comment on every single line of code, especially if the code is straightforward and self-explanatory.

Here is an example of using comments to explain the obvious:

```js
// This code uses the const keyword to create a new variable called price.
// We are assigning the number 10 to the price variable.
const price = 10;
```

In this situation, there is no need to add any comments here because the code is self-explanatory. The goal is to enhance readability, not clutter the code with unnecessary explanations.

If you want to add comments to your personal projects as you are learning to code, that is fine. But once you start working on real world projects with other developers, it is important not to use comments for code that is self-explanatory.

It is also important not to use comments to help explain away confusing, overly complicated, or poorly written code. In those situations, it is best to refactor, or change, your code so other developers will better understand what is going on.

Comments are powerful tools for documenting your code and making it easier to understand. You should use comments to provide context or leave notes for yourself and others.


### Lecture Block: Lecture Working With Data Types


## What Is Dynamic Typing in JavaScript, and How Does It Differ from Statically Typed Languages?

### Description

JavaScript is a dynamically typed language, meaning you don't need to specify the data type of a variable when you declare it. Instead, the type is determined based on the value assigned to the variable while the program is running. This allows you to change the type of a variable throughout the program.

Let's look at an example:

```js
let example = "Hello";
example = 42;
```

In this example, we have a variable called `example` with the data type of string. But then we update value to be a number instead.

The flexibility of dynamic typing makes JavaScript more forgiving and easy to work with for quick scripting, but it can also introduce bugs that may be harder to catch, especially as your program grows larger.

In statically typed languages like Java or C++, you must declare the data type of a variable when you create it, and that type cannot change.

For instance, if you declare a variable as `integer`, you can only assign it integer values. If you try to assign it a different type, the program will throw an error.

Here's an example in Java language:

```js
int value = 42; // value must always be an integer
value = "Hello"; // This would cause an error in Java
```

The difference between dynamic typing and static typing lies in the flexibility vs. the safety of your code. Dynamically typed languages offer flexibility but at the cost of potential runtime errors.

Statically typed languages enforce stricter rules that can prevent certain errors, but they require more upfront declaration and offer less flexibility in changing types.

Here is another example of creating a variable with a type set to `number` then changing it to later be of type `string`:

```js
let data = 100;  // Initially a number
data = "New data";  // Dynamically changes to a string
```

In a statically typed language, this kind of change would not be allowed, as the data type would be fixed.

In conclusion, JavaScript's dynamic typing allows variables to change types freely, which offers flexibility but can lead to unexpected errors during execution.

Statically typed languages like Java require you to specify variable types upfront, which helps catch errors before the program runs but offers less flexibility.


## How Does the typeof Operator Work, and What Is the typeof null Bug in JavaScript?

### Description

The `typeof` operator in JavaScript is a simple yet powerful tool that lets you see the data type of a variable or value. It always returns a string indicating the type.

Let's take a look at a few examples:

```js
let num = 42;
console.log(typeof num); // "number"
```

In this first example, we have created a variable called `num` and assigned it the number `42`. When you use the `typeof` operator on the variable named `num`, it will return the string `number`.

Here is another example of using the `typeof` operator on variable called `isUserLoggedIn`:

```js
let isUserLoggedIn = true;
console.log(typeof isUserLoggedIn); // "boolean"
```

When you use the `typeof` operator on the `isUserLoggedIn` variable, it will return a string `boolean` because the boolean `true` was assigned to the variable.

Using the `typeof` operator can be especially useful when you're debugging or trying to understand what kind of data you're working with in your code.

However, there's a well-known quirk in JavaScript when it comes to `null`.

Let's take a look at an example:

```js
let exampleVariable = null;
console.log(typeof exampleVariable); // "object"
```

In this example, we have a variable called `exampleVariable` and have assigned it the value of `null`. But when we use the `typeof` operator, it returns the string `object`.

This is widely considered a bug in JavaScript, dating back to its early days. The reason for this behavior is rooted in the way JavaScript was originally designed.

When the language was first implemented, values like `null` were represented as a special type of object, leading to this unexpected result.

Unfortunately, this has become a part of the language, and while it's confusing, it's something you'll need to be aware of.


### Lecture Block: Lecture Working With Strings In Javascript


## What Is Bracket Notation, and How Do You Access Characters from a String?

### Description

In JavaScript, strings are treated as sequences of characters, and each character in a string can be accessed using bracket notation. This allows you to retrieve a specific character from a string based on its position, which is called its index.

An index is the position of a character within a string, and it is zero-based. This means that the first character of a string has an index of `0`, the second character has an index of `1`, and so on.

For example, in the string `hello`, the character `h` is at index `0`, `e` is at index `1`, `l` is at index `2`, and so on.

Bracket notation uses square brackets (`[]`) and the index of the character you want to access. Let’s look at an example:

```js
let greeting = "hello";
console.log(greeting[1]); // Output: "e"
```

In this example, we can access the character at index `1`, which is `e`.

To get the last character of a string, you can use the length of the string minus one.
The `length` property of a string tells you how many characters it contains, so to access the last character, you would subtract one from the length:

```js
let greeting = "hello";
console.log(greeting[greeting.length - 1]); // Output: "o"
```

In this case, the `length` of `hello` is `5`, and the last character (`o`) is at index `4` which is `5 - 1`.

If you want to get multiple characters, you can use bracket notation like this:

```js
let greeting = "hello";
let firstTwo = greeting[0] + greeting[1]; // Output: "he"
console.log(firstTwo);
```

In this example, we are concatenating the first and second characters using bracket notation to form the string `he`.

Bracket notation is useful when you need to access specific characters in a string, such as extracting initials from a name or checking a specific letter for validation.


## How Do You Create a Newline in Strings and Escape Strings?

### Description

When working with strings in JavaScript, there are times when you need to include special characters that the JavaScript engine might otherwise misinterpret.

Two common tasks involve creating a newline within a string and escaping certain characters (like quotes) to make sure they appear correctly.

In many programming languages, including JavaScript, you can create a newline in a string using a special character called an escape sequence. The most common escape sequence for newlines is `\n`.

For example, if you want to break a string into multiple lines, you would use `\n` where you want the new line to begin:

```js
let poem = "Roses are red,\nViolets are blue,\nJavaScript is fun,\nAnd so are you.";
console.log(poem);
```

The output will be:

```md
Roses are red,
Violets are blue,
JavaScript is fun,
And so are you.
```

The `\n` escape sequence tells JavaScript to insert a line break at that point, which results in the string being displayed across multiple lines.

Another important concept when working with strings is escaping characters. Sometimes, you need to include characters in your string that JavaScript normally uses for something else, such as quotes.

If you simply use quotes inside a string without escaping them, it can cause an error because JavaScript will think you're trying to end the string.

For example, this will cause an error:

```js
let statement = "She said, "Hello!"";
```

JavaScript gets confused because it thinks the string ends after the word `"said,"` but, you want the quotes around `"Hello!"` to be part of the string.

To fix this, you can escape the inner quotes by placing a backslash (`\`) before them:

```js
let statement = "She said, \"Hello!\"";
console.log(statement); // Output: She said, "Hello!"
```

The backslash tells JavaScript to treat the quotes as literal characters, so they appear correctly in the output.

You can also escape other special characters, such as the backslash itself (`\\`), or single quotes within a string surrounded by single quotes (`\'`).

Here's another example using single quotes:

```js
let quote = 'It\'s a beautiful day!';
console.log(quote); // Output: It's a beautiful day!
```

By escaping the single quote with `\'`, JavaScript knows to include it as part of the string rather than ending the string early.

Escaping and creating newlines are essential when you’re formatting output or handling special characters in strings. These techniques help you prevent errors and ensure your text appears exactly as intended.


## What Are Template Literals, and What Is String Interpolation?

### Description

In JavaScript, template literals are a powerful and flexible way to work with strings. Unlike regular strings, which use single (`'`) or double (`"`) quotes, template literals are defined with backticks (`` ` ``).

They allow for easier string manipulation, including embedding variables directly inside a string, a feature known as string interpolation.

Template literals make it easier to create strings that span multiple lines or include expressions (like variables or even JavaScript code) directly within the string.

Here's a basic example of a template literal:

```js
let name = "Alice";
let greeting = `Hello, ${name}!`; // Output: "Hello, Alice!"
```

Notice the use of backticks instead of single or double quotes. The `${name}` syntax is an example of string interpolation, where the value of the variable `name` is directly inserted into the string.

String interpolation allows you to embed variables and expressions inside a string. This is a significant improvement over the older method, where you would concatenate strings and variables using the `+` operator.

Here is an example using string concatenation and the plus (`+`) operator:

```js
let name = "Alice";
let age = 25;
let message = "My name is " + name + " and I am " + age + " years old.";
console.log(message); // Output: "My name is Alice and I am 25 years old."
```

And here is an example using template literals and string interpolation:

```js
let message = `My name is ${name} and I am ${age} years old.`;
console.log(message); // Output: "My name is Alice and I am 25 years old."
```

As you can see, string interpolation with template literals is much cleaner and easier to read, especially when you're working with multiple variables.

Another great feature of template literals is that they support multiline strings. With regular strings, you would need to use escape characters (`\n`) to create new lines. With template literals, you can simply write the string across multiple lines, and the formatting is preserved:

```js
let poem = `Roses are red,
Violets are blue,
JavaScript is fun,
And so are you.`;

console.log(poem);
```

The output will retain the line breaks as written:

```md
Roses are red,
Violets are blue,
JavaScript is fun,
And so are you.
```

Template literals are particularly useful when you need to include variables or expressions in strings, format complex strings, or work with multiline text. They are more concise and readable compared to traditional string concatenation.


## How Can You Find the Position of a Substring in a String?

### Description

When working with strings in JavaScript, there may be times when you need to locate the position of a specific substring within a larger string.

A substring is a sequence of characters that appears within a larger string. For example, in the string `hello world`, `hello` and `world` are substrings.

To locate the position of a substring inside of a string, you can use the `indexOf()` method.
The `indexOf()` method in JavaScript allows you to search for a substring within a string.

If the substring is found, `indexOf()` returns the index (or position) of the first occurrence of that substring. If the substring is not found, `indexOf()` returns `-1`, which indicates that the search was unsuccessful.

The `indexOf()` method takes two arguments: the first is the substring you want to find within the larger string, and the second is an option starting position for the search. If you don’t provide a starting position, the search will begin at the start of the string.

In this context, an **argument** is a value you give to a function or method when you call it, enabling that function or method to perform its task using the specific information you provide. You will learn more about arguments in future lectures.

Here is an example of using the `indexOf()` method to find the position for the string `awesome`:

```js
let sentence = "JavaScript is awesome!";
let position = sentence.indexOf("awesome!");
console.log(position); // 14
```

In this example, the word `awesome` starts at index `14` in the string `JavaScript is awesome!`, so the `indexOf()` method returns `14`.

Now, let's see what happens when the substring isn't found:

```js
let sentence = "JavaScript is awesome!";
let position = sentence.indexOf("fantastic");
console.log(position); // -1
```

Since the word `fantastic` does not appear in the string, the method returns `-1`.

You can also specify where to begin searching within the string by providing a second argument to `indexOf()`. Here’s an example:

```js
let sentence = "JavaScript is awesome, and JavaScript is powerful!";
let position = sentence.indexOf("JavaScript", 10);
console.log(position); // 27
```

In this case, the search for `JavaScript` begins after the 10th character, and so the second occurrence of `JavaScript` is found at index `27`.

It is important to note that the `indexOf()` method is case sensitive.

In this example, the following would return `-1` because the capital letter `F` is not found in the string `freeCodeCamp`.

```js
console.log("freeCodeCamp".indexOf("F")) // -1
```

Using `indexOf()` can be very useful when you need to check if a substring is present in a string and to determine its position for further operations.


## What Is the Prompt Method, and How Does It Work?

### Description

The `prompt()` method is an important part of JavaScript's interaction with the user. It’s one of the simplest ways to get input from a user through a small pop-up dialog box.

You'll often see it used in cases where the webpage needs a piece of information from the user, such as a name or some other form of text input.

So, what exactly does the `prompt()` method do? It opens a dialog box that asks the user for some input, and then it returns the text entered by the user as a string.

The `prompt()` method takes two arguments: The first one is the message which will appear inside the dialog box, typically prompting the user to enter information. And the second one is a default value which is optional and will fill the input field initially.

Here's an example of how it works:

```js
let userName = prompt("What is your name?", "Guest");
```

In this example, the `prompt()` method displays a dialog box with the message `What is your name?` and an input field that initially contains the value `Guest`.

If the user types their name and presses "OK", the `userName` variable will store the entered value. If the user presses "Cancel," the `userName` variable will be set to `null`. `null` signifies that the user did not provide any input.

When the page first loads, you'll see the prompt dialog box appear with the message `What is your name?` and the input field pre-filled with `Guest`.

Keep in mind that the `prompt()` method will halt the execution of the script until the user interacts with the dialog box.

This means the rest of your JavaScript code won’t run until the user either provides input and clicks "OK", or cancels the prompt.

One other point to consider is that while `prompt()` is useful for quick testing or small applications, it's generally avoided in modern, complex web applications due to its disruptive nature and inconsistent behavior across different browsers.

Here's an example:

```js
let age = prompt("How old are you?");
if (age !== null) {
  console.log("You are " + age + " years old.");
} else {
  console.log("User canceled the prompt.");
}
```

In this example, if the user provides input, it will be displayed in the console. If they cancel, the console will log that the user canceled the prompt.

By understanding the `prompt()` method, you gain a simple way to interact with users and retrieve information directly through the browser, even though it may not be widely used in modern web applications.


### Lecture Block: Lecture Working With Common String Methods


## What Is ASCII, and How Does It Work with charCodeAt() and fromCharCode()?

### Description

In programming, understanding how characters are represented as numbers is fundamental. This is where ASCII comes in. ASCII, short for American Standard Code for Information Interchange, is a character encoding standard used in computers to represent text. It assigns a numeric value to each character, which is universally recognized by machines.

In this lecture, we will explore what ASCII is, how it works, and how you can use JavaScript methods like `charCodeAt()` and `fromCharCode()` to interact with ASCII values.

ASCII is a system for encoding characters such as letters, digits, and symbols into numerical values. Each character is mapped to a specific number.

For example, the capital letter `A` is represented by the number `65` in ASCII, while the lowercase `a` is represented by `97`. This encoding allows computers to store and manipulate text.

The ASCII standard covers 128 characters including:

- Uppercase and lowercase English letters (A-Z, a-z).
- Numbers (0-9).  
- Common punctuation marks and symbols (!, @, #, and so on).
- Control characters (such as newline and tab).  

In JavaScript, you can easily access the ASCII code of a character using the `charCodeAt()` method. This method is called on a string and returns the ASCII code of the character at a specified index.

Let’s take a look at an example:

```js
let letter = "A";
console.log(letter.charCodeAt(0));  // Output: 65
```

In this example, `A` is the first character of the string, and calling `charCodeAt(0)` returns its ASCII value, `65`.

You can also use this method with other characters to find their ASCII values:

```js
let symbol = "!";
console.log(symbol.charCodeAt(0));  // Output: 33
```

Here, the ASCII code for the exclamation mark `!` is returned as `33`.

While `charCodeAt()` helps you retrieve the ASCII value of a character, the `fromCharCode()` method allows you to do the opposite: convert an ASCII code into its corresponding character.

Let's see this in action:

```js
let char = String.fromCharCode(65);
console.log(char);  // Output: A
```

In this example, `fromCharCode(65)` converts the ASCII value `65` back to the character `A`.

Another example would be converting the number `97` to its corresponding lowercase letter:

```js
let char = String.fromCharCode(97);
console.log(char);  // Output: a
```

These methods are particularly useful when you need to manipulate or compare characters based on their ASCII values.

For instance, you might use `charCodeAt()` to check if a character is uppercase, lowercase, or a digit by comparing its ASCII value.

On the other hand, `fromCharCode()` can be used to dynamically generate characters from their ASCII codes.


## How Can You Test if a String Contains a Substring?

### Description

When working with strings in JavaScript, there are many cases where you might need to check whether a string contains a specific substring, which is a smaller part of that string.

For example, you might want to check if a user's input includes a specific word or character before performing some action. One way to achieve this is by using the `includes()` method.

The `includes()` method is used to check if a string contains a specific substring. If the substring is found within the string, the method returns `true` otherwise, it returns `false`.

Here's the basic syntax:

```js
string.includes(searchValue);
```

For the syntax, the `searchValue` is the substring you want to look for within the string. And here's an example:

```js
let phrase = "JavaScript is awesome!";
let result = phrase.includes("awesome");

console.log(result);  // true
```

In this example, the word `awesome` is found within the string `JavaScript is awesome!`, so the `includes()` method returns `true`.

It's important to note that the `includes()` method is case-sensitive. This means that the exact match of the characters is required, including their case.

For example:

```js
let phrase = "JavaScript is awesome!";
let result = phrase.includes("Awesome");

console.log(result);  // Output: false
```

Since `Awesome` (with an uppercase `A`) does not match `awesome` (with a lowercase `a`), the result is `false`.

You can also use the `includes()` method to check for a substring starting at a specific index in the string by providing a second parameter:

```js
let text = "Hello, JavaScript world!";
let result = text.includes("JavaScript", 7);

console.log(result);  // true
```

Here, the search for the substring `JavaScript` starts from the 7th position in the string, ensuring it skips any characters before this position.

The `includes()` method only returns a `true` or `false` result. It does not provide information on where the substring is located in the string or how many times it occurs. If you need that level of detail, other methods, such as the `indexOf()` method might be more suitable.


## How Can You Extract a Substring from a String?

### Description

When working with strings in JavaScript, you often need to extract a portion or substring from a larger string.

For example, you may want to extract part of a word, a specific character sequence, or just a fragment of a sentence.

JavaScript provides several methods for this task, one of the most commonly used being the `slice()` method.

The `slice()` method allows you to extract a portion of a string and returns a new string, without modifying the original string. It takes two parameters: the starting index and the optional ending index.

Here's the basic syntax:

```js
string.slice(startIndex, endIndex);
```

`startIndex` is the position where the extraction starts. `endIndex` is where the extraction ends. If not provided, `slice()` extracts until the end of the string.

Let's look at a simple example of extracting part of a string:

```js
let message = "Hello, world!";
let greeting = message.slice(0, 5);

console.log(greeting);  // Output: Hello
```

In this example, `slice(0, 5)` extracts characters starting from index `0` up to but not including index `5`. As a result, the word `Hello` is extracted.

If you omit the second parameter, `slice()` will extract everything from the start index to the end of the string:

```js
let message = "Hello, world!";
let world = message.slice(7);

console.log(world);  // Output: world!
```

Here, `slice(7)` extracts the string from index `7` to the end of the string, resulting in `world!`.

You can also use negative numbers as indexes. When you use a negative number, it counts backward from the end of the string:

```js
let message = "JavaScript is fun!";
let lastWord = message.slice(-4);

console.log(lastWord);  // Output: fun!
```

In this case, `slice(-4)` extracts the last four characters from the string, giving us `fun!`.

Let's say you want to extract a section from the middle of a string. You can provide both the starting and ending indexes to precisely control which part of the string you want:

```js
let message = "I love JavaScript!";
let language = message.slice(7, 17);

console.log(language);  // Output: JavaScript
```

Here, `slice(7, 17)` extracts the substring starting at index 7 and ending right before index `17`, which is the word `JavaScript`.

The `slice()` method is a powerful tool for extracting parts of a string in JavaScript.

You specify the start and end indexes, and the method returns a new string that contains the extracted portion.

With options for positive, negative, and omitted indexes, you can adapt it to various situations without altering the original string.


## How Can You Change the Casing for a String?

### Description

When working with strings in JavaScript, there are many situations where you might need to adjust the case of the text, such as transforming all letters to uppercase for a heading or converting text to lowercase for uniformity.

Luckily, JavaScript makes this easy with two built-in methods: `toUpperCase()` and `toLowerCase()`.

The `toUpperCase()` method converts all the characters to uppercase letters and returns a new string with all uppercase characters. This is useful when you want to emphasize text or create consistency in the format of strings.

Let's see an example:

```js
let greeting = "Hello, World!";
let uppercaseGreeting = greeting.toUpperCase();
console.log(uppercaseGreeting);  // Output: "HELLO, WORLD!"
```

In this code, the `toUpperCase()` method transforms the entire string into uppercase letters.

The original string remains unchanged because `toUpperCase()` returns a new string, rather than modifying the original one.

On the flip side, the `toLowerCase()` method converts all characters in a string to lowercase. This is helpful when you need to standardize input, such as when comparing user-provided text or making case-insensitive checks.

Let's look at an example:

```js
let shout = "I AM LEARNING JAVASCRIPT!";
let lowercaseShout = shout.toLowerCase();
console.log(lowercaseShout);  // Output: "i am learning javascript!"
```

The `toLowerCase()` method converts all characters to lowercase, making the string less aggressive, while leaving the original string unchanged.

In summary, the `toUpperCase()` and `toLowerCase()` methods in JavaScript are powerful tools for transforming strings into all uppercase or lowercase letters.

These methods are particularly useful for standardizing text input, making case-insensitive comparisons, and ensuring design consistency.

With these simple yet effective methods, you can handle text manipulation in a more controlled and predictable way.


## How Can You Replace Parts of a String with Another?

### Description

In JavaScript, there are many scenarios where you may need to replace a portion of a string with another string.

For instance, you might need to update user information in a URL, change the formatting of dates, or correct errors in user-generated content.

The `replace()` method in JavaScript allows you to find a specified value (like a word or character) in a string and replace it with another value.

Here is the basic syntax:

```js
string.replace(searchValue, newValue);
```

`searchValue` is the value you want to search for in the string. It can be either a string or a regular expression (regex), which describes patterns in text. This allows you to search for and manipulate strings in a flexible and powerful way. You'll learn more about regular expressions in future lectures.

The `newValue` is the value that will replace the `searchValue`. Here's a simple example:

```js
let text = "I love JavaScript!";
let newText = text.replace("JavaScript", "coding");

console.log(newText);  // Output: "I love coding!"
```

In this example, the word `JavaScript` is found within the string and is replaced with `coding`.

The `replace()` method is case-sensitive, meaning that it will only find exact matches of the `searchValue`. For example:

```js
let sentence = "I enjoy working with JavaScript.";
let updatedSentence = sentence.replace("javascript", "coding");

console.log(updatedSentence);  // Output: "I enjoy working with JavaScript."
```

Here, since `javascript` (with lowercase `j`) does not match `JavaScript` (with uppercase `J`), the replacement is not made.

By default, the `replace()` method will only replace the first occurrence of the `searchValue`. If the value appears multiple times in the string, only the first one will be replaced:

```js
let phrase = "Hello, world! Welcome to the world of coding.";
let updatedPhrase = phrase.replace("world", "universe");

console.log(updatedPhrase);  // Output: "Hello, universe! Welcome to the world of coding."
```

Notice that only the first occurrence of `world` is replaced with `universe`.

The `replace()` method in JavaScript is a powerful and flexible tool for string manipulation.

It lets you replace specific parts of a string, whether you're dealing with individual characters, words, or complex patterns using regular expressions.

While it's ideal for straightforward replacements, understanding its case sensitivity and default behavior (like replacing only the first occurrence) can help you use it more effectively.


## How Can You Repeat a String x Number of Times?

### Description

When working with JavaScript, you may encounter situations where you need to repeat a string a specific number of times.

Whether you're generating repeated patterns or simply duplicating text, the `repeat()` method provides a simple and effective way to achieve this.

The `repeat()` method is a built-in function in JavaScript that allows you to repeat a string a specified number of times. Here is the basic syntax:

```js
string.repeat(count);
```

`string` is the string that you want to repeat, and `count` is the number of times you want the string to be repeated. Here's an example:

```js
let word = "Hello!";
let repeatedWord = word.repeat(3);
console.log(repeatedWord);  // Output: "Hello!Hello!Hello!"
```

In this case, the string `Hello!` is repeated three times, resulting in `Hello!Hello!Hello!`.

While the `repeat()` method is useful, there are a few exceptions and limitations to keep in mind.

The `count` parameter must be a non-negative number. If you pass a negative number, JavaScript will throw a `RangeError`.

```js
let word = "Test";
console.log(word.repeat(-1));  // Throws RangeError: Invalid count value
```

The `count` must be a finite number. If you try to repeat a string an infinite number of times or use `Infinity` as the count, you will also get a `RangeError`.

In JavaScript, `Infinity` is a special value that represents an infinite quantity. It's used to denote numbers that are larger than any finite number.

```js
let word = "Test";
console.log(word.repeat(Infinity));  // Throws RangeError: Invalid count value
```

If the count is not an integer (such as a decimal like `2.5`), the `repeat()` method will round it down to the nearest integer.

```js
let word = "Test";
console.log(word.repeat(2.5));  // Output: "TestTest"
```

If you pass `0` as the count, the `repeat()` method will return an empty string.

```js
let word = "Test";
console.log(word.repeat(0));  // Output: ""
```

The `repeat()` method can simplify tasks that involve string duplication, making your code more concise and readable.

Whether you're generating repeated text patterns or filling a space with characters, `repeat()` can save you from writing loops or more complex code.


## How Can You Trim Whitespace from a String?

### Description

When working with strings in JavaScript, it's common to encounter unwanted whitespace at the beginning or end of a string. Whitespace can interfere with operations like comparison, storage, or display, which is why it's important to know how to remove it efficiently.

In this lecture, we'll explore how you can trim whitespace using JavaScript's `trim()`, `trimStart()`, and `trimEnd()` methods.

Whitespace refers to spaces, tabs, or line breaks that occur in a string but are not visible characters. For example:

```js
let greeting = "   Hello, world!   ";
```

In this case, there are spaces before and after the visible text, `Hello, world!`.

The `trim()` method is the most commonly used way to remove whitespace from both the beginning and the end of a string. Here's an example:

```js
let message = "   Hello!   ";
let trimmedMessage = message.trim();
console.log(trimmedMessage);  // Output: "Hello!"
```

In this case, the `trim()` method removes all the leading and trailing spaces, leaving just `Hello!`. Note that any whitespace within the string (between words, for example) is left untouched by `trim()`.

Sometimes, you may only want to remove whitespace from either the beginning or the end of a string, but not both. This is where `trimStart()` and `trimEnd()` come in.

`trimStart()` removes whitespace from the beginning (or start) of the string.

```js
let greeting = "   Hello!   ";
let trimmedStart = greeting.trimStart();

console.log(trimmedStart);  // Output: "Hello!   "
```

`trimEnd()` removes whitespace from the end of the string.

```js
let greeting = "   Hello!   ";
let trimmedEnd = greeting.trimEnd();

console.log(trimmedEnd);  // Output: "   Hello!"
```

These methods give you more precise control over which part of the string you want to clean up.

In summary, trimming whitespace is an essential part of working with strings in JavaScript. Whether you want to clean up input data or ensure consistent string comparisons, you can use `trim()` to remove whitespace from both sides of a string, or use `trimStart()` and `trimEnd()` to target specific sides.


## Module: Javascript Booleans And Numbers


### Lecture Block: Lecture Working With Numbers And Arithmetic Operators


## What Is the Number Type in JavaScript, and What Are the Different Types of Numbers Available?

### Description

The `Number` type is one of the most used data types in JavaScript and other programming languages. Numbers might seem simple, but there's a lot to explore when it comes to numbers in JavaScript. So, let's take a deeper look. In JavaScript, the `Number` data type represents a numeric value.

Unlike many other programming languages that separate integers and floating-point numbers into different types, JavaScript uses one unified `Number` type to account for numbers. This means you can work with whole numbers, decimals, and even special numeric values all under the same `Number` data type umbrella.

Here's a basic example showing you integers, floating point numbers, and negative numbers are all of type number:

```js
const wholeNumber = 50;
const decimalNumber = 4.5;
const negativeNumber = -7;

console.log(typeof wholeNumber); // number
console.log(typeof decimalNumber); // number
console.log(typeof negativeNumber); // number
```

JavaScript's `Number` type includes various kinds of numeric values, ranging from simple integers and floating-point numbers to special cases like `Infinity` and `NaN`, or "Not a Number". Let's break down the main types you'll encounter. Integers are whole numbers without any fractional or decimal part. They can be positive, negative, or zero. Here are some examples:

```js
const positiveInteger = 100;
const negativeInteger = -25;
const zero = 0;

console.log(typeof positiveInteger); // number
console.log(typeof negativeInteger); // number
console.log(typeof zero); // number
```

Floating point numbers are numbers with decimal points. They're often referred to as just "floats" by JavaScript developers. Floats are useful when you need more precision, such as when you're dealing with measurements or currencies. Here are some examples:

```js
const floatingPointNumber = 4.5;
const anotherFloat = 89.56;
const oneMoreFloat = 16.462;

console.log(typeof floatingPointNumber); // number
console.log(typeof anotherFloat); // number
console.log(typeof oneMoreFloat); // number
```

JavaScript can represent numbers that are beyond the maximum limit with `Infinity`. You'll encounter this when you try to divide a number by zero or on rare occasions, exceed the upper boundary of the `Number` type. Here's an example:

```js
const infiniteNumber = 1 / 0;
console.log(infiniteNumber); // Infinity
console.log(typeof infiniteNumber); // number
```

Sometimes in JavaScript, some mathematical operations don't result in a valid number. For instance, if you try to perform a mathematical operation on something that isn't a number, you'll get `NaN`, which stands for "Not a Number":

```js
const notANumber = 'hello world' / 2;
console.log(notANumber); // NaN
```

Surprisingly, the type of `NaN` is also `Number`:

```js
const notANumber = 'hello world' / 2;
console.log(typeof notANumber); // number
```

Apart from the standard decimal system (base 10), JavaScript also supports numbers in different bases such as binary, octal, and hexadecimal. Binary is a base-2 system that uses only digits 1 and 0. Octal is a base-8 system that uses only digits 0 to 7. Hexadecimal is a base-16 system that uses digits 0 to 9 and letters a to f, like you see in CSS hex colors.


## What Are the Different Arithmetic Operators in JavaScript?

### Description

JavaScript provides tools to perform basic arithmetic operations on numbers, such as addition, subtraction, multiplication, and division. JavaScript also includes operators for more complex arithmetic operations, such as remainder and exponentiation.

All these tools are called arithmetic operators. Let's look at these operators in detail, how to use them and how to combine them. 

The addition operator is a plus sign (`+`). The addition operator allows you to find the total of two or more numbers. In addition operations, the order of the numbers doesn't matter:

```js
const num1 = 10;
const num2 = 5;
const num3 = 15;

const result1 = num1 + num2;
const result2 = num2 + num1;
const result3 = num2 + num1 + num3;

console.log(result1); // 15
console.log(result2); // 15
console.log(result3); // 30
```

The subtraction operator is a minus sign (`-`). It allows you to find the difference between two numbers. Use the minus sign when you want to subtract a number from another number, usually a smaller one from a bigger one:

```js
const difference = 10 - 5;
console.log(difference); // 5
```

If a smaller number comes first, you'll get a negative result:

```js
const difference = 5 - 10;
console.log(difference); // -5
```

You can also assign the numbers to variables and do the subtraction with the variable names:

```js
const num1 = 10;
const num2 = 5;
const result = num1 - num2;

console.log(result); // 5
```

In JavaScript, the multiplication operator is represented by an asterisk (`*`) and is used to find the product of two or more numbers. The order of the numbers you're multiplying does not matter:

```js
const num1 = 10;
const num2 = 5;
const num3 = 15;

const result1 = num1 * num2;
const result2 = num2 * num1;
const result3 = num2 * num1 * num3;

console.log(result1); // 50
console.log(result2); // 50
console.log(result3); // 750
```

In JavaScript, the division operator is a slash (`/`), which differs from the division symbol used in traditional math (`÷`). You perform division operations with the division operator. The order of the numbers you're dividing matters in this case:

```js
const num1 = 10;
const num2 = 5;
const num3 = 15;

const result1 = num1 / num2;
const result2 = num2 / num1;
const result3 = num2 / num1 / num3;

console.log(result1); // 2
console.log(result2); // 0.5
console.log(result3); // 0.03333333333333333
```

It's important to note that if you try to divide by zero, JavaScript will return `Infinity`:

```js
const result = 10 / 0; 

console.log(result); // Infinity
```

Make sure to avoid those types of calculations so you don't end up with unexpected results in your code. 

The remainder operator, represented by a percentage sign (`%`), returns the remainder of a division. The remainder in math is the leftover value after performing division:

```js
const num1 = 10;
const num2 = 3;
const remainder = num1 % num2;

console.log(remainder); // 1
```

The exponentiation operator, represented by a double asterisk (`**`), raises one number to the power of another:

```js
const num1 = 2;
const num2 = 3;

const exponent = num1 ** num2;
console.log(exponent); // 8
```

It's possible to mix operators in a single operation or expression:

```js
const result = 10 + 5 * 2 - 8 / 4;
console.log(result); // 18
```

When you mix different operators in a single expression, the JavaScript engine follows a system called operator precedence to determine the order of operations. Operator precedence determines the order in which operations are executed in expressions. You will learn more about operator precedence in future lectures.


## What Happens When You Try to Do Calculations with Numbers and Strings?

### Description

JavaScript is a language where things sometimes work in surprising, or even weird, ways. One such surprise occurs when you mix numbers and strings in calculations. The first thing you'll probably try is to add a number and a string. In JavaScript, the `+` operator does double duty. It handles both addition and string concatenation, which is a way to join two strings together.

When you use `+` with a number and a string, JavaScript decides to treat them both as strings and joins them together. If you check the type of the result with the `typeof` operator, you'd see it's indeed a string:

```js
const result = 5 + '10';

console.log(result); // 510
console.log(typeof result); // string
```

What do you think will happen if you switch the order of `5` and `'10'`?

```js
const result = '10' + 5;

console.log(result); // 105
console.log(typeof result); // string
```

You can see the same thing happened. JavaScript sees a string in `'10'` and a number in `5`, so it converts the number to a string and concatenates them. This is known as type coercion. Type coercion is when a value from one data type is converted into another.

Things get more interesting when you try to perform other arithmetic operations like subtraction, multiplication, or division with a string and number. In these cases, JavaScript tries to convert the string into a number before doing the math – another type coercion! Here's what happens:

```js
const subtractionResult = '10' - 5;
console.log(subtractionResult); // 5
console.log(typeof subtractionResult); // number

const multiplicationResult = '10' * 2;
console.log(multiplicationResult); // 20
console.log(typeof multiplicationResult); // number

const divisionResult = '20' / 2;
console.log(divisionResult); // 10
console.log(typeof divisionResult); // number
```

In the examples above, JavaScript successfully converts the string `'10'` or `'20'` to a number and then performs the calculation. As a result, `'10' - 5` yields `5`, `'10' * 2` gives `20`, and `'20' / 2` results in `10`.

But what if the string doesn't look like a number? Let's see what happens in that case:

```js
const subtractionResult = 'abc' - 5;
console.log(subtractionResult); // NaN
console.log(typeof subtractionResult); // number

const multiplicationResult = 'abc' * 2;
console.log(multiplicationResult); // NaN
console.log(typeof multiplicationResult); // number

const divisionResult = 'abc' / 2;
console.log(divisionResult); // NaN
console.log(typeof divisionResult); // number
```

In the examples above, the string `'abc'` does not represent a valid numeric value, so JavaScript cannot convert it into a meaningful number. When such conversion fails, JavaScript returns `NaN`, which stands for "Not a Number". `NaN` is a special value of the `Number` type that represents an invalid or unrepresentable number.

What if you perform arithmetic operations with a boolean (`true` or `false`)? Let's see what happens. JavaScript treats booleans as numbers in mathematical operations: `true` becomes `1`, and `false` becomes `0`.

```js
const result1 = true + 1;
console.log(result1); // 2
console.log(typeof result1); // number

const result2 = false + 1;
console.log(result2); // 1
console.log(typeof result2); // number

const result3 = 'Hello' + true;
console.log(result3); // "Hellotrue"
console.log(typeof result3); // string
```

In the first two examples, `true + 1` resulted in `2`, and `false + 1` resulted in `1`. In the third example, `'Hello' + true`, JavaScript converted `true` to a string and concatenates it with `'Hello'`, resulting in `'Hellotrue'`, which is a string.

For `null` and `undefined`, JavaScript treats `null` as `0` and `undefined` as `NaN` in mathematical operations:

```js
const result1 = null + 5;
console.log(result1); // 5
console.log(typeof result1); // number

const result2 = undefined + 5;
console.log(result2); // NaN
console.log(typeof result2); // number
```

JavaScript often performs type coercion, automatically converting data types such as numbers, strings, and booleans in sometimes unexpected ways. Understanding these conversions is crucial for avoiding bugs and writing robust code in your projects.


### Lecture Block: Lecture Working With Operator Behavior


## How Does Operator Precedence Work?

### Description

If you write an expression with several operators in JavaScript, how does JavaScript decide which one to evaluate first? This is where operator precedence comes in. Let's explore operator precedence in detail with code examples, and also what happens when operators have the same precedence.

Operator precedence determines the order in which operations are evaluated in an expression. Operators with higher precedence are evaluated before those with lower precedence. Think of operator precedence like in math, where division and multiplication happen before addition and subtraction.

Without following this rule, basic equations would give you the wrong answer. JavaScript works the same way. It has its own rules for which operators come first, second, and so on. For example, take a look at the expression below:

```js
const result = 2 + 3 * 4;

console.log(result); // 14
```

If JavaScript evaluated this expression from left to right, you'd expect `2 + 3 = 5`, then `5 * 4 = 20`. But because multiplication has a higher precedence than addition, JavaScript evaluates the `3 * 4` part first, resulting in `2 + 12 = 14`. 

Sometimes, you may want certain parts of your expression to run first, regardless of precedence rules. You can use parentheses, `()`, to do this. Anything inside parentheses is evaluated first, no matter what. Let's make the `2 + 3` part of the previous example evaluate first:

```js
const result = (2 + 3) * 4;

console.log(result); // 20
```

In the example above, the parentheses force JavaScript to evaluate `2 + 3` first, and then multiply the result by `4`. This gives you `20` instead of `14`.

The division operator has more precedence than addition or subtraction too:

```js
const result = 2 + 6 / 3;

console.log(result); // 4
```

If JavaScript evaluated this expression from left to right, you might expect `2 + 6 = 8`, then `8 / 3 = 2.67`. But since division has a higher precedence than addition, JavaScript evaluates the division first: `6 / 3 = 2`, and then adds `2 + 2`, giving the result `4`.

So, in both multiplication and division, those operations will always take place before addition and subtraction unless you use parentheses to change the order. So what happens if the operators have the same precedence? JavaScript uses associativity to figure out the order to evaluate them.

Associativity is what tells JavaScript whether to evaluate operators from left to right or right to left. For most operators like addition and multiplication, associativity is left to right. So, JavaScript processes these from the leftmost side of the expression to the right:

```js
const result = 10 - 2 + 3;

console.log(result); // 11
```

First, `10 - 2 = 8`, then `8 + 3 = 11`. JavaScript moves left to right in this case. Some operators, like assignment (`=`), are right-to-left associative. This means the right side of the expression gets evaluated first:

```js
let a, b;
a = b = 5;

console.log(a); // 5
console.log(b); // 5
console.log(a + b); // 10
```

In the example above, JavaScript assigns `5` to `b` first, then assigns `b` (which is now `5`) to `a`.

The exponent operator is also right-to-left associative:

```js
const result = 2 ** 3 ** 2;

console.log(result); // 512
```

First, JavaScript evaluates `3 ** 2`, which equals `9`, then, it evaluates `2 ** 9`, which equals `512`. If the exponent operator had left-to-right associativity, JavaScript would have calculated `2 ** 3` first to get `8`, then `8 ** 2` to get `64`.


## How Do the Increment and Decrement Operators Work?

### Description

If you're working with numbers and need to increase or decrease a value by one, the increment and decrement operators make the job easier. Let's break it down in a simple way.

The increment and decrement operators are represented by `++` and `--`, respectively. They both allow you to adjust the value of a variable by `1`.

Instead of writing something like `x = x + 1` or `x = x - 1`, you can simply use `x++` to add `1`, or `x--` to subtract `1`. It's faster, cleaner, and easier to read.

There's a twist to how the increment and decrement operators work: they come in two forms, prefix and postfix, with the difference being when the value gets updated. For the increment operator, prefix is `++x` and postfix is `x++`.

Prefix (`++x`) increases the value of the variable first, then returns a new value. Postfix (`x++`) returns the current value of the variable first, then increases it:

```js
let x = 5;

console.log(++x); // 6
console.log(x); // 6
```

In the code above, `++x` means "increment `x` first, then use it". So when you log `++x`, you immediately get the incremented value, which is `6`.

Now, let's take a look at an example using the postfix:

```js
let y = 5;

console.log(y++); // 5
console.log(y); // 6
```

In this example, `y++` means "use `y` first, then increment it". When you log `y++`, you get `5`, but `y` becomes `6` after that line of code.

The decrement operator does the same thing as increment, except it decreases the value by `1`. Again, there are two forms: prefix (`--x`) decreases the value of the variable first, then returns the new value. And postfix (`x--`) returns the current value first, then decreases it:

```js
let x = 5;
console.log(--x); // 4
console.log(x); // 4

let y = 5;
console.log(y--); // 5
console.log(y); // 4
```

So, which should you use: prefix or postfix? In many cases, it doesn't matter which one you use. Both get the job done. However, if you're using the value immediately in an expression, the difference becomes important. Let's take a look at this example:

```js
let a = 5;
let b = ++a;
console.log(b); // 6 (a was incremented before assignment)

let c = 5;
let d = c++;
console.log(d); // 5 (c was incremented after assignment)
```

So, if you need the updated value right away, use prefix. If you want the current value first and you don’t care about the increment until later, go with postfix.


## What Are Compound Assignment Operators in JavaScript, and How Do They Work?

### Description

In JavaScript, all arithmetic operators have a compound assignment form. Compound assignment operators allow you to perform a mathematical operation and reassign the result back to the variable in one line of code. Instead of writing something like this:

```js
let num = 5;
num = num + 2;

console.log(num); // 7
```

You can write something like this:

```js
let num = 5;
num += 2;

console.log(num); // 7
```

Notice how `num += 2` combines both the addition and assignment steps into one. This saves time and reduces clutter in your code. Let's dive deeper into the most common compound assignment operators in JavaScript.

As you've already seen, the `+=` operator lets you add a value to an existing variable. It is known as the addition assignment operator. The addition assignment operator takes the current value of the variable, adds the specified number to it, and then assigns the result back to the variable:

```js
let total = 10;
total += 5;

console.log(total); // 15
```

As you might guess, there's a subtraction assignment operator denoted by `-=`. The subtraction assignment operator subtracts the specified value from the current value of the variable and assigns the new value back to the variable:

```js
let score = 20;
score -= 7;

console.log(score); // 13
```

If you didn't use the subtraction assignment, you'd have done something like this:

```js
let score = 20;
score = score - 7;

console.log(score); // 13
```

The multiplication assignment operator is represented by `*=`. It multiplies the current value of the variable by the specified number and reassigns it back to the variable:

```js
let points = 5;
points *= 3;

console.log(points); // 15
```

Lastly, there's a division assignment operator denoted by `/=`. Just like others before it, it lets you divide the current value of a variable by a number you specify, then assign the result back to the variable:

```js
let balance = 100;
balance /= 4;

console.log(balance); // 25
```

Remember there's a compound assignment operator for every operator in JavaScript. So, apart from the four already mentioned, we also have:

- Remainder assignment operator (`%=`), which divides a variable by the specified number and assigns the remainder to the variable.

- Exponent assignment operator (`**=`), which raises a variable to the power of the specified number and reassigns the result to the variable.

- Bitwise AND assignment operator (`&=`), which performs a bitwise AND operation with the specified number and reassigns the result to the variable.

- Bitwise OR assignment operator (`|=`), which performs a bitwise OR operation with the specified number and reassigns the result to the variable.


### Lecture Block: Lecture Working With Comparison And Boolean Operators


## What Are Booleans, and How Do They Work with Equality and Inequality Operators?

### Description

In an earlier lecture, you were first introduced to the concept of booleans, but in this lecture, we will dive deeper into how booleans work and how the equality and inequality operators work.

Booleans are a data type with only `true` and `false` values. They're useful because they allow you to do something based on some conditions. Booleans are essential when you want to evaluate whether something should happen or not, like deciding if someone can access a certain feature in your app. Here is an example of setting the value `true` to a variable called `isOldEnoughToDrive`:

```js
let isOldEnoughToDrive = true;

console.log(isOldEnoughToDrive); // true
```

You can use this variable inside a conditional like this:

```js
let isOldEnoughToDrive = true;

if (isOldEnoughToDrive) {
 console.log("You're old enough to drive"); // You're old enough to drive
} else {
 console.log("Sorry, you are not old enough to drive");
}
```

A conditional helps you make decisions in your code based on a condition. This example uses what is called an `if/else` statement.

If `isOldEnoughToDrive` is `true`, then the sentence `You're old enough to drive` will be logged to the console. Otherwise, if the `isOldEnoughToDrive` is `false`, then the sentence `Sorry, you are not old enough to drive` will be logged to the console. Since the `isOldEnoughToDrive` variable is set to `true`, the first sentence will be logged to the console. You will learn more about `if/else` statements in a future lecture.

To compare two values, you can use either the equality or strict equality operator. The result of the comparison will be a boolean of either `true` or `false`. Here is an example of using the equality operator to compare a string and a number. The equality operator is represented by a double equals sign (`==`).

```js
console.log(5 == "5"); // true
```

In this example, JavaScript converts the string `"5"` into the number `5` and then checks if they are equal. Since both values are now the same, the result is true. The equality operator uses type coercion before checking if each value is equal.

This differs from the strict equality operator, which does not perform type coercion. The strict equality operator will check if the types are the same and if the values are the same. Here is an example using the strict equality operator to compare a number and string. This operator is represented by a triple equals sign (`===`).

```js
console.log(5 === '5'); // false
```

The following comparison will be `false`, because a string data type is not the same as a number data type. If you need to check if something is not equal to another value, then you can use the inequality or strict inequality operators. Here is an example of using the inequality operator (`!=`) to compare a number with a string. 

```js
console.log(5 != "5"); // false
```

In this example, the result would be `false` because the inequality operator first converts the string value to a number and then compares the values. Since the values would be the same it will return `false`. If you tried to use the strict inequality operator, then you would get a different result. The strict inequality operator is represented by an exclamation mark followed by two equal signs (`!==`).

```js
console.log(5 !== "5"); // true
```

The result would be `true` because the strict inequality operator does not perform any type coercion. Since the number `5` is not equal to the string `"5"`, then the result is `true`.

It is considered best practice to use strict inequality and equality operators whenever possible, as they do not perform type coercion. Most of the time in professional projects, you will see codebases that usually prefer these two operators over the inequality and equality operators.


## What Are Comparison Operators, and How Do They Work?

### Description

Comparison operators allow you to compare two values and return a `true` or `false` result. You can then use the result to make a decision or control the flow of your program. You use comparisons in `if` statements, loops, and many other situations where you need to make decisions based on certain conditions. Let's dive into the most common comparison operators and see how they work.

The greater than operator, represented by a right-angle bracket (`>`), checks if the value on the left is greater than the one on the right:

```js
let a = 6;
let b = 9;

console.log(a > b); // false
console.log(b > a); // true
```

The greater than or equal operator, represented by a right-angle bracket and the equals sign (`>=`), checks if the value on the left is either greater than or equal to the one on the right:

```js
let a = 6;
let b = 9;
let c = 6;

console.log(a >= b); // false
console.log(b >= a); // true
console.log(a >= c); // true
```

The lesser than operator, represented by a left-angle bracket (`<`) works similarly to `>`, but in reverse. It checks if the value on the left is smaller than the one on the right:

```js
let a = 6;
let b = 9;

console.log(a < b); // true
console.log(b < a); // false
```

The less than or equal operator, represented by a left-angle bracket and the equals sign (`<=`) checks if the value on the left is smaller than or equal to the one on the right:

```js
let a = 6;
let b = 9;
let c = 6;

console.log(a <= b); // true
console.log(b <= a); // false
console.log(a <= c); // true
```


### Lecture Block: Lecture Working With Unary And Bitwise Operators


## What Are Unary Operators, and How Do They Work?

### Description

Unary operators act on a single operand to perform operations like type conversion, value manipulation, or checking certain conditions. Let's look at some common unary operators and how they work.

The unary plus operator converts its operand into a number. If the operand is already a number, it remains unchanged.

```js
const str = '42';
const strToNum = +str;

console.log(strToNum); // 42
console.log(typeof str); // string
console.log(typeof strToNum); // number
```

Unary plus is handy when you want to make sure you're working with a numeric value. As you might guess, there's a unary negation operator. It negates the value of the operand. It works similarly to the unary plus, except it flips the sign.

```js
const str = '42';
const strToNegativeNum = -str;

console.log(strToNegativeNum); // -42
console.log(typeof str); // string
console.log(typeof strToNegativeNum); // number
```

The logical NOT operator, represented by an exclamation mark (`!`), is another unary operator. It flips the boolean value of its operand. So, if the operand is `true`, it becomes `false`, and if it's `false`, it becomes `true`. 

```js
let isOnline = true;
console.log(!isOnline); // false

let isOffline = false;
console.log(!isOffline); // true
```

The bitwise NOT operator is a less commonly used unary operator. Represented by a tilde, `~`, it inverts the binary representation of a number. Computers store numbers in binary format (1s and 0s). The `~` operator flips every bit, meaning it changes all 1s to 0s and all 0s to 1s. You will learn more about binary and bits in a future lecture.

```js
const num = 5; // The binary for 5 is 00000101

console.log(~num); // -6
```

In this example, `5` became `-6` because by applying the `~` operator to `5`, you get `- (5 + 1)`, which equals `-6` due to two's complement representation. Two's complement is a way computers represent negative numbers in binary. You probably won't use the bitwise NOT often unless you're working with low-level programming tasks like manipulating bits directly.

The `void` keyword is a unary operator that evaluates an expression and returns `undefined`.

```js
const result = void (2 + 2);

console.log(result); // undefined
```

`void` is also commonly used in hyperlinks to prevent navigation:

```js
<a href="javascript:void(0);">Click Me</a>
```

Finally, there is the `typeof` operator which you learned about in previous lectures. This returns the type of its operand as a string. 

```js
const value = 'Hello world';

console.log(typeof value); // string
```


## What Are Bitwise Operators, and How Do They Work?

### Description

Bitwise operators in JavaScript are special operators that work on the binary representations of numbers. To understand bitwise operators, we first need to grasp the concept of bits and binary numbers. In computing, a bit is the most basic unit of information. It can have only two values: `0` or `1`. Binary is a number system that uses only these two digits to represent all numbers. 

For example, the binary representation of the decimal number `10` is `1010`. In this system, each digit represents a power of `2`, starting from the rightmost digit and increasing as we move left. 

<table>
  <tr>
    <td>1</td>
    <td>0</td>
    <td>1</td>
    <td>0</td>
  </tr>
  <tr>
    <td>1 · 2<sup>3</sup></td>
    <td>0 · 2<sup>2</sup></td>
    <td>1 · 2<sup>1</sup></td>
    <td>0 · 2<sup>0</sup></td>
  </tr>
  <tr>
    <td>8</td>
    <td>0</td>
    <td>2</td>
    <td>0</td>
  </tr>
<table>

In the table above, the first row shows the binary number `1010`, the second row shows the power of `2` represented by each binary position, and the third row shows the result of each multiplication. If you add all the values in the third row, they total `10`.

Now, let's dive into bitwise operators. These operators perform operations on the binary representations of numbers. JavaScript provides several bitwise operators, including AND (`&`), OR (`|`), XOR (`^`), NOT (`~`), left shift (`<<`), and right shift (`>>`).

The bitwise AND (`&`) operator returns a `1` in each bit position for which the corresponding bits of both operands are `1`. Here's an example:

```js
let a = 5;  // Binary: 101
let b = 3;  // Binary: 011
console.log(a & b);  // Output: 1 (Binary: 001)
```

In this example, we perform a bitwise AND operation on `5` (`101` in binary) and `3` (`011` in binary). The result is `1` (`001` in binary) because only the rightmost bit is `1` in both numbers.

The bitwise OR (`|`) operator returns a `1` in each bit position for which the corresponding bits of either or both operands are `1`. For example:

```js
let a = 5;  // Binary: 101
let b = 3;  // Binary: 011
console.log(a | b);  // Output: 7 (Binary: 111)
```

Here, the result is `7` (`111` in binary) because at least one of the bits is `1` in each position.

The bitwise XOR (`^`) operator returns a `1` in each bit position for which the corresponding bits of either, but not both, operands are `1`. For instance:

```js
let a = 5;  // Binary: 101
let b = 3;  // Binary: 011
console.log(a ^ b);  // Output: 6 (Binary: 110)
```

The result is `6` (`110` in binary) because the first and second bits from the right are different in the two numbers.

The bitwise NOT (`~`) operator inverts all the bits of its operand. For example:

```js
let a = 5;  // Binary: 101
console.log(~a);  // Output: -6
```

This might seem surprising, but it's because of how negative numbers are represented in binary using two's complement.

The left shift (`<<`) operator shifts all bits to the left by a specified number of positions. For example:

```js
let a = 5;  // Binary: 101
console.log(a << 1);  // Output: 10 (Binary: 1010)
```

Here, all bits are shifted one position to the left, effectively multiplying the number by `2`.

The right shift (`>>`) operator shifts all bits to the right. For example:

```js
let a = 5;  // Binary: 101
console.log(a >> 1);  // Output: 2 (Binary: 10)
```

Here, all bits are shifted one position to the right, effectively dividing the number by `2` and rounding down.

Bitwise operators are often used in low-level programming and cryptography. While they may not be as commonly used in everyday JavaScript programming, understanding them can be beneficial for certain specialized tasks and can deepen your understanding of how computers work at a fundamental level.


### Lecture Block: Lecture Working With Conditional Logic And Math Methods


## What Are Conditional Statements, and How Do If/Else If/Else Statements Work?

### Description

Conditional statements let you make decisions in your JavaScript code. They allow your program to flow in a particular way based on certain conditions. Let's take a look at how `if`, `else if`, `else`, and the ternary operator work to let you control the flow of your code.

An `if` statement takes a condition and runs a block of code if that condition is truthy. Truthy values are any values that result in `true` when evaluated in a Boolean context like an `if` statement. Here are examples of truthy values:

- non-empty strings, for example, `hello`

- any number other than `0` and `-0`, for example, `4`, `-5`, and others

- arrays

- objects

- the boolean `true`

On the other hand, falsy values are values that evaluate to `false` in a boolean context. JavaScript has few falsy values, which makes them easy to remember. Here are a few falsy values:

- boolean `false`

- `0` (zero)

- `""` (empty string)

- `null`

- `undefined`

- `NaN` (Not a Number)

Now, that we have a basic understanding of truthy and falsy values, let's see how it works with `if` statements. In this first example, we are using a couple of `if` statements to check against truthy and falsy values:

```js
if (null) {
  console.log("This will not run.");
}

if ("freeCodeCamp") {
  console.log("This will run.");
}
```

Since `null` is a falsy value, the message inside the block will never be logged to the console. But for the second `if` statement, the string `freeCodeCamp` is a truthy value, and will be considered `true` in this boolean context of the `if` statement. As a result, the message `This will run.` will be logged to the console.

Let's take a look at a few more examples on how `if` statements work with different comparison operators. Here is an example of using an `if` statement to check if the user is eligible to vote: 

```js
const age = 22;

if (age >= 18) {
 console.log("You're eligible to vote"); // You're eligible to vote
}
```

In this example, since `age` is currently `22`, this means the condition will evaluate to `true` because `22` is greater than or equal to `18`. So the message `You're eligible to vote` will be logged to the console. If we change the example so `age` is now `15`, then the condition will evaluate to `false` and the message will not be logged to the console:

```js
const age = 15;

if (age >= 18) {
 console.log("You're eligible to vote"); // Code not running because age is less than 18
}
```

When a condition is `false`, then you can use an `else` clause:

```js
const age = 15;

if (age >= 18) {
 console.log("You're eligible to vote");
} else {
 console.log("You're not eligible to vote"); // You're not eligible to vote
}
```

In this example, `15` is not greater than or equal to `18`, so the condition would be `false`. The code inside the `else` block will run in this case.

If you want to check multiple conditions, you can use an `else if` block. This allows your program to choose between more than two paths.

```js
const score = 87;

if (score >= 90) {
 console.log('You got an A'); 
} else if (score >= 80) {
 console.log('You got a B'); // You got a B
} else if (score >= 70) {
 console.log('You got a C');
} else {
 console.log('You failed! You need to study more!');
}
```

Since the `score` is currently `87`, then the message of `You got a B` would be logged to the console.

The ternary operator is a compact way to write simple `if/else` statements. It has three parts: a condition, a result if the condition is true, and a result if it is false. Here's the basic syntax:

```js
condition ? expressionIfTrue : expressionIfFalse;
```

Here's an example dealing with weather temperatures in Celsius: 

```js
const weather = temperature > 25 ? 'sunny' : 'cool';

console.log(`It's a ${weather} day!`);
```

If `temperature` is greater than `25`, the code above logs `It's a sunny day!`. If `temperature` is ever less than `25`, it logs `It's a cool day!`.

So, which should you use between an if statement and a ternary? Use a ternary while dealing with a single condition or single expressions, or when you want a compact syntax for simple logic. Use `if/else` statements when you're dealing with complex conditions and multiple statements, as things become unreadable if you nest ternaries.


## What Are Binary Logical Operators, and How Do They Work?

### Description

Binary logical operators help you evaluate two expressions and return a result based on their truthiness. Let's look at the three most common binary logical operators: logical AND, logical OR, and the nullish coalescing operator.

The logical AND operator is represented by a double ampersand (`&&`). It checks if both operands are true and returns a result. If both operands are truthy, it returns the second value, that is, the one on the right:

```js
const result = true && 'hello';

console.log(result); // hello
```

In the example above, the text `hello` is logged to the console because both operands are `true`. If either operand is falsy, it returns the falsy value:

```js
const result = 0 && 3;

console.log(result); // 0
```

Since `0` is a falsy value, the number `0` is logged to the console. And if both operands are falsy, it returns the first falsy value:

```js
const result = false && 0;

console.log(result); // false
```

Since `false` is a falsy value, then `false` is logged to the console. The logical AND operator is useful when you want to check multiple conditions and ensure that all are true before proceeding. Here is an example:

```js
if (2 < 3 && 3 < 4) {
 console.log('The if block runs'); 
} else {
 console.log('The else block runs');
} 
```

In the condition, since `2` is less than `3` AND `3` is less than `4`, then the sentence `The if block runs` will be logged to the console.

The logical OR operator checks if at least one of the operands is truthy. If the first operand is truthy, it returns that value:

```js
const result = 'This is truthy' || false;

console.log(result); // This is truthy
```

If the first operand is falsy but the second is truthy, the second value will be logged to the console:

```js
const result = 0 || 'This is truthy';

console.log(result); // This is truthy
```

It is common to use the logical OR operator in `if/else` statements like this:

```js
let userInput;

if (userInput || 'Guest') {
 console.log('A user is present');
} else {
 console.log('No user detected');
}
```

Since we didn't assign a value to the `userInput` variable, it is currently `undefined`. The condition in the `if` statement checks if either the `userInput` variable or the string `Guest` are truthy. Since the string `Guest` is true in a boolean context like this, the string `A user is present` will be logged to the console.

The nullish coalescing operator is more sophisticated than logical OR and logical AND. Represented by a double question mark (`??`), it helps in scenarios where you want to return a value only if the first one is `null` or `undefined`. Here is an example of working with the nullish coalescing operator:

```js
const result = null ?? 'default';

console.log(result); // default
```

Since `null` is a falsy value, the string `default` would be logged to the console. The nullish coalescing operator is incredibly useful in situations where `null` or `undefined` are the only values that should trigger a fallback or default value. Here is an example of dealing with a user's preference settings:

```js
const userSettings = {
 theme: null,
 volume: 0,
 notifications: false,
};

let theme = userSettings.theme ?? 'light';
console.log(theme); // light
```

In the example above, we have an object called `userSettings` that contains `theme`, `volume` and `notifications` properties. We are accessing the `theme` using dot notation like `userSettings.theme`. You will learn more about how to work with objects in a future lecture. Since the user's `theme` is currently set to `null`, then the string `light` will be logged to the console.


## What Is the Math Object in JavaScript, and What Are Some Common Methods?

### Description

When diving into JavaScript, you'll quickly discover that performing mathematical operations is a common task. While basic arithmetic operators can handle simple calculations, JavaScript offers a built-in `Math` object to tackle more complex math challenges. 

This handy tool provides a variety of methods that make it easier to perform advanced calculations and manipulate numbers. Let's explore these methods and see how they can simplify your coding experience.

The `Math.random()` method generates a random floating-point number between `0` (inclusive) and `1` (exclusive). This means the possible output can be `0`, but it will never actually reach `1`. Here is an example working with the `Math.random()` method:

```js
const randomNum = Math.random();

console.log(randomNum); 
// any number between 0 and 1 – 0 inclusive and 1 exclusive
```

`Math.min()` and `Math.max()` both take a set of numbers and return the minimum and maximum value, respectively. Here is an example of working both of those methods:

```js
const smallest = Math.min(1, 5, 3, 9);
console.log(smallest); // 1

const largest = Math.max(1, 5, 3, 9);
console.log(largest); // 9
```

The first `console.log()` will log the number `1`, since `1` is the smallest in that list of numbers. And the second `console.log()` will log the number `9`, since `9` is the largest numbers in that list.

If you wanted to round numbers up or down to the nearest whole integer, you could use the `Math.ceil()` and `Math.floor()` methods.  Here is an example of working with `Math.ceil()`:

```js
console.log(Math.ceil(4.3)); // 5
```

`Math.ceil()` will round `4.3` up to the nearest whole integer, which is `5` in this case. Now, let's take a look at rounding a number down:

```js
console.log(Math.floor(4.7)); // 4
```

`Math.floor()` will round `4.7` down to the nearest whole integer, which is `4` in this case. `Math.round()` is the hybrid of `Math.ceil()` and `Math.floor()`. It rounds a number to its nearest integer, taking the decimal point into account:

```js
console.log(Math.round(2.3)); // 2
console.log(Math.round(4.5)); // 5
console.log(Math.round(4.8)); // 5
```

So, if the decimal point is less than `5`, the number is rounded down. And if the decimal point is `5` or greater, the number is rounded up. A practical application of `Math.floor()` and `Math.random()` is to generate a random number between two whole numbers. Here's the syntax for that:

```js
Math.floor(Math.random() * (max - min)) + min;
```

Generating a random number between `20` and `1` would look like this:

```js
const randomNumBtw1And20 = Math.floor(Math.random() * 20) + 1;
console.log(randomNumBtw1And20); 
```

Another helpful `Math` method would be the `Math.trunc()` method. `Math.trunc()` removes the decimal part of a number, returning only the integer portion, without rounding:

```js
console.log(Math.trunc(2.9)); // 2
console.log(Math.trunc(9.1)); // 9
```

If you need to get the square root or cube root of a number, you can use the `Math.sqrt()` and `Math.cbrt()` methods, respectively:

```js
console.log(Math.sqrt(81)); // 9
console.log(Math.cbrt(27)); // 3
```

The first log statement, will log `9` because the square root of `81` is `9`, while the second log statement will log `3` because the cube root of `27` is `3`. If you need to get the absolute value of a number, you can use the `Math.abs()` method:

```js
console.log(Math.abs(-5)); // 5
console.log(Math.abs(5)); // 5
```

`Math.abs()` returns the absolute value of a number, turning negatives into positives. The last method we will look at will be the `Math.pow()` method:

```js
console.log(Math.pow(2, 3)); // 8
console.log(Math.pow(8, 2)); // 64
```

`Math.pow()` takes two numbers and raise the first to the power of the second. There are many more methods that belong to the `Math` object, that you can explore on your own. However, these are just a few of the more commonly used ones found in JavaScript codebases.


### Lecture Block: Lecture Working With Numbers And Common Number Methods


## How Does isNaN Work?

### Description

In JavaScript, `NaN` stands for "Not a Number". It's a special value that represents an unrepresentable or undefined numerical result. `NaN` is a property of the global object, and it's also considered a type of number in JavaScript, which might seem counterintuitive at first.

`NaN` is typically the result of operations that should return a number but can't produce a meaningful numerical value. For example:

```js
let result = 0 / 0;
console.log(result); // Output: NaN
```

In this case, dividing zero by zero is mathematically undefined, so JavaScript returns `NaN`. One peculiar property of `NaN` is that it's not equal to anything, including itself:

```js
console.log(NaN === NaN); // Output: false
```

This unique behavior makes it challenging to check if a value is `NaN` using standard comparison operators. To address this, JavaScript provides the `isNaN()` function. The `isNaN()` function property is used to determine whether a value is `NaN` or not. However, it's important to understand how `isNaN()` works, as it can sometimes produce unexpected results. Here's how `isNaN()` behaves:

```js
console.log(isNaN(NaN));       // true
console.log(isNaN(undefined)); // true
console.log(isNaN({}));        // true

console.log(isNaN(true));      // false
console.log(isNaN(null));      // false
console.log(isNaN(37));        // false

console.log(isNaN("37"));      // false: "37" is converted to 37
console.log(isNaN("37.37"));   // false: "37.37" is converted to 37.37
console.log(isNaN(""));        // false: empty string is converted to 0
console.log(isNaN(" "));       // false: string with a space is converted to 0

console.log(isNaN("blabla"));  // true: "blabla" is not a number
```

As you can see, `isNaN()` first attempts to convert the parameter to a number. If it can't be converted, it returns `true`. This behavior can lead to some surprising results, especially when dealing with strings that can be coerced into numbers.

Due to these potential inconsistencies, ES6 introduced `Number.isNaN()`. This method does not attempt to convert the parameter to a number before testing. It only returns `true` if the value is exactly `NaN`:

```js
console.log(Number.isNaN(NaN));        // true
console.log(Number.isNaN(Number.NaN)); // true
console.log(Number.isNaN(0 / 0));      // true

console.log(Number.isNaN("NaN"));      // false
console.log(Number.isNaN(undefined));  // false
console.log(Number.isNaN({}));         // false
console.log(Number.isNaN("blabla"));   // false
```

`Number.isNaN()` provides a more reliable way to check for `NaN` values, especially in cases where type coercion might lead to unexpected results with the global `isNaN()` function. In practice, when dealing with numerical operations or user inputs that should be numbers, it's often necessary to check for `NaN` to handle errors or unexpected inputs gracefully. For example:

```js
function divide(a, b) {
  let result = a / b;
  if (Number.isNaN(result)) {
    return "Error: Division resulted in NaN";
  }
  return result;
}

console.log(divide(10, 2));  // 5
console.log(divide(10, 0));  // Infinity
console.log(divide(0, 0));   // "Error: Division resulted in NaN"
```

In this example, we're using `Number.isNaN()` to catch cases where the division operation results in `NaN`, allowing us to handle this scenario appropriately. Understanding `NaN` and how to properly check for it is crucial for writing robust JavaScript code, especially when dealing with mathematical operations or parsing user inputs.


## How Do the parseFloat() and parseInt() Methods Work?

### Description

`parseFloat()` and `parseInt()` are two essential methods in JavaScript for converting strings to numbers. These methods are particularly useful when dealing with user input or processing data that comes in string format but needs to be treated as numerical values.

Let's start with `parseFloat()`. This method parses a string argument and returns a floating-point number. It's designed to extract a number from the beginning of a string, even if the string contains non-numeric characters later on. Remember that floats are numbers with decimal points. Here's how `parseFloat()` works:

```js
console.log(parseFloat("3.14"));     // Output: 3.14
console.log(parseFloat("3.14 abc")); // Output: 3.14
console.log(parseFloat("3.14.5"));   // Output: 3.14
console.log(parseFloat("abc 3.14")); // Output: NaN
```

As you can see, `parseFloat()` starts parsing from the beginning of the string and continues until it encounters a character that can't be part of a floating-point number. If it can't find a valid number at the start of the string, it returns `NaN` (Not a Number).

`parseInt()`, on the other hand, parses a string argument and returns an integer. Like `parseFloat()`, it starts from the beginning of the string, but it stops at the first non-digit character. Here's how `parseInt()` works:

```js
console.log(parseInt("42"));       // Output: 42
console.log(parseInt("42px"));     // Output: 42
console.log(parseInt("3.14"));     // Output: 3
console.log(parseInt("abc123"));   // Output: NaN
```

`parseInt()` stops parsing at the first non-digit it encounters. For floating-point numbers, it returns only the integer part. If it can't find a valid integer at the start of the string, it returns `NaN`.

Both methods have some noteworthy behaviors. They ignore leading whitespace:

```js
console.log(parseFloat("  3.14"));  // Output: 3.14
console.log(parseInt("  42"));      // Output: 42
```

They handle plus and minus signs at the beginning of the string:

```js
console.log(parseFloat("+3.14"));  // Output: 3.14
console.log(parseInt("-42"));      // Output: -42
```

It's worth noting that while these methods are powerful, they have some limitations. For instance, they don't handle all number formats, such as scientific notation, directly. For more complex parsing needs, you might need to use additional techniques or libraries.

In conclusion, `parseFloat()` and `parseInt()` are valuable tools for converting strings to numbers in JavaScript. Understanding how they work and their specific behaviors allows you to handle numeric data more effectively in your applications, especially when dealing with user inputs or external data sources.


## What Is the toFixed() Method, and How Does It Work?

### Description

The `.toFixed()` method is a built-in JavaScript function that formats a number using fixed-point notation. It's particularly useful when you need to control the number of decimal places in a number, especially for displaying currency values or when working with precise measurements. 

The `.toFixed()` method is called on a number and takes one optional argument, which is the number of digits to appear after the decimal point. It returns a string representation of the number with the specified number of decimal places. Here's a basic example of how `.toFixed()` works:

```js
let num = 3.14159;
console.log(num.toFixed(2)); // Output: "3.14"
```

In this case, we're limiting the number of decimal places to two. So, `3.14159` becomes `3.14`. It's important to note that `.toFixed()` returns a string, not a number. This is because the method is primarily intended for formatting numbers for display, not for further calculations.

The `.toFixed()` method rounds the number to the nearest value that can be represented with the specified number of decimal places. This rounding behavior is important to understand:

```js
console.log((3.14159).toFixed(3));  // Output: "3.142"
console.log((3.14449).toFixed(3));  // Output: "3.144"
console.log((3.14550).toFixed(3));  // Output: "3.146"
```

As you can see, `.toFixed()` rounds up when the next digit is `5` or greater, and rounds down otherwise. If you call `.toFixed()` without arguments, it defaults to `0` decimal places:

```js
let num = 3.14159;
console.log(num.toFixed()); // Output: "3"
```

The `.toFixed()` method can be particularly useful when working with financial calculations or displaying prices:

```js
let price = 19.99;
let taxRate = 0.08;
let total = price + (price * taxRate);

console.log("Total: $" + total.toFixed(2)); // Output: "Total: $21.59"
```

In this example, `.toFixed(2)` ensures that the total is always displayed with two decimal places, which is standard for currency in many countries.

In conclusion, the `.toFixed()` method is a powerful tool for formatting numbers in JavaScript, particularly when you need to control the display of decimal places. While it's primarily used for formatting output, remember its behavior, especially when precise calculations are needed.


### Lecture Block: Lecture Understanding Comparisons And Conditionals


## How Do Comparisons Work with Null and Undefined Data Types?

### Description

In JavaScript, `null` and `undefined` are two distinct data types that represent the absence of a value, but they behave differently in comparisons. Understanding how these types interact in various comparison scenarios is crucial for writing robust and bug-free code.

Let's start with the `undefined` type. A variable is `undefined` when it has been declared but hasn't been assigned a value. It's the default value of uninitialized variables and function parameters that weren't provided an argument.

The `null` type, on the other hand, is an assignment value that represents a deliberate non-value. It's often used to indicate that a variable intentionally has no value.

When comparing `null` and `undefined` using the equality operator (`==`), JavaScript performs type coercion. This means it tries to convert the operands to the same type before making the comparison. In this case, `null` and `undefined` are considered equal:

```js
console.log(null == undefined); // true
```

However, when using the strict equality operator (`===`), which checks both value and type without performing type coercion, `null` and `undefined` are not equal:

```js
console.log(null === undefined); // false
```

This difference is important to keep in mind when writing conditional statements or performing equality checks in your code. When comparing `null` or `undefined` with other values using the equality operator (`==`), the behavior can be unexpected. For example:

```js
console.log(null == 0);  // false
console.log(null == ''); // false
console.log(undefined == 0); // false
console.log(undefined == ''); // false
```

These comparisons return `false` because `null` and `undefined` are only equal to each other (and themselves) when using the equality operator. The behavior of `null` in other comparisons is particularly tricky:

```js
console.log(null > 0);  // false
console.log(null == 0); // false
console.log(null >= 0); // true
```

`undefined`, on the other hand, always converts to `NaN` in numeric contexts, which makes all numeric comparisons with `undefined` return `false`:

```js
console.log(undefined > 0);  // false
console.log(undefined < 0);  // false
console.log(undefined == 0); // false
```

Given these nuances, it's generally recommended to use the strict equality operator when comparing values, especially when dealing with `null` and `undefined`. This approach helps avoid unexpected type coercion and makes your code's behavior more predictable.

In summary, while `null` and `undefined` are both used to represent the absence of a value, they behave differently in comparisons. Understanding these differences is key to writing clear and error-free JavaScript code.


## What Are Switch Statements and How Do They Differ from If/Else Chains?

### Description

`switch` statements and `if/else if/else` chains are both control flow structures in programming that allow us to execute different code blocks based on certain conditions. However, they have distinct characteristics and use cases.

A `switch` statement evaluates an expression and matches its value against a series of `case` clauses. When a match is found, the code block associated with that `case` is executed. Here's a basic structure of a `switch` statement:

```js
switch (expression) {
  case value1:
    // code to be executed if expression === value1
    break;
  case value2:
    // code to be executed if expression === value2
    break;
  default:
    // code to be executed if expression doesn't match any case
}
```

The `break` statement at the end of each `case` is crucial. It tells the program to exit the switch block once a matching `case` has been executed. Without it, the program would continue executing subsequent cases, a behavior known as "fall-through".

`switch` statements are typically used when you're comparing a single variable against multiple possible values. They're especially useful when you have many potential conditions to check against a single variable. Here is an example using a `switch` statement for the days of the week:

```js
let dayOfWeek = 3; 

switch (dayOfWeek) {
    case 1:
        console.log("It's Monday! Time to start the week strong.");
        break;
    case 2:
        console.log("It's Tuesday! Keep the momentum going.");
        break;
    case 3:
        console.log("It's Wednesday! We're halfway there.");
        break;
    case 4:
        console.log("It's Thursday! Almost the weekend.");
        break;
    case 5:
        console.log("It's Friday! The weekend is near.");
        break;
    case 6:
        console.log("It's Saturday! Enjoy your weekend.");
        break;
    case 7:
        console.log("It's Sunday! Rest and recharge.");
        break;
    default:
        console.log("Invalid day! Please enter a number between 1 and 7.");
}
```

`switch` statements can be more readable and concise when dealing with many possible values for a single variable. 

`if/else if` statements on the other hand are more flexible. They can evaluate complex conditions and different variables in each clause. This makes them suitable for a wider range of scenarios. Here is an example of when you might use an `if/else` statement over a `switch` statement:

```js
let creditScore = 720; 
let annualIncome = 60000; 
let loanAmount = 200000; 

let eligibilityStatus;

if (creditScore >= 750 && annualIncome >= 80000) {
    eligibilityStatus = "Eligible for premium loan rates.";
} else if (creditScore >= 700 && annualIncome >= 50000) {
    eligibilityStatus = "Eligible for standard loan rates.";
} else if (creditScore >= 650 && annualIncome >= 40000) {
    eligibilityStatus = "Eligible for subprime loan rates.";
} else if (creditScore < 650) {
    eligibilityStatus = "Not eligible due to low credit score.";
} else {
    eligibilityStatus = "Not eligible due to insufficient income.";
}

console.log(eligibilityStatus);
```

In this example, we have a person’s annual income and credit score and checking what types of loan they would qualify for. Since we are dealing with more complex logical evaluations and multiple variables, it is better to use an `if/else` statement here versus a `switch` statement.

It's worth noting that `switch` statements in JavaScript use strict comparison (`===`), which means they don't perform type coercion. This can be an advantage in terms of predictability and avoiding subtle bugs.

In summary, while both `switch` statements and `if/else if` chains allow for multiple-branch logic in your code, they have different strengths. `switch` statements excel at handling multiple possible values for a single variable, while `if/else if` chains offer more flexibility for complex conditions. The choice between them often comes down to the specific requirements of your code and personal or team coding style preferences.


## Module: Javascript Functions


### Lecture Block: Lecture Working With Functions


## What Is the Purpose of Functions, and How Do They Work?

### Description

Functions are reusable pieces of code that perform a specific task or calculate a value. Think of functions as a machine that takes some input, does some operations on it, and then produces an output. Here is an example of declaring a function:

```js
function greet() {
  console.log("Hello, Jessica!");
}
```

In this example, we have declared a function called `greet`.  Inside that function, we have a `console.log` that logs the message `Hello, Jessica!`. If we tried to run this code, we would not see the message appear in the console. This is because we need to call the function.

A function call, or invocation, is when we actually use or execute the function. To call a function, you will need to reference the function name followed by a set of parentheses:

```js
function greet() {
  console.log("Hello, Jessica!");
}

greet(); // "Hello, Jessica!"
```

Now the message of `Hello, Jessica!` will be logged to the console. But what if we wanted the message to say `Hello, Nick!` or `Hello, Anna!`? We don't want to write a new function each time we greet a different user. Instead, we can create a reusable function that uses function parameters and arguments. 

Parameters act as placeholders for the values that will be passed to the function when it is called. They allow functions to accept input and work with that input. Arguments are the actual values passed to the function when it is called. Here is an updated version of the `greet` function that uses parameters and arguments:

```js
function greet(name) {
  console.log("Hello, " + name + "!");
}

greet("Alice"); // Hello, Alice!
greet("Nick"); // Hello, Nick!
```

The `name` serves as the parameter while the strings `Alice` and `Nick` serve as the arguments. Now we have a reusable function that can be used dozens of times throughout our code with different arguments. 

When a function finishes its execution, it will always return a value. By default, the return value will be `undefined`. Here is an example: 

```js
function doSomething() {
    console.log("Doing something...");
}

let result = doSomething();
console.log(result); // undefined
```

If you need your function to return a specific value, then you will need to use the `return` statement. Here is an example of using a `return` statement to return the sum of two values:

```js
function calculateSum(num1, num2) {
  return num1 + num2;
}

console.log(calculateSum(3, 4)); // 7
```

Often times you will be using the `return` statement, because you can use that value that was output from the function later on in your code.

So far, we've been working with named functions, but you can also create what's called an anonymous function. An anonymous function is a function without a name that can be assigned to a variable like this:

```js
const sum = function (num1, num2) {
  return num1 + num2;
};

console.log(sum(3, 4)); // 7
```

In this example, we have a `const` variable called `sum` and we are assigning it an anonymous function that returns the sum of `num1` and `num2`. We are then able to call `sum` and pass in the numbers `3` and `4` to get the result of `7`. 

Functions support default parameters, allowing you to set default values for parameters. These default values are used if the function is called without an argument for that parameter. Here's an example:

```js
function greetings(name = "Guest") {
  console.log("Hello, " + name + "!");
}

greetings(); // Hello, Guest!
greetings("Anna"); // Hello, Anna!
```

In this example, if no argument is provided for `name`, it defaults to `Guest`.

In summary, functions allow you to write reusable and organized code. They can take inputs (parameters), perform actions, and return outputs.


## What Are Arrow Functions, and How Do They Work?

### Description

In the previous lecture, you learned how to work with functions, which are reusable pieces of code that help make your code more modular, easier to maintain, and more efficient. All previous examples used the regular function syntax, like this:

```js
function greetings(name) {
  console.log("Hello, " + name + "!");
}
```

But another way to write functions in JavaScript is to create an arrow function expression. Here is how you can refactor the previous example to use arrow function syntax instead:

```js
const greetings = (name) => {
  console.log("Hello, " + name + "!");
};
```

In this revised example, we are creating a `const` variable called `greetings` and assigning it an anonymous function. Most of the syntax will look familiar to you except for the missing `function` keyword and the addition of the arrow (`=>`) between the `name` parameter and the function body. If your parameter list only has one parameter in it, then you can remove the parentheses like this:

```js
const greetings = name => {
  console.log("Hello, " + name + "!");
};
```

If your arrow function has no parameters, then you must use the parentheses like this:

```js
const greetings = () => {
  console.log("Hello");
};
```

When first learning about functions, you had to wrap the function body in curly braces. But if your function body only contains a single line of code, you can remove the curly braces like this:

```js
const greetings = name => console.log("Hello, " + name + "!");
```

It is important to note that removing the parentheses and curly braces for regular function syntax will not work. You will get errors if you tried to do something like this:

```js
// This will produce syntax errors 
function greetings name console.log("Hello, " + name + "!");
```

These types of one line functions only work if you are using the arrow function syntax. Another key concept is the `return` statement. Here is an example of using the arrow function syntax to calculate the area:

```js
const calculateArea = (width, height) => {
  const area = width * height;
  return area;
};

console.log(calculateArea(5, 3)); // 15
```

We are creating a variable inside the function called `area` and then returning that variable. But we could clean up our code a bit and return the calculation itself:

```js
const calculateArea = (width, height) => {
  return width * height;
}; 
```

If you tried to remove the curly braces and place the calculation on the same line, then you would get an `Uncaught SyntaxError: Unexpected token 'return'` message:

```js
const calculateArea = (width, height) => return width * height;
```

The reason why you are getting this error, is because you need to remove the `return` statement. When you remove that `return` statement, the error will disappear and the function will still implicitly return the calculation. 

```js
const calculateArea = (width, height) => width * height;
```

So when should you use the arrow function syntax? Well, it depends. Many developers use it consistently in their personal projects. However, when working on a team, the choice usually depends on whether the existing codebase uses regular functions or arrow functions. In future lectures, we'll cover when to use arrow functions and when to avoid them.


## What Is Scope in Programming, and How Does Global, Local, and Block Scope Work?

### Description

Scope in programming refers to the visibility and accessibility of variables in different parts of your code. It determines where variables can be accessed or modified. In JavaScript, understanding scope is crucial for writing clean, efficient, and bug-free code. There are three main types of scope: global scope, local scope, and block scope.

Global scope is the outermost scope in a JavaScript program. Variables declared in the global scope are accessible from anywhere in your code, including within functions and blocks. These variables are often called global variables. While global variables can be convenient, they should be used sparingly as they can lead to naming conflicts and make your code harder to maintain. Here's an example of a global variable:

```js
let globalVar = "I'm a global variable";

function printGlobalVar() {
    console.log(globalVar);
}

printGlobalVar(); // Output: "I'm a global variable"
```

In this example, `globalVar` is declared in the global scope and can be accessed inside the `printGlobalVar` function.

Local scope, on the other hand, refers to variables that are only accessible within a function. Here's an example of local scope:

```js
function greet() {
    let message = "Hello, local scope!";
    console.log(message);
}

greet(); // Output: "Hello, local scope!"
console.log(message); // This will throw an error
```

In this code, `message` is a local variable within the `greet` function. It can be used inside the function, but trying to access it outside the function will result in an error.

Block scope is a concept introduced with the `let` and `const` keywords in ES6. A block is any code section within curly braces, `{}`, such as in `if` statements, `for` loops, or `while` loops. The concept of loops will be taught in an upcoming lecture. 

Variables declared with `let` or `const` inside a block are only accessible within that block. Here's an example of block scope:

```js
if (true) {
    let blockVar = "I'm in a block";
    console.log(blockVar); // Output: "I'm in a block"
}
console.log(blockVar); // This will throw an error
```

In this example, `blockVar` is only accessible within the `if` block. Trying to access it outside the block will result in an error. Understanding these different types of scope is essential for managing variable accessibility and avoiding unintended side effects in your code. 

Global variables should be used sparingly, as they can lead to naming conflicts and make your code harder to maintain. Local variables help to keep different parts of your code isolated, which is especially useful in larger programs. Block scoping with `let` and `const` provides even finer control over variable accessibility, helping to prevent errors and make your code more predictable. Mastering these basic concepts of global, local, and block scope will provide a solid foundation for understanding more advanced topics.


## Module: Javascript Arrays


### Lecture Block: Lecture Working With Arrays


## What Are the Key Characteristics of JavaScript Arrays?

### Description

An array in JavaScript is an ordered collection of values, each identified by a numeric index. The values in a JavaScript array can be of different data types, including numbers, strings, booleans, objects, and even other arrays.

To create an array in JavaScript, you can use square brackets, `[]`, and separate the values with commas. Here's an example:

```js
let fruits = ["apple", "banana", "orange"];
```

In this example, we declare a variable `fruits` and assign it an array containing three string values: `apple`, `banana`, and `orange`.

One of the key characteristics of arrays is that they are zero-indexed, meaning that the first element in an array has an index of `0`, the second element has an index of `1`, and so on. You can access individual elements in an array using their index. For example:

```js
let fruits = ["apple", "banana", "orange"];
console.log(fruits[0]); // "apple"
console.log(fruits[2]); // "orange"
```

In this example, we use the index `0` to access the first element (`apple`) and the index `2` to access the third element (`orange`).

Arrays in JavaScript have a special `length` property that returns the number of elements in the array. You can access this property using the `length` keyword. For example:

```js
let fruits = ["apple", "banana", "orange"];
console.log(fruits.length); // 3
```

Another key characteristic of arrays in JavaScript is that they are dynamic, meaning that their size can change after they are created. You can add or remove elements from an array using various array methods, such as `push()`, `pop()`, `shift()`, `unshift()`, `splice()`, and more. These methods will be taught in upcoming lectures.

JavaScript arrays are versatile and useful when it comes to data storage inside your programs. Throughout this module, you'll get to see firsthand how working with arrays will help you efficiently manage and manipulate collections of data.


## How Do You Access and Update Elements in an Array?

### Description

In the previous lecture, you were first introduced to working with arrays and accessing different elements from arrays. Here is a reminder on how to access the second element from an array:

```js
const fruits = ["apple", "banana", "cherry"];

console.log(fruits[1]); // "banana"
```

Since arrays are zero based indexed, the first element will be at index `0`, the second index will be at index `1`, etc. It's important to note that if you try to access an index that doesn't exist in the array, JavaScript will return `undefined`. 

```js
let fruits = ["apple", "banana", "cherry"];
console.log(fruits[3]); // undefined
```

In this example, there is no index `3` for the `fruits` array. So the log will show `undefined`. Now, let's look at how to update elements in an array. You can update an element by assigning a new value to a specific index. 

```js
let fruits = ["apple", "banana", "cherry"];
fruits[1] = "blueberry";
console.log(fruits); // ["apple", "blueberry", "cherry"]
```

In this example, we've replaced `banana` with `blueberry` at index `1`. This method allows you to change any element in the array, as long as you know its index. You can also add new elements to an array by assigning a value to an index that doesn't yet exist:

```js
let fruits = ["apple", "banana", "cherry"];
fruits[3] = "date";
console.log(fruits); // Outputs: ["apple", "blueberry", "cherry", "date"]
```

However, exercise caution when doing this. If you assign a value to an index that is much larger than the current length of the array, you will create undefined elements for the indices in between, which can lead to unexpected behavior. As you continue to work with JavaScript, you'll find that these ways of accessing and updating array elements are fundamental to many programming tasks. Whether you're building a simple todo list or processing complex data structures, these skills will be invaluable.


## How Do You Add and Remove Elements from the Beginning and End of an Array?

### Description

Arrays in JavaScript are dynamic, which means you can easily add or remove elements from them. There are four main methods for adding and removing elements from the beginning and end of an array: `push()`, `pop()`, `shift()`, and `unshift()`. Let's explore each of these methods in detail.

The `push()` method is used to add one or more elements to the end of an array. The return value for the `push()` method is the new length of the array. Here's an example of adding a new fruit to the existing `fruits` array:

```js
const fruits = ["apple", "banana"];
const newLength = fruits.push("orange");
console.log(newLength); // 3
console.log(fruits); // ["apple", "banana", "orange"]
```

In this example, we start with an array called `fruits` which contains two elements. We then use the `push()` method to add the string `orange` to the end of the array.

You might have noticed that we are using `const` when declaring the `fruits` array. But why is it possible to add more elements to this `fruits` array when `fruits` is a constant? This is possible because declaring an array with the `const` keyword creates a reference to the array. While the array itself is mutable and can be modified, you cannot reassign a new value to the `fruits` constant, like this:

```js
const fruits = ["apple", "banana"];
fruits = ["This", "will", "not", "work"];
console.log(fruits); // Uncaught TypeError: Assignment to constant variable. 
```

The next method we will look at is the `pop()` method. The `pop()` method removes the last element from an array and returns that element. It also modifies the original array. Here's how it works:

```js
let fruits = ["apple", "banana", "orange"];
let lastFruit = fruits.pop();
console.log(fruits); // ["apple", "banana"]
console.log(lastFruit); // "orange"
```

In this example, we start with an array of three fruits. The `pop()` method removes the last element (`orange`) from the array and returns it. The original `fruits` array is modified and contains only two elements.

The `unshift()` method adds one or more elements to the beginning of an array and returns its new length. It works similarly to `push()`, but modifies the start of the array instead of the end. Here's an example:

```js
let numbers = [2, 3];
let newLength = numbers.unshift(1);
console.log(numbers); // [1, 2, 3]
console.log(newLength); // 3
```

In this example, we use `unshift()` to add the number `1` to the beginning of the `numbers` array. The method returns the new length of the array, which is `3`.

Finally, the `shift()` method removes the first element from an array and returns that element. It's similar to `pop()`, but it works at the beginning of the array instead of the end. Here's how it works:

```js
let colors = ["red", "green", "blue"];
let firstColor = colors.shift();
console.log(colors); // ["green", "blue"]
console.log(firstColor); // "red"
```

In this example, we start with an array of three colors. The `shift()` method removes the first element (`red`) from the array and returns it. The original `colors` array is modified to contain only two elements.

Note that while `push()` and `unshift()` can add multiple elements at once, `pop()` and `shift()` remove only one element at a time.


## What Is the Difference Between One-Dimensional and Two-Dimensional Arrays?

### Description

In programming, arrays are fundamental data structures used to store collections of elements. Understanding the difference between one-dimensional and two-dimensional arrays is crucial for organizing and manipulating data effectively. Let's explore these concepts in a way that's easy for beginners to grasp.

A one-dimensional array, often called an array, is like a single row of boxes. Imagine you have a line of storage lockers at a train station. Each locker can hold one item, and you can access any locker directly if you know its number.

In programming terms, each item in a one-dimensional array is accessed using a single index. For example, in JavaScript, you might create and use a one-dimensional array like this:

```js
let fruits = ["apple", "banana", "cherry", "date"];
console.log(fruits[2]); // Outputs: "cherry"
```

Here, `fruits` is a one-dimensional array. You can think of it as a single row of fruit names. To access any fruit, you use one number (the index) inside square brackets.

Now, let's move on to two-dimensional arrays. If a one-dimensional array is like a single row of lockers, a two-dimensional array is like a grid of lockers – multiple rows and columns. In programming, a two-dimensional array is essentially an array of arrays. It's used to represent data that has a natural grid-like structure, such as a chessboard, a spreadsheet, or pixels in an image.

To access an element in a two-dimensional array, you need two indices: one for the row and one for the column. Here's an example of how you might create and use a two-dimensional array in JavaScript:

```js
let chessboard = [
    ["R", "N", "B", "Q", "K", "B", "N", "R"],
    ["P", "P", "P", "P", "P", "P", "P", "P"],
    [" ", " ", " ", " ", " ", " ", " ", " "],
    [" ", " ", " ", " ", " ", " ", " ", " "],
    [" ", " ", " ", " ", " ", " ", " ", " "],
    [" ", " ", " ", " ", " ", " ", " ", " "],
    ["p", "p", "p", "p", "p", "p", "p", "p"],
    ["r", "n", "b", "q", "k", "b", "n", "r"]
];

console.log(chessboard[0][3]); // Outputs: "Q"
```

In this example, `chessboard` is a two-dimensional array representing a chess game's initial setup. To access the queen (`Q`) in the top row, we use two indices: `[0][3]`. The first index, `0`, selects the first row, and the second index, `3`, selects the fourth column in that row.

The key difference between one-dimensional and two-dimensional arrays lies in how you access and organize the data. One-dimensional arrays use a single index and are suitable for linear data like lists or sequences. Two-dimensional arrays use two indices and are ideal for grid-like data structures.

It's worth noting that in JavaScript, two-dimensional arrays are actually arrays of arrays. This means each element of the outer array is itself an array. This nested structure allows for great flexibility but also requires careful handling to avoid errors.

As you progress in your programming journey, you'll find that choosing between one-dimensional and two-dimensional arrays depends on the nature of your data and how you need to manipulate it. 

One-dimensional arrays are simpler and sufficient for many tasks, while two-dimensional arrays become invaluable when dealing with more complex, structured data.


## What Is Array Destructuring, and How Does It Work?

### Description

Array destructuring is a feature in JavaScript that allows you to extract values from arrays and assign them to variables in a more concise and readable way. It provides a convenient syntax for unpacking array elements into distinct variables. 

This technique is particularly useful when working with arrays and functions that return multiple values. Here is an example of using array destructuring: 

```js
let fruits = ["apple", "banana", "orange"];

let [first, second, third] = fruits;

console.log(first);  // "apple"
console.log(second); // "banana"
console.log(third);  // "orange"
```

In this example, we have an array called `fruits` with three elements. Using array destructuring, we assign the first element to the variable `first`, the second element to `second`, and the third element to `third`. This allows us to easily access individual elements of the array without using index notation. 

Here is what it would look like if you accessed each of those elements by their index instead of using array destructuring:

```js
const fruits = ["apple", "banana", "orange"];

const first = fruits[0];
const second = fruits[1];
const third = fruits[2];

console.log(first); // "apple"
console.log(second); // "banana"
console.log(third); // "orange"
```

Array destructuring also allows you to skip elements you're not interested in by using commas. For instance:

```js
let colors = ["red", "green", "blue", "yellow"];
let [firstColor, , thirdColor] = colors;

console.log(firstColor); // Output: "red"
console.log(thirdColor); // Output: "blue"
```

In this example, we skip the second element of the `colors` array by using an extra comma. This assigns `red` to `firstColor` and `blue` to `thirdColor`, effectively ignoring `green`.

Another powerful feature of array destructuring is the ability to use default values. If the array has fewer elements than the variables you're trying to assign, you can provide default values:

```js
let numbers = [1, 2];
let [a, b, c = 3] = numbers;

console.log(a); // 1
console.log(b); // 2
console.log(c); // 3
```

Here, we assign default value `3` to `c` because the `numbers` array doesn't have a third element.

Now, let's discuss the rest syntax, denoted by three dots (`...`). It allows you to capture the remaining elements of an array that haven’t been destructured into a new array. Here's how it works:

```js
let fruits = ["apple", "banana", "orange", "mango", "kiwi"];
let [first, second, ...rest] = fruits;

console.log(first);  // "apple"
console.log(second); // "banana"
console.log(rest);   // ["orange", "mango", "kiwi"]
```

In this example, `first` and `second` capture the first two elements of the `fruits` array, and `rest` captures all remaining elements as a new array. The rest syntax must be the last element in the destructuring pattern.

Array destructuring is a powerful feature that can make your code more concise and easier to read. It's especially useful when working with arrays, and when you need to extract specific elements from an array.


## How Can You Use String and Array Methods to Reverse a String?

### Description

Reversing a string is a common programming task that can be accomplished in JavaScript using a combination of string and array methods. The process involves three main steps:

- Splitting the string into an array of characters.
- Reversing the array.
- Joining the characters back into a string. 

Let's explore each of these steps using the `split()`, `reverse()`, and `join()` methods.

The first step in reversing a string is to convert it into an array of individual characters. We can do this using the `split()` method. The `split()` method divides a string into an array of substrings and specifies where each split should happen based on a given separator. If no separator is provided, the method returns an array containing the original string as a single element. Examples of common separators include:

- An empty string (`""`), which splits the string into individual characters.

- A single space (`" "`), which splits the string wherever spaces occur.

- A dash (`"-"`), which splits the string at each dash.

Here's an example of using the split method to create an array of characters:

```js
let str = "hello";
let charArray = str.split("");
console.log(charArray); // ["h", "e", "l", "l", "o"]
```

In this example, we use `split("")` (with an empty string pass to it) to convert the string `hello` into an array of its individual characters. Once we have an array of characters, we can use the `reverse()` method to reverse the order of elements in the array. 

The `reverse()` method is an array method that reverses an array in place. This means it modifies the original array rather than creating a new one. Here's how we can use it:

```js
let charArray = ["h", "e", "l", "l", "o"];
charArray.reverse();
console.log(charArray); // ["o", "l", "l", "e", "h"]
```

In this example, `reverse()` changes the order of elements in `charArray`, reversing it from `["h", "e", "l", "l", "o"]` to `["o", "l", "l", "e", "h"]`.

The final step is to convert the reversed array of characters back into a string. We can accomplish this using the `join()` method. The `join()` method creates and returns a new string by concatenating all of the elements in an array, separated by a specified separator string. If you want to join the characters without any separator, you can use an empty string as the argument. Here's an example:

```js
let reversedArray = ["o", "l", "l", "e", "h"];
let reversedString = reversedArray.join("");
console.log(reversedString); // "olleh"
```

In this example, `join("")` (with an empty string pass to it as an argument) combines all the characters in the array into a single string without any separator between them.

Remember that strings in JavaScript are immutable, which means you can't directly reverse a string by modifying it. That's why we need to convert it to an array, reverse the array, and then convert it back to a string. This combination of string and array methods provides a powerful and flexible way to manipulate strings in JavaScript.


### Lecture Block: Lecture Working With Common Array Methods


## How Do You Get the Index for an Element in an Array Using the indexOf Method?

### Description

In JavaScript, the `indexOf()` method is useful for finding the first index of a specific element within an array. If the element cannot be found, then it will return `-1`. Here is the basic syntax:

```js
array.indexOf(element, fromIndex)
```

`element` represents the value you want to search for within the array, and the `fromIndex` parameter is the position from which the search should start. The `fromIndex` parameter is optional. If `fromIndex` is not provided, the search starts from the beginning of the array. Let's look at an example:

```js
let fruits = ["apple", "banana", "orange", "banana"];
let index = fruits.indexOf("banana");
console.log(index); // 1
```

In this example, we have an array `fruits` containing various fruit names. We use the `indexOf()` method to find the index of the string `banana` within the `fruits` array. Since `banana` is present at index `1`, the method returns `1`, which is stored in the `index` variable and logged to the console.

If the element you're searching for is not found in the array, `indexOf()` returns `-1`. For example:

```js
let fruits = ["apple", "banana", "orange"];
let index = fruits.indexOf("grape");
console.log(index); // -1
```

Here, we search for the string `grape` in the fruits array using `indexOf()`. Since `grape` is not present in the array, the method returns `-1`, which is stored in the `index` variable and logged to the console.

If you want to start looking for an item after a specific index number, then you can pass a second argument like in this example: 

```js
let colors = ["red", "green", "blue", "yellow", "green"];
let index = colors.indexOf("green", 3);
console.log(index); // 4
```

In this example, the search does not start from the start of an array, rather it starts from the index number `3` which is `yellow` and gets the output of `4`.


## How Do You Add and Remove Elements from the Middle of an Array?

### Description

The `splice()` method in JavaScript is a powerful way for modifying arrays. It allows you to add or remove elements from any position in an array, including the middle. The return value for the `splice()` method will be an array of the items removed from the array. If nothing was removed, then an empty array will be returned.

It is important to note that this method will mutate the original array, modifying it in place rather than creating a new array. This is something to be aware of when working with `splice()`. Here is the basic syntax:

```js
array.splice(startIndex, itemsToRemove, item1, item2)
```

`startIndex` specifies the index at which to begin modifying the array, while `itemsToRemove` is an optional parameter indicating how many elements to remove. If `itemsToRemove` is omitted, `splice()` will remove all elements from `startIndex` to the end of the array. The subsequent parameters (`item1`, `item2`, and so on) are the elements to be added to the array, beginning at the start index.

Let's start with an example of removing elements from the middle of an array:

```js
let fruits = ["apple", "banana", "orange", "mango", "kiwi"];
let removed = fruits.splice(2, 2);

console.log(fruits);  // ["apple", "banana", "kiwi"]
console.log(removed); // ["orange", "mango"]
```

In this example, `splice(2, 2)` starts at index `2` and removes `2` elements. The modified array will now consist of only `apple`, `banana`, and `kiwi`. Now, let's look at how to add elements to the middle of an array:

```js
let colors = ["red", "green", "blue"];
colors.splice(1, 0, "yellow", "purple");

console.log(colors); // ["red", "yellow", "purple", "green", "blue"]
```

Here, `splice(1, 0, "yellow", "purple")` starts at index `1`, removes `0` elements, and inserts `yellow` and `purple`. The second parameter (`0`) means no elements are removed before insertion. You can also use `splice()` to simultaneously remove and add elements:

```js
let numbers = [1, 2, 3, 4, 5];
numbers.splice(1, 2, 6, 7, 8);

console.log(numbers); // [1, 6, 7, 8, 4, 5]
```

In this case, `splice(1, 2, 6, 7, 8)` starts at index `1`, removes `2` elements (`2` and `3`), and inserts `6`, `7`, and `8`. If you need to keep the original array unchanged, you should create a copy before using `splice()`:

```js
let original = [1, 2, 3, 4, 5];
let copy = [...original];
copy.splice(2, 1, 6);

console.log(original); // [1, 2, 3, 4, 5]
console.log(copy);     // [1, 2, 6, 4, 5]
```

In this example, to create a copy of the `original` array without modifying it, we use the spread operator (`...`). The spread operator will create a shallow copy of the elements of the `original` array into a new array.  You will learn more about this in future lectures.

When we use `copy.splice(2, 1, 6)`, it modifies the copy array by removing the element at index `2` (which is `3`) and inserting the new element `6` at that position.

One common use case for `splice()` is to remove a single element from an array when you know its index:

```js
let fruits = ["apple", "banana", "orange", "mango"];
let indexToRemove = fruits.indexOf("orange");
if (indexToRemove !== -1) {
    fruits.splice(indexToRemove, 1);
}

console.log(fruits); // ["apple", "banana", "mango"]
```

In this example, we first use the `indexOf()` method to find the index of the element `orange` in the `fruits` array. The `indexOf()` method returns the index of the first occurrence of the given element or `-1` if the element is not found in the array. 

We then compare `indexToRemove` with `-1` to ensure that the element exists in the array before attempting to remove it. If `indexToRemove` is not equal to `-1` (meaning the element is found), we use `splice()` to remove one element starting from the `indexToRemove` position.

You can also use `splice()` to clear an array by removing all elements:

```js
let array = [1, 2, 3, 4, 5];
array.splice(0);

console.log(array); // []
```

While `splice()` is powerful, it's worth noting that for very large arrays, it can be less efficient than other methods, especially when modifying the beginning of the array. This is because `splice()` may need to shift all subsequent elements. In such cases, if you're only adding or removing elements at the end of the array, methods like `push()`, `pop()`, `unshift()`, and `shift()` might be more appropriate.

In conclusion, the `splice()` method is a versatile way for modifying arrays in JavaScript. It allows for precise control over adding and removing elements from any position in an array. Understanding how to use `splice()` effectively can greatly enhance your ability to manipulate arrays in your JavaScript code.


## How Can You Check if an Array Contains a Certain Value?

### Description

In JavaScript, the `includes()` method is a simple and efficient way to check if an array contains a specific value. This method returns a boolean value: `true` if the array contains the specified element, and `false` otherwise. 

The `includes()` method is particularly useful when you need to quickly verify the presence of an element in an array without needing to know its exact position. Let's start with an example of how to use the `includes()` method:

```js
let fruits = ["apple", "banana", "orange", "mango"];
console.log(fruits.includes("banana")); // true
console.log(fruits.includes("grape"));  // false
```

In this example, we have an array of fruits. We use the `includes()` method to check if `banana` is in the array. It returns `true` because `banana` is indeed present. We then check for `grape`, which returns `false` because it's not in the array.

The `includes()` method is case-sensitive when dealing with strings. This means that `Banana` with a capital B and `banana` with all lowercase letters are considered different values. Here's an example that illustrates this:

```js
let fruits = ["apple", "banana", "orange"];
console.log(fruits.includes("banana")); // true
console.log(fruits.includes("Banana")); // false
```

In this case, `banana` (all in lowercase) is found in the array, but `Banana` (with the first letter capitalized) is not, so the second `includes()` call returns `false`.

The `includes()` method can also accept an optional second parameter that specifies the position in the array to start the search. This is useful if you want to check for an element's presence in a specific part of the array. Here's how you can use this feature:

```js
let numbers = [10, 20, 30, 40, 50, 30, 60];
console.log(numbers.includes(30, 3)); // true
console.log(numbers.includes(30, 4)); // true
```

For the first `console.log`, we are looking for the number `30` starting at index `3`. In this case, there is a number `30` that appears after index `3`, so the `includes()` method returns `true`. 

The same is true for the second `console.log`. We are looking for the number `30` starting at index `4`. Since the number `30` does appear after that index, then it will return `true`. 

It's worth noting that `includes()` uses the strict equality comparison (`===`), which means it can distinguish between different types. For example:

```js
let mixedArray = [1, "2", 3, "4", 5];
console.log(mixedArray.includes(2));  // false
console.log(mixedArray.includes("2")); // true
```

In this case, the number `2` and the string `"2"` are considered different data types. So, the first `console.log` will return `false`, while the second `console.log` will return `true`.

The `includes()` method is a powerful tool for checking the presence of elements in arrays. It's simple to use, efficient, and can save you from writing more complex loops or conditions to search through arrays. Whether you're working with strings, numbers, or mixed data types, `includes()` provides a straightforward way to verify if a value exists in your array.


## What Is a Shallow Copy of an Array, and What Are Some Ways to Create These Copies?

### Description

A shallow copy of an array is a new array that contains references to the same elements as the original array. Creating shallow copies of arrays is a common operation, especially when you want to manipulate an array without modifying the original. 

There are several methods for creating shallow copies of arrays, and we'll explore some of the most common ones: `concat()`, `slice()`, and the spread operator.

Let's start with the `concat()` method. This method creates a new array by merging two or more arrays. When used with a single array, it effectively creates a shallow copy. Here's an example:

```js
let originalArray = [1, 2, 3];
let copyArray = [].concat(originalArray);

console.log(copyArray); // [1, 2, 3]
console.log(copyArray === originalArray); // false
```

In this example, we are using the `concat()` method to concatenate an empty array to the `originalArray`. This will create a new array that is a shallow copy of `originalArray`. 

The `copyArray` contains the same elements as `originalArray`, but it is a different array object, which is why the strict equality check (`===`) returns `false`.

Another method to create a shallow copy is the `slice()` method. When called without arguments, `slice()` returns a shallow copy of the entire array. Here's how it works:

```js
let originalArray = [1, 2, 3];
let copyArray = originalArray.slice();

console.log(copyArray); // [1, 2, 3]
console.log(copyArray === originalArray); // false
```

In this case, `originalArray.slice()` creates a new array that is a shallow copy of `originalArray`. Again, the `copyArray` contains the same elements but is a different array object.

The spread operator (`...`), introduced in ES6, provides another concise way to create shallow copies of arrays. Here's an example:

```js
let originalArray = [1, 2, 3];
let copyArray = [...originalArray];

console.log(copyArray); // [1, 2, 3]
console.log(copyArray === originalArray); // false
```

The spread operator (`...`) spreads the elements of `originalArray` into a new array, effectively creating a shallow copy. It's important to note that all these methods create new array objects, which means you can modify the copy without affecting the original array. For example:

```js
let originalArray = [1, 2, 3];
let copyArray = [...originalArray];

copyArray.push(4);
console.log(originalArray); // [1, 2, 3]
console.log(copyArray);     // [1, 2, 3, 4]
```

In this example, adding an element to `copyArray` doesn't affect `originalArray`.

In summary, shallow copies of arrays can be easily created using methods like `concat()`, `slice()`, or the spread operator. These methods are useful for creating new arrays that can be manipulated independently of the original array.


## Module: Javascript Objects


### Lecture Block: Lecture Working With Objects


## What Is an Object in JavaScript, and How Can You Access Properties from an Object?

### Description

In JavaScript, an object is a fundamental data structure that allows you to store and organize related data and functionality. 

You can think of an object as a container that holds various pieces of information, much like a filing cabinet holds different folders and documents. 

These pieces of information are called properties, and they consist of a name (or key) and a value.

```js
const exampleObject = {
  propertyName: value;
}
```

Objects are incredibly versatile and form the backbone of JavaScript. In fact, almost everything in JavaScript is an object or can be treated as one. This includes arrays, functions, and even primitive data types like strings and numbers when used in certain ways. 

This object-centric nature of JavaScript is one of the reasons it's such a flexible and powerful language. Let's look at how you can create an object:

```js
const person = {
  name: "Alice",
  age: 30,
  city: "New York"
};
```

In this example, we've created an object called `person` with three properties: `name`, `age`, and `city`. Each property has a name and a value, separated by a colon.

Now, let's explore how you can access these properties. There are two main ways to access object properties in JavaScript: dot notation and bracket notation.

Dot notation is the most common and straightforward way to access object properties. Here is the basic syntax for dot notation:

```js
objectName.propertyName
```

Here's how you would use dot notation with our `person` object:

```js
const person = {
  name: "Alice",
  age: 30,
  city: "New York"
};

console.log(person.name);  // Alice
console.log(person.age);   // 30
```

Dot notation is concise and easy to read, making it the preferred choice when you know the exact name of the property you want to access and that name is a valid JavaScript identifier (meaning it doesn't start with a number and doesn't contain special characters or spaces).

Bracket notation, on the other hand, allows you to access object properties using a string inside square brackets. Here's how you would use bracket notation:

```js
const person = {
  name: "Alice",
  age: 30,
  city: "New York"
};

console.log(person["name"]); // Alice
console.log(person["age"]); //  30
```

Bracket notation is more flexible than dot notation because it allows you to use property names that aren't valid JavaScript identifiers. For example, if you had a property name with spaces or that starts with a number, you'd need to use bracket notation:

```js
const oddObject = {
  "1stProperty": "Hello",
  "property with spaces": "World"
};

console.log(oddObject["1stProperty"]);  // Hello
console.log(oddObject["property with spaces"]);  // World
```

Another advantage of bracket notation is that it allows you to use variables to access properties dynamically:

```js
const person = {
  name: "Alice",
  age: 30,
  city: "Wonderland"
};

let propertyName = "city";
console.log(person[propertyName]); // Wonderland
```

This flexibility makes bracket notation particularly useful when you don't know the exact property name at the time you're writing the code, or when you're working with property names that come from user input or some other dynamic source.

It's worth noting that objects in JavaScript are incredibly powerful and versatile. They can contain not just simple values like strings and numbers, but also arrays, or other objects.

Understanding objects and how to work with them is crucial in JavaScript because they're used extensively throughout the language and in many JavaScript libraries and frameworks. 

As you continue to learn and work with JavaScript, you'll find that mastering objects opens up a world of possibilities for creating complex and powerful applications.


## What Is Object Destructuring, and How Does It Work?

### Description

Object destructuring is a powerful feature in JavaScript that allows you to extract values from objects and assign them to variables in a more concise and readable way. 

It's part of the ES6 (ECMAScript 2015) specification and has become an essential tool for many JavaScript developers. 

Destructuring can simplify your code, especially when working with complex objects or when you need to extract multiple values at once.

At its core, object destructuring is about unpacking values from objects into distinct variables. Instead of accessing object properties one by one, you can extract multiple properties in a single statement. This can make your code cleaner and more efficient.

Let's start with an example to illustrate how object destructuring works:

```js
const person = { name: "Alice", age: 30, city: "New York" };

const { name, age } = person;

console.log(name); // Alice
console.log(age);  // 30
```

In this example, we're extracting the `name` and `age` properties from the `person` object and assigning them to variables with the same names. 

One of the powerful aspects of object destructuring is that you can assign the extracted values to variables with different names. This is particularly useful when you're working with objects that have property names that might conflict with existing variables or when you want to use a different name:

```js
let person = { name: "Alice", age: 30, city: "New York" };

let { name: personName, age: personAge } = person;

console.log(personName); // Alice
console.log(personAge); //  30
```

In this case, we're extracting the `name` property and assigning it to a variable called `personName`, and doing the same with `age` and `personAge`.

Object destructuring also allows you to set default values. If a property doesn't exist in the object you're destructuring, you can specify a fallback value:

```js
let person = { name: "Alice", age: 30, city: "New York" };
let { name, age, country = "Unknown" } = person;

console.log(country); // Unknown
```

Here, since `country` doesn't exist in our `person` object, it gets the default value `Unknown`.

Now, let's talk about the shorthand notation in object destructuring. When you're creating objects, especially when the property names match variable names, you can use a shorthand syntax:

```js
let name = "Bob";
let age = 25;

let person = { name, age };

console.log(person); // { name: "Bob", age: 25 }
```

The code above takes the properties with the same name as our variables and assigns them the values of those variables.

This shorthand notation is particularly useful when you're returning objects from functions or creating objects with multiple properties:

```js
function createPerson(name, age) {
  return { name, age };
}

let person = createPerson("Charlie", 35);
console.log(person); // { name: "Charlie", age: 35 }
```

Object destructuring and the shorthand object notation are powerful features that can make your code more concise and easier to read. 

They're especially useful when working with complex data structures, or when you need to pass multiple parameters to functions. 

As you continue to work with JavaScript, you'll find many situations where these techniques can simplify your code and make it more expressive.


## How Can You Remove Properties from an Object?

### Description

There are several ways to remove properties from an object, with the `delete` operator being the most straightforward and commonly used method.

When you use `delete`, it removes the selected property from the object. Here's an example of how to use the `delete` operator:

```js
const person = {
  name: "Alice",
  age: 30,
  job: "Engineer"
};

delete person.job;

console.log(person.job); // undefined
```

In this example, we start with a `person` object that has three properties: `name`, `age`, and `job`. Then, we use the `delete` operator to remove the `job` property. After the deletion, the `person` object no longer has the `job` property.

Another way to remove properties is by using destructuring assignment with rest parameters. This approach doesn't actually delete the property, but it creates a new object without the specified properties:

```js
const person = {
  name: "Bob",
  age: 25,
  job: "Designer",
  city: "New York"
};

const { job, city, ...remainingProperties } = person;

// { name: "Bob", age: 25 }
console.log(remainingProperties);
```

In this example, we use destructuring to extract `job` and `city` from the `person` object, and collect the remaining properties into a new object called `remainingProperties`. This creates a new object without the `job` and `city` properties.

Understanding how to remove properties from objects is an important skill in JavaScript programming. It allows you to manipulate objects dynamically, and clean up unnecessary data.


## How to Check If an Object Has a Property?

### Description

In JavaScript, there are several ways to check if an object has a specific property. Understanding these methods is important for working effectively with objects, especially when you're dealing with data from external sources or when you need to ensure certain properties exist before using them. 

We'll explore three common approaches: the `hasOwnProperty()` method, the `in` operator, and checking against `undefined`.

Let's start with the `hasOwnProperty()` method. This method returns a boolean indicating whether the object has the specified property as its own property. Here's an example:

```js
const person = {
  name: "Alice",
  age: 30
};

console.log(person.hasOwnProperty("name")); // true
console.log(person.hasOwnProperty("job")); // false
```

In this example, we have an object called `person` with two properties: `name` and `age`. To check if `name` is a property in the `person` object, we use the `hasOwnProperty()` method. Since `name` is a property, it will return `true`. But when we use the `hasOwnProperty()` to check if `job` is a property, it will return `false` because it does not exist in the object.

Another way to check for the existence of a property in an object is to use the `in` operator. Like `hasOwnProperty()`, the `in` operator will return `true` if the property exists on the object. Here's how you can use it:

```js
const person = {
  name: "Bob",
  age: 25
};
console.log("name" in person);  // true
```

In this example, `"name" in person` returns `true` because `name` is a property of `person`.

The third method involves checking if a property is `undefined`. This approach can be useful, but it has some limitations. Here's an example:

```js
const car = {
  brand: "Toyota",
  model: "Corolla",
  year: 2020
};

console.log(car.brand !== undefined); // true
console.log(car.color !== undefined); // false
```

In this code, we check if `car.brand` and `car.color` are not `undefined`. This works because accessing a non-existent property on an object returns `undefined`. However, this method can give false negatives if a property explicitly has the value `undefined`.

In practice, the choice between these methods often depends on the specific requirements of your code. Understanding the differences between them will help you make the right choice in different scenarios.


## How Do You Work with Accessing Properties from Nested Objects and Arrays in Objects?

### Description

When working with JavaScript, you'll often encounter complex data structures that involve nested objects and arrays within objects. These structures can represent rich, hierarchical data, but they also require a clear understanding of how to access and manipulate the data within them. Let's explore how to navigate these nested structures effectively.

Accessing properties from nested objects involves using the dot notation or bracket notation, much like accessing properties from simple objects. However, you'll need to chain these accessors to drill down into the nested structure. 

For example, let's consider a nested object representing a person with contact information:

```js
const person = {
  name: "Alice",
  age: 30,
  contact: {
    email: "alice@example.com",
    phone: {
      home: "123-456-7890",
      work: "098-765-4321"
    }
  }
};
```

To access `Alice`'s work phone number, you would chain the property accessors like this:

```js
console.log(person.contact.phone.work); // "098-765-4321"
```

You can also use bracket notation, which is particularly useful when property names include spaces or special characters, or when you're using variables to access properties:

```js
console.log(person['contact']['phone']['work']); // "098-765-4321"
```

Now, let’s take a look at how we can access data where one of the object properties has the value of an array. Here is a modified `person` object that includes an array of addresses:

```js
const person = {
  name: "Alice",
  age: 30,
  addresses: [
    { type: "home", street: "123 Main St", city: "Anytown" },
    { type: "work", street: "456 Market St", city: "Workville" }
  ]
};
```

Here is an example of how to access `Alice`'s work address city:

```js
console.log(person.addresses[1].city); // "Workville"
```

In this example, `person.addresses` refers to the array of addresses. To access the second address in that array, we use bracket notation and index `1`. Then, we use dot notation to access the `city` from that address object.

Understanding how to access properties in nested objects and arrays is essential when working with complex data structures. In future workshops and labs, you will have the opportunity to practice working with these types of data structures.


## What Is the Difference Between Primitive and Non-Primitive Data Types?

### Description

In JavaScript, understanding the difference between primitive and non-primitive data types is important for writing efficient and bug-free code. 

These two categories of data types behave differently in terms of how they are stored in memory and how they are manipulated in your programs.

Primitive data types are the simplest form of data in JavaScript. They include numbers, strings, booleans, `null`, `undefined`, and symbols. These types are called "primitive" because they represent single values and are not objects. 

When you work with primitive data types, you're dealing directly with their values. For example, when you create a variable with a primitive value, that value is stored directly in the variable. 

Primitive values are immutable, which means once they are created, their value cannot be changed. However, you can reassign a new value to the variable. Here's an example of working with primitive data types:

```js
let num1 = 5;
let num2 = num1;
num1 = 10;

console.log(num2); // 5
```

In this example, we are assigning a primitive value (`5`) from `num1` to `num2`. This creates an independent copy of the value. As a result, any changes made to the original variable (`num1`) do not affect the copy (`num2`).

Non-primitive data types, on the other hand, are more complex. In JavaScript, these are objects, which include regular objects, arrays, and functions. Unlike primitives, non-primitive types can hold multiple values as properties or elements. 

When you create a variable with a non-primitive value, what's stored in the variable is actually a reference to the location in memory where the object is stored, not the object itself. This leads to some important differences in behavior. Here's an example with non-primitive types:

```js
const originalPerson = { name: "John", age: 30 };
const copiedPerson = originalPerson;

originalPerson.age = 31;

console.log(copiedPerson.age); // 31
```

In this example we have an object called `originalPerson` with two properties of `name` and `age`. We then assign the `originalPerson` object to a variable called `copiedPerson`.

Then we update the `age` value for the `originalPerson` object. When we log the `age` property of `copiedPerson` object it shows the updated value.

But why is that happening? This occurs because both `originalPerson` and `copiedPerson` are referencing the same object in memory.

In JavaScript, when you assign an object to another variable, you're copying the reference to the object, not the object itself. This is known as shallow copying by reference. As a result, any changes made to the object through one reference are reflected in all references to that object.

As you continue to work with JavaScript, you'll encounter many situations where understanding the difference between primitive and non-primitive types is important. It's a fundamental concept that underlies many aspects of the language and is key to writing efficient and correct code.


## What Is the Difference Between Functions and Object Methods?

### Description

In JavaScript, functions and object methods are both ways to encapsulate reusable code, but they have some key differences in how they are defined, used, and the context in which they operate. Understanding these differences is crucial for writing effective and organized JavaScript code.

As you learned in earlier modules, functions are reusable blocks of code that perform a specific task:

```js
function greet(name) {
    return "Hello, " + name + "!";
}
console.log(greet("Alice")); // "Hello, Alice!"
```

Object methods, on the other hand, are functions that are associated with an object. They are defined as properties of an object and can access and manipulate the object's data. Here's an example of an object with a method:

```js
const person = {
    name: "Bob",
    age: 30,
    sayHello: function() {
        return "Hello, my name is " + this.name;
    }
};

console.log(person.sayHello()); // "Hello, my name is Bob"
```

In this example, `sayHello` is a method of the `person` object. The `this` keyword allows the `sayHello` method to access the properties of the object named `person`. You will learn more about the `this` keyword in future lectures.

A difference between functions and methods is how they are invoked. Functions are called by their name, while methods are called using dot notation on the object they belong to. For example, we call the `greet` function as `greet("Alice")`, but we call the `sayHello` method as `person.sayHello()`.

Another important difference is the context in which they operate. Regular functions have their own scope, but they don't have a built-in reference to any particular object. Methods, however, are bound to their object and can access its properties and other methods using the `this` keyword.

A key point to note is that, methods help in organizing code into logical objects, while functions are used for more general, reusable code.

Understanding the difference between functions and object methods is important as you progress in your JavaScript journey. While they may seem similar at first, recognizing when to use each will help you write more organized, efficient, and better code.


## What Is the Object() Constructor, and When Should You Use It?

### Description

In JavaScript, a constructor is a special type of function used to create and initialize objects. It is invoked with the `new` keyword and can initialize properties and methods on the newly created object.

In this lecture, we will take a look at how to work with the `Object()` constructor. The `Object()` constructor creates a new empty object. Here is an example:

```js
new Object()
```

When you call `new Object()`, it returns a new object that can be used to store values.

The `Object()` constructor can be used with or without the `new` keyword. When called as a function without `new`, it behaves differently depending on the type of value passed to it. Here's an example of using the `Object()` constructor without the `new` keyword:

```js
const num = 42;
const numObj = Object(num); // Creates an object wrapper for the number

console.log(numObj); // 42
console.log(typeof numObj); // "object"
```

The first `console.log` will show `42`, but it is important to note that this is not a regular number. As you can see in the second `console.log`, `numObj` is an object.  This is happening because we used the `Object()` constructor to turn that input of a number into an object. 

What happens if we try to pass `null` or `undefined` to the `Object()` constructor?

```js
const newObj = new Object(undefined);
console.log(newObj); // {}
```

Well, the result will be an empty object. Another use case for the `Object()` constructor is when you're working with a value of unknown type and you need to ensure it's an object. Let’s take a look at the following example:

```js
function toObject(value) {
  if (value === null || value === undefined) {
    return {};
  }

  if (typeof value === "object") {
    return value;
  }

  return Object(value);
}

console.log(toObject(null));

console.log(toObject(true));

console.log(toObject([1, 2, 3]));
```

In this example, we have a function called `toObject`. The second condition will check if the value is a type of object and will return the value if the condition is `true`. This condition will check for objects as well as arrays since arrays are special types of objects.

If neither of the conditions is true, the function returns `Object(value)`, which converts the input into an object. This works for values like numbers, strings, and booleans

Most of the time you will not be using the `Object()` constructor to create new objects because you will be using object literal syntax instead (e.g., `const objectLiteral = { name: "Beau" }`). But it is still good to understand the basics of working with the Object constructor.


## What Is the Optional Chaining Operator, and How Does It Work?

### Description

The optional chaining operator (`?.`) is a useful tool in JavaScript that lets you safely access object properties or call methods without worrying whether they exist. It's like a safety net for working with objects that might have missing parts.

```js
const person = {
  name: "Alice",
  age: 30
};

console.log(person.name); // "Alice"
console.log(person.job); // undefined
```

In this example, `person.name exists`, so it logs `Alice`. But `person.job` doesn't exist, so it gives us `undefined`.

Now, let's say we want to access a property of an object that might not exist:

```js
const person = {
  name: "Alice",
  age: 30
};

console.log(person.address.street); // This will throw an error!
```

This example will throw an `Uncaught TypeError`. Since `person.address` is `undefined`, we are not able to access the `street` property. This is where the optional chaining operator comes in handy. Here is an example of using the optional chaining operator:

```js
const user = {
  name: "John",
  profile: {
    email: "john@example.com",
    address: {
      street: "123 Main St",
      city: "Somewhere"
    }
  }
};

console.log(user.profile?.address?.street); // "123 Main St"
console.log(user.profile?.phone?.number);   // undefined
```

By using the optional chaining operator, we are telling JavaScript to only continue with the operation if the object (or the value before the `?.`) exists and is not `null` or `undefined`. 

If the value before the `?.` is `null` or `undefined`, JavaScript returns `undefined` rather than attempting to proceed with the operation and throwing an error.

Remember, the optional chaining operator is most useful when you're not sure if a property or method exists. It helps prevent errors and makes your code more robust.


## What Is JSON, and How Do You Access Values Using Bracket and Dot Notation?

### Description

What is JSON and how do you access values using bracket and dot notation?

JSON stands for JavaScript Object Notation. It is a lightweight, text-based data format that is commonly used to exchange data between a server and a web application. 

One of the reasons why JSON is so popular in web development is because it is both machine-parseable and human-readable.   

Since JSON is language-independent, you can easily send JSON data from a Java application to a Python application, or from a JavaScript application to a C# application.

JSON supports many data types including objects, arrays, strings, booleans, null, and numbers. 

Here's an example of a JSON object:

```js
{
  "name": "Alice",
  "age": 30,
  "isStudent": false,
  "list of courses": ["Mathematics", "Physics", "Computer Science"]
}
```

As you can see, JSON uses key-value pairs to store information and each pair is separated by a comma. Each key must be wrapped in double quotes, otherwise you will get an error.

To access data from a JSON object, you can either use dot or bracket notation. In this example, we are using dot notation to access the `age` from the JSON object:

```js
import data from "./example.json" with { type: "json" };

console.log(data.age);
```

This particular example is using what is known as an `import` statement, which imports the JSON object into this file so we have access to it. You will learn more about the `import` statement in a future lecture.

You can also use bracket notation to access information from JSON objects. Here is an example of accessing the `list of courses` array:

```js
import data from "./example.json" with { type: "json" };

console.log(data["list of courses"]);
```

Using bracket notation is particularly useful here because the key contains multiple words separated by spaces. If we tried to use dot notation, it would result in an error.

In summary, JSON is a versatile format that can store many data types, including arrays and nested objects. By using dot notation or bracket notation, you can easily access the values stored within a JSON object.


## How Do JSON.parse() and JSON.stringify() Work?

### Description

There are two powerful methods in JavaScript for handling JSON data: `JSON.parse()` and `JSON.stringify()`. These methods are commonly used to convert between JSON strings and JavaScript objects.

`JSON.stringify()` is used to convert a JavaScript object into a JSON string. This is useful when you want to store or transmit data in a format that can be easily shared or transferred between systems. 

Here's how you can use the `JSON.stringify()` method:

```js
const user = {
  name: "John",
  age: 30,
  isAdmin: true
};

const jsonString = JSON.stringify(user);
console.log(jsonString);
```

In the example, the JavaScript object `user` is converted into a JSON string that looks like this:

```js
'{"name":"John","age":30,"isAdmin":true}'
```

The `JSON.stringify()` method also accepts an optional parameter called a replacer, which can be a function or an array. Here is an example of using an array for the optional replacer parameter:

```js
const developerObj = {
  firstName: "Jessica",
  isAwesome: true,
  isMusician: true,
  country: "USA",
};

// result: {"firstName":"Jessica","country":"USA"}
console.log(JSON.stringify(developerObj, ["firstName", "country"]));
```

In this example, we have a `developerObj` with four properties. When we use the `JSON.stringify()` method, we can pass in an array for the second parameter and specify which properties we want stringified. The result will be a stringified object containing only the `firstName` and `country` properties. 

Another optional parameter for the `JSON.stringify()` method would be the spacer parameter. This allows you to control the spacing for the stringified result:

```js
const developerObj = {
  firstName: "Jessica",
  isAwesome: true,
  isMusician: true,
  country: "USA",
};

console.log(JSON.stringify(developerObj, null, 2));

/* result
{
  "firstName": "Jessica",
  "isAwesome": true,
  "isMusician": true,
  "country": "USA"
}
*/
```

Most of the time you will not be using either of these optional parameters for the `JSON.stringify()` method but it is still helpful to be aware of them. 

Another method you will be using a lot in your programming is the `JSON.parse()` method. `JSON.parse()` converts a JSON string back into a JavaScript object. This is useful when you retrieve JSON data from a web server or from `localStorage` and you need to manipulate the data in your application. You will learn more about `localStorage` in a future lecture. 

Here's an example on how to work with the `JSON.parse()` method:

```js
const jsonString = '{"name":"John","age":30,"isAdmin":true}';
const userObject = JSON.parse(jsonString);
```

The JSON string is parsed back into a JavaScript object that looks like this:

```js
{
  name: "John",
  age: 30,
  isAdmin: true
}
```

This allows you to work with the data in your program as a normal JavaScript object, making it easier to manipulate and use.

In future modules, we will continue to learn more about how to work with JSON and the `JSON.parse()` and `JSON.stringify()` methods.


## Module: Javascript Loops


### Lecture Block: Lecture Working With Loops


## How Do Loops and Iteration Work in JavaScript?

### Description

Loops in programming are used to repeat a block of code multiple times.

An example of a loop would be when you are designing a program that needs to print out a list of items. You could use a loop to print out each one of the items in the list.

Another example would be when you designing a game and you want to move a character across the screen. You could use a loop to move the character a certain number of pixels each time the loop runs. 

In JavaScript, there are several types of loops that you can use. In this lecture, we will cover the `for` loop. Here is the basic syntax for a `for` loop:

```js
for (initialization; condition; increment or decrement) {
  // code block to be executed
}
```

The initialization statement is executed before the loop starts. It is typically used to initialize a counter variable. A counter variable is a variable that is used to keep track of how many times the loop has run.

The condition statement is evaluated before each iteration of the loop. An iteration is a single pass through the loop.

If the condition is true, the code block inside the loop is executed. If the condition is false, the loop stops and you move on to the next block of code.

The last part of the loop is the increment/decrement statement. This statement is executed after each iteration of the loop. It is typically used to increment or decrement the counter variable.

```js
for (let i = 0; i < 5; i++) {
  console.log(i);
}
```

In the first part of the example above, we initialize a counter variable `i` to `0`. It is common convention to use `i` as the counter variable in a `for` loop.

The next part is to check the condition. In this case, the condition is checking if `i` is less than `5`. Since `i` is `0`, the condition is true, and the code block inside the loop is executed.

The code block inside the loop is to log the value of `i` to the console. The value of `i` is `0`, so the console will show the value of `0`.

Then the increment statement is executed. In this case, we are incrementing `i` by `1`. So `i` is now `1`.

Then we check the condition again which is to check if `i` is less than `5`. Since `i` is now `1`, the condition is still true, and the code block inside the loop is executed again.

We keep repeating this process until the condition is false. In this case, when `i` is `5`, the condition is false, and the loop stops.

When you're working with loops you should be careful not to create a condition that is always true. If you do, the loop will run forever and your program will crash. This is known as an infinite loop.

It is possible to create nested `for` loops. A nested loop is when you place one loop inside of another. We will see examples of when you might want to do this later on.

Loops can be beneficial in programming when you need to repeat a block of code a certain number of times. Even though working with `for` loops can be tricky at first,  with practice you will get the hang of it.


## How Does the For...of Loop Work, and When Should You Use It?

### Description

A `for...of` loop is used when you need to loop over values from an iterable. Examples of iterables would be arrays, and strings.

Here is the basic syntax for a `for...of` loop:

```js
for (variable of iterable) {
  // code block to be executed
}
```

The variable in the example represents the current value of the iterable that is being looped over.

If you have an array of numbers, the variable would be the current number in the array. If you have a string, the variable would be the current character in the string.

Let's take a look at a few examples so you can better understand how the `for...of` loop works.

In this first example we have an array of numbers and we want to loop over each number and log it to the console.

```js
const numbers = [1, 2, 3, 4, 5];

for (const num of numbers) {
  console.log(num);
}
```

We have created a variable called `num` that will represent the current number in the array. For iteration 1, `num` will be `1`, for iteration 2, `num` will be `2`, and so on.

Inside the loop, we are logging the current number to the console.

Here is another example where we have a string and we want to loop over each character and log it to the console.

```js
const str = 'freeCodeCamp';

for (let char of str) {
  console.log(char);
}
```

In this example, we have created a variable called `char` that will represent the current character in the string.

For each iteration, the loop will log the current character to the console.

It is important to note that you can use `let`, or `const` when declaring the variable in a `for...of` loop.

If you are going to use `const` though, make sure that the value of the variable does not change inside the loop. If it does, you will get an error.

Here is an example of using `const` that results in an error:

```js
const numbers = [1, 2, 3, 4, 5];

for (const num of numbers) {
  console.log(num);
  num = num + 1; // This will cause an error
}
```

In this example, we are trying to change the value of `num` inside the loop. Since we declared `num` with `const`, we will get an error. So, if you need to change the value of the variable inside the loop, use `let` instead.

Let's take a look at one last example dealing with an array of objects.

```js
const people = [
  { name: 'John', age: 30 },
  { name: 'Jane', age: 25 },
  { name: 'Jim', age: 40 }
];

for (const person of people) {
  console.log(`${person.name} is ${person.age} years old`);
}
```

In this example, we have an array of objects called `people`. Each object has a `name` and `age` property.

When we loop through the array, we create a variable called `person` that will represent the current object in the array.

Inside the loop, we are outputting a message to the console.

The first message will be `John is 30 years old`, the second message will be `Jane is 25 years old`, and the third message will be `Jim is 40 years old`.

`for...of` loops are really useful when you need to loop over values from an iterable like an array or a string. They are also easy to read and can make your code more concise.


## What Is the For...in Loop, and When Should You Use It?

### Description

A `for...in` loop is best used when you need to loop over the properties of an object. This loop will iterate over all enumerable properties of an object, including inherited properties and non-numeric properties.

An inherited property is a property that is inherited from the object's prototype chain. A non-numeric property is a property that is not a number or a string that can be converted to a number.

Here is the basic syntax of a `for...in` loop:

```js
for (variable in object) {
  // code block to be executed
}
```

The variable in the example represents the current property of the object that is being looped over.

Let's take a look at a few examples so you can better understand how the `for...in` loop works.

In this first example we have a `fruit` object and we want to loop over each property and log the value to the console.

```js
const fruit = {
  name: 'apple',
  color: 'red',
  price: 0.99
};

for (const prop in fruit) {
  console.log(fruit[prop]);
}
```

The `prop` variable represents the current property of the object. `fruit[prop]` is used to access the value of each property.

For the first iteration, `prop` will be `name`. For the second iteration, `prop` will be `color`, and so on.

The results logged to the console will be `apple`, `red`, and `0.99`.

In this second example, we have a nested object and we want to loop over each property and log the value to the console.

```js
const person = {
  name: 'John',
  age: 30,
  address: {
    street: '123 Main St',
    city: 'Anytown',
    state: 'CA'
  }
};

for (const prop in person) {
  console.log(person[prop]);
}
```

The `address` property is an object itself. The `for...in` loop will also loop over the properties of the `person` object and log the entire `address` object to the console.

Here is what the result will look like in the console:

```md
John
30
{ street: '123 Main St', city: 'Anytown', state: 'CA' }
```

If you want to loop over the properties of the `address` object, you can nest another `for...in` loop inside the first one.

```js
function isObject(obj) {
  return typeof obj === 'object' && !Array.isArray(obj) && obj !== null;
}

for (const prop in person) {
  if (isObject(person[prop])) {
    for (const nestedProp in person[prop]) {
      console.log(person[prop][nestedProp]);
    }
  } else {
    console.log(person[prop]);
  }
}
```

In this example have a custom function `isObject` that checks if the value is an object.

The `Array.isArray` method is used to check if the value is an array. By placing the logical NOT operator (`!`) in front of the method, we are checking if the value is not an array.

The reason why we can't just use `typeof` equals `'object'` is because arrays are also considered objects in JavaScript. We want to exclude arrays from the check.

Also, due to a historical bug in JavaScript, `typeof null` returns `'object'`. So we want to also exclude `null` values from the check.

If the condition is true, we nest another `for...in` loop that will loop over the properties of the nested object and log the value to the console.

The `nestedProp` variable represents the current property of the nested object.

Here is what the modified result will look like in the console:

```md
"John"
30
"123 Main St"
"Anytown"
"CA"
```

A `for...in` loop is useful when you need to loop over the properties of an object.

It is not recommended to use a `for...in` loop to loop over the elements of an array. Instead, use a `for...of` loop or other array methods like `forEach`, `map`, `filter`, and `reduce`, which you will learn about in future lessons.


## What Is a While Loop, and How Does It Differ from the Do...while Loop?

### Description

In previous lectures, you learned how to work with `for` loops, `for...in` loops and `for...of` loops. In this lecture, you will learn about the `while` loop and the `do...while` loop.

A `while` loop will run a block of code as long as the condition is true. Here is the basic syntax for a `while` loop:

```js
while (condition) {
  // code block to be executed
}
```

The condition is checked before the block of code is executed. If the condition is false, the block of code will not be executed.

`while` loops are useful when you do not know how many times you need to run the block of code. Here is an example of using a `while` loop to validate user input:

```js
let userInput = prompt("Please enter a number between 1 and 10");

while (isNaN(userInput) || Number(userInput) < 1 || Number(userInput) > 10) {
  userInput = prompt("Invalid input. Please enter a number between 1 and 10.");
}

alert("You entered a valid number!");
```

In this example, we are using the `prompt` method to ask for user input. Then, the `while` loop first checks if the `userInput` is `NaN`. Remember that `NaN` is "Not a Number". `isNaN` checks whether the value is `NaN` and that `NaN` is the result of an invalid number conversion because it's not a number.

So if the user types in random characters or nothing at all, then they will be prompted with the message again. The `while` loop is also checking if the `userInput`, when converted to a number, is between `1` and `10`. 

We are using the `Number` constructor here because a prompt will return a string and we want only want to be explicitly checking numbers here.

If the user input is not between `1` and `10`, the `while` loop will continue to prompt the user to enter a number between `1` and `10`.

Once the user enters a valid number, the `while` loop will exit and an alert will be displayed to the user.

Another loop similar to the `while` loop would be the `do...while` loop. Here is the basic syntax:

```js
do {
  // code block to be executed
} while (condition);
```

One key difference between a `do...while` loop and a `while` loop is that the `do...while` loop will execute the block of code at least once before checking the condition.

If the condition is true, the block of code will continue to execute. If the condition is false, the block of code will stop executing.

Here is an example of using a `do...while` loop to validate user input:

```js
let userInput;

do {
  userInput = prompt("Please enter a number between 1 and 10");
} while (Number(userInput) < 1 || Number(userInput) > 10);

alert("You entered a valid number!");
```

In this example, we have a variable called `userInput` and have not assigned a value to it. Then we have a `do...while` loop that will prompt the user to enter a number between `1` and `10`.

Then the `while` loop will check if the user input is less `than` 1 or greater than `10`. If the input is not between `1` and `10`, the `do...while` loop will continue to prompt the user to enter a number between `1` and `10`.

Once the user complies and enters a valid number, the `do...while` loop will exit and an alert will be displayed to the user.

In most cases, you will probably use the `while` loop more often than the `do...while` loop. However, it is good to know both types of loops and when to use them.


## What Are the Break and Continue Statements Used for in Loops?

### Description

A `break` statement is used to exit a loop early, while a `continue` statement is used to skip the current iteration of a loop and move to the next one.

Here is an example of using a `break` statement in a `for` loop:

```js
for (let i = 0; i < 10; i++) {
  if (i === 5) {
    break;
  }
  console.log(i);
}
```

In the example above, the loop starts counting at `0` and while `i` is less then `10`, the loop will continue to run.

Inside the loop, we check if `i` is equal to `5`. If it is, we use the `break` statement to exit the loop early. If not, we log the value of `i` to the console. So the output of the code will print the numbers `0`, `1`, `2`, `3`, and `4`.

The `break` statement is useful when you want to exit a loop early based on a certain condition. For example, if you are searching for a specific value in an array, you can use a `break` statement to exit the loop once you find the value.

Sometimes you may want to skip a particular iteration of a loop without exiting the loop entirely. This is where the `continue` statement comes in. Here is an example of using a `continue` statement in a `for` loop:

```js
for (let i = 0; i < 10; i++) {
  if (i === 5) {
    continue;
  }
  console.log(i);
}
```

Just like before, we have initialized `i` to `0` and have a condition that will run the loop as long as `i` is less than `10`.

Inside the loop, when `i` is equal to `5`, we use the `continue` statement to skip the current iteration and move to the next one.

The output of this code will print the numbers `0`, `1`, `2`, `3`, `4`, `6`, `7`, `8`, and `9`. The number `5` is skipped because of the `continue` statement.

Another thing you can do with both the `break` and `continue` statements is to use labels to specify which loop you want to break or continue.

This is useful when you have nested loops and you want to control the flow of the outer loop from within the inner loop.

Here is an example of using labels with the `break` statement:

```js
outerLoop: for (let i = 0; i < 3; i++) {
  innerLoop: for (let j = 0; j < 3; j++) {
    if (i === 1 && j === 1) {
      break outerLoop;
    }
    console.log(`i: ${i}, j: ${j}`);
  }
}
```

In this example, we have an outer `for` loop labeled `outerLoop` and an inner `for` loop labeled `innerLoop`.

When `i` is equal to `1` and `j` is equal to `1`, we use the `break` statement with the `outerLoop` label to exit the outer loop early. This will exit both the inner and outer loops.

The output of this code will log the following to the console:

```md
"i: 0, j: 0"
"i: 0, j: 1"
"i: 0, j: 2"
"i: 1, j: 0"
```

Most of the time you will not find the need to use labels with the `break` and `continue` statements, but it is good to know that you have that option if you ever need it.


## Module: Review Javascript Fundamentals


### Lecture Block: Lecture Working With Types And Objects


## What Is a String Object, and How Does It Differ from a String Primitive?

### Description

In previous modules you have been used to working with strings literals like this:

```js
const greeting = "Hello, World!";
```

But JavaScript also has string objects. Both string objects and string primitives are used to handle text but they function differently under the hood. A string object is created using the string constructor function, which wraps the primitive value in an object. Here is how you would create a string object:

```js
const greetingObject = new String("Hello, World!");

console.log(typeof greetingObject); // "object"
```

When we use the `typeof` operator we can see that the result is of type object instead of type string. One of the things that you might have been wondering about is how you can use properties like the `.length` property on string primitives.

When you use the `length` property on a string primitive, JavaScript temporarily wraps the string primitive in a string object, to perform the operation. This is why you can use the `length` property and the different methods like `repeat()`, `concat()`, and `slice()`. These types of methods and properties are referred to as instance methods also properties and static methods. You will learn about how that works in detail in future modules.

One key difference between a string object and a string primitive is how it relates to memory and performance. String primitives are usually more memory efficient and faster compared to string objects. Although you will primarily work with string primitives in your code, it's still useful to understand how string objects work.


## What Is the toString() Method, and How Does It Work?

### Description

The `toString()` method is a fundamental feature in JavaScript that converts a value to its string representation. It's a method you can use for numbers, booleans, arrays, and objects. One of the most common uses of `toString()` is to convert a number to its string representation. Here's an example:

```js
const num = 10;
console.log(num.toString()); // "10"
```

This method accepts an optional radix which is a number from `2` to `36`. This radix represents the base, such as base 2 for binary or base 8 for octal. If the radix is not specified it defaults to base 10, which is decimal. Here's an example of passing `2` as an argument to the `toString()` method:

```js
const num = 10;
console.log(num.toString(2)); // "1010"
```

The result will be `1010` which is the binary representation for the decimal number `10`.

You can also use the `toString()` method to convert arrays and objects to strings. Arrays have a custom implementation of `toString()` that converts each element to a string and joins them with commas. Here's an example:

```js
const arr = [1, 2, 3];
console.log(arr.toString()); // "1,2,3"
```

In this example all the elements of the array are joined together to form the string `1,2,3`. 

When `toString()` method is used with objects, the result will not be a stringified version of the object properties. 

```js
const person = {
  name: "John",
  age: 30,
  isStudent: true
},

console.log(person.toString()); // "[object Object]"
```

In this example, the result will be the default string representation for the object which is `[object Object]`. To get a stringified version of the `person` object properties you'll need to use `JSON.stringify()` which you will learn about more in the future lectures.

In conclusion, the `toString()` method is used for converting values to strings. Understanding how it works with different data types and how to customize it for your own objects can greatly advance your ability to manipulate and display data in your JavaScript applications.


## What Is the Number Constructor, and How Does It Work for Type Coercion?

### Description

The `Number()` constructor is used to create a number object. The number object contains a few helpful properties and methods like the `isNaN` and the `toFix` method. Here's an example using the `Number()` constructor with the `new` keyword:

```js
const myNum = new Number("34");
console.log(typeof myNum); // "object" 
```

In this example we pass in a string literal to the `Number()` constructor and the return type is of type `object` instead of a `string`. 

When the `Number()` constructor is called as a function without the `new` keyword, then the return value will be the primitive number type. Most of the time you will be using the `Number()` constructor to convert other data types to the number data type. Here's an example of converting a string to a number:

```js
const myNum = Number("100");
console.log(myNum); // 100

console.log(typeof myNum); // number
```

This is helpful when you are getting input from the user and you need to convert that string input to a number so you can perform mathematical calculations. 

If you try to call the `Number()` constructor through an empty string then the result will be the number `0`: 

```js
const num = Number("");
console.log(num); // 0
```

This is because JavaScript will try to parse the string and since it doesn't contain any digits, the result will be zero.

If you try to pass in a string with random characters then the result will be `NaN` or "Not a Number". 

```js
const num = Number("random");
console.log(num); // NaN
```

When working with booleans, `true` returns `1` because `true` gets converted to one and `false` returns `0` because `false` is converted to zero. 

```js
const boolTrue = Number(true);
const boolFalse = Number(false);

console.log(boolTrue); // 1
console.log(boolFalse); // 0
```

If you pass in `null`, the result will be `0` and if you pass `undefined`, the result will be `NaN`. 

```js
const undefinedNum = Number(undefined);
const nullNum = Number(null);

console.log(undefinedNum); // NaN
console.log(nullNum); // 0
```

When working with arrays there are a few things to consider.

An empty array will return `0`. An array with a single number will return that number. An array with multiple numbers returns `NaN`. And an array with string(s) will also return `NaN`.

```js
const emptyArr = Number([]);
const arrOneNum = Number([7]);
const arrMultiNum = Number([7, 36, 12]);
const arrStr = Number(["str1"]);
const arrMultiStr = Number(["str1", "str2"]);

console.log(emptyArr); // 0
console.log(arrOneNum); // 7
console.log(arrMultiNum); // NaN
console.log(arrStr); // NaN
console.log(arrMultiStr); // NaN
```

When working with objects, the result is always `NaN`.

```js
const obj1 = Number({});
const obj2 = Number({2: 2});
const obj3 = Number({key: "val"});
const obj4 = Number({key: true});

console.log(obj1); // NaN
console.log(obj2); // NaN
console.log(obj3); // NaN
console.log(obj4); // NaN
```

In conclusion, you'll mostly use the `Number()` constructor for type conversion more than creating a number or a number object.


### Lecture Block: Lecture Working With Arrays Variables And Naming Practices


## What Are Some Common Practices for Naming Variables and Functions?

### Description

Naming variables and functions is an important aspect of writing clean, readable and maintainable code. Good naming practices makes your code self-documenting reducing the need for extensive comments and making it easier for other developers including your future self to understand your code.

Let's start with general naming conventions in JavaScript. In previous lectures you learned about using camel case for variable names. For boolean variables, it's a common practice to use prefixes such as `is`, `has`, or `can`. This immediately tells the reader that the variable is a boolean:

```js
let isLoading = true;
let hasPermission = false;
let canEdit = true;
```

For functions the name should clearly indicate what the function does. It's often helpful to start with a verb:

```js
function getUserData(){
  /* ... */
}

function calculateTotal(){
  /* ... */
}

function validateInput(){
  /* ... */
}
```

For functions that return a boolean often called predicates, you can use the same `is`, `has`, or `can` prefixes:

```js
function isValidEmail(email) {
  /* ... */
}

function hasRequiredFields(form) {
  /* ... */
}
```

When you have functions that retrieve data it's common to start with the word `get`:

```js
function getProductDetails(productId) {
  /* ... */
}

function getUserProfile(userId) {
  /* ... */
}
```

When you have functions that set data it's common to start with the word `set`:

```js
function setUserPreferences(preferences) {
  /* ... */
}

function setPageTitle(title) {
  /* ... */
}
```

For event handler functions, you might prefix with `handle` or suffix with `handler`:

```js
function handleClick(){
  /* ... */
}

function onSubmit(){
  /* ... */
}

function keyPressHandler(){
  /* ... */
}
```

An event handler is an action that happens after an event has happened like a button click. You will learn about that in future lectures.

When naming iterator variables and loops, it's common to use single letters like `i`, `j`, or `k`, but for nested loops or more complex iterations more descriptive names can be helpful:

```js
for (let i = 0; i < array.length; i++) {
  /* ... */
}

for (let studentIndex = 0; studentIndex < students.length; studentIndex++) {
  /* ... */
}
```

For array names consider using plural nouns to indicate that the variable contains multiple items:

```js
const colors = ['red', 'green', 'blue'];
const userNames = ['Alice', 'Bob', 'Charlie'];
```

Remember the goal is to make your code as self explanatory as possible. A good rule of thumb is that if you need to add a comment to explain what a variable or function does, you might want to consider renaming it to something more descriptive.

Lastly, be consistent with your codebase or team. If your team has established naming conventions, stick to them. Consistency makes the code more readable and maintainable for everyone involved.


## How Do You Get the Length for an Array, and How Can You Create an Empty Array of Fixed Length?

### Description

In prior lectures you were first introduced to the `length` property, this property returns the number of elements in an array. So here is a quick reminder on how it works:

```js
const fruits = ['apple', 'banana', 'orange'];
console.log(fruits.length); // 3
```

It's possible to have arrays with empty slots. Empty slots are defined as slots with nothing in them. This is different than an array with the value of `undefined`. These types of arrays are known as sparse arrays. Here is an example:

```js
const sparseArray = [1, , , 4];
console.log(sparseArray.length); // 4
```

In this case even though we only have two defined elements, `1` and `4`. The length is `4` because the highest index (`3`) plus `1` gives us a length of `4`.

Now let's discuss how to create an empty array of fixed length. There are few ways to do this in JavaScript but one common method is to use the `Array()` constructor with a numeric argument. The `Array()` constructor can be used with the `new` keyword to create a new array. Here is an example:

```js
const emptyArray = new Array(5);
console.log(emptyArray.length); // 5
console.log(emptyArray); // [,,,,]
```

In this example, we create a new array using the `Array(5)`. This creates a sparse array with a length of `5` where all the slots are empty. 

Another way to create an empty array of fixed length is to use the `Array.from()` method with a length argument. This method creates an array of the specified length with all elements initialized to `undefined`: 

```js
const fixedLengthArray = Array.from({ length: 5 });
console.log(fixedLengthArray.length); // 5

// [undefined, undefined, undefined, undefined, undefined]
console.log(fixedLengthArray);
```

If you want to create an array of specific length and fill it with a default value, you can use the `Array.fill()` method: 

```js
const filledArray = new Array(3).fill(0);
console.log(filledArray); // [0, 0, 0]
```

This creates an array of length three and fills all elements with the value `0`.

Understanding how to get the length of an array and create arrays of fixed length is important for many programming tasks especially when you need to initialize arrays for specific algorithms or data structures.


### Lecture Block: Lecture Working With Code Quality And Execution Concepts


## What Are Linters and Formatters, and How Can They Help You with Code Consistency?

### Description

In the world of software development maintaining clean, consistent and error-free code is important. This is where linters and formatters come into play. These tools are essential for developers to ensure code quality and consistency across projects and teams.

Let's start with linters. A linter is a static code analysis tool that flags programming errors, bugs, stylistic errors, and suspicious constructs. The term lint comes from a Unix utility that examines C language source code. 

Today linters exist for most programming languages including JavaScript. Linters help in several ways. First they catch potential errors before runtime. For example, a linter might flag the use of undefined variable or a function being called with the wrong number of arguments. They also enforce coding standards and best practices. This might include rules about indentation, the use of semicolons, or the maximum allowed line length. Lastly, they help maintain consistency across a codebase especially when multiple developers are working on the same project.

A popular linter for JavaScript is ESLint. Here is a simple example of what ESLint might flag:

```js
function doSomething(x) {
  return x + z
}
```

In this code variable `z` is not declared, so ESLint would flag the error `z` is not defined. Also, the last statement is missing a semicolon which ESLint might also flag in the code editor.

Formatters on the other hand are tools that automatically format your code to adhere to a specific style guide. While linters can often autofix some issues, formatters are specifically designed to rewrite your code to match a predetermined style. 

Formatters ensure a consistent code style across an entire project or team regardless of individual developer preferences. They also save time and mental energy that would otherwise be spent on manual formatting. Lastly, they can make code reviews more efficient by eliminating discussions about code style. 

A popular formatter for JavaScript is Prettier. Here is an example of how Prettier might format code. Here's a before formatting:

```js
function longFunction(
  argument1, 
  argument2,
  argument3
) {return argument1 + argument2 + argument3;}
```

And then after the prettier formatting:

```js
function longFunction(argument1, argument2, argument3) {
  return argument1 + argument2 + argument3;
}
```

Both linters and formatters can be integrated into your development workflow in various ways. They can be included in your build process or added as plugins to your text editor or IDE providing real-time feedback as you code. Using linters and formatters together can significantly improve code quality and consistency. For example, you might use ESLint to catch potential errors and enforce certain coding practices, and then use Prettier to handle all formatting tasks. 

Many development teams set up these tools as part of their project configuration often with pre-commit hooks that run the linter and formatter before allowing code to be committed. This ensures that all code in the repository meets the teams standards for quality and style.

In summary, linters and formatters are powerful tools that help maintain code quality, catch potential errors early, and ensure consistency across codebases. By automating these aspects of code review they allow developers to focus more on solving problems and less on debating code style.


## What Is Memory Management, and How Does It Work in JavaScript?

### Description

Memory management is an essential concept in programming, but it can be a bit confusing for beginners, let's break it down in simple terms.

When you run a program, including JavaScript code in a web browser, it needs memory to store all the information its working with. This includes variables, functions, objects, basically everything your code creates and uses. Memory management is the process of controlling this memory, allocating it when needed, and freeing it up when it's no longer needed. In some programming languages, developers have to manually manage memory. They need to explicitly tell the computer when to allocate memory for new things and when to free up memory that's no longer needed. This can be powerful but also tricky as forgetting to free memory can lead to memory leaks.

JavaScript however uses automatic memory management. This means that JavaScript (more specifically the JavaScript engine in your web browser) takes care of memory allocation and deallocation for you. You don't have to explicitly free memory in your code. This automatic process is often called garbage collection.

Here's how it works in simple terms. First allocation happens when you create a variable, objects or functions in your JavaScript code, memory is automatically allocated to store them. Then you use this allocated memory when you work with these variables, objects or functions in your code. 

The JavaScript engine has clever ways to figure out when something in memory is no longer needed. Generally if there is no way for your program to access or use a piece of data any more it's considered no longer needed. Periodically the garbage collector runs, it finds a memory that's no longer needed and frees it up, making it available for future use. This process happens automatically which is great because it means you don't have to worry about managing memory yourself. 

However, it's still important to understand this concept because you can sometimes accidentally keep references to things you don't need anymore preventing the garbage collector from freeing that memory. For example:

```js
function createLargeArray() {
  let largeArray = new Array(1000000);
  return function() {
    console.log(largeArray.length);
  };
}

let printArrayLength = createLargeArray();
printArrayLength();
```

In this code, even after `createLargeArray` finishes running, `largeArray` can't be garbage collected because the returned function still has access to it. This is a closure, and while closures are useful they can sometimes lead to more memory usage than you might expect. You will learn more about closures in future lectures.

As a beginner, you don't need to worry too much about the intricacies of memory management. JavaScript's automatic garbage collection takes care of most things for you. However, as you advance in your JavaScript journey, understanding these concepts can help you write more efficient code, especially for larger applications or when working with limited resources. 

Remember, good coding practices, like avoiding global variables when possible and being mindful of what your functions are closing over, can help the JavaScript engine manage memory more efficiently.


## What Are Closures, and How Do They Work?

### Description

Closures are one of the most powerful and often misunderstood features in JavaScript. At its core, a closure is a function that has access to variables in its outer enclosing lexical scope, even after the outer function has returned. This might sound complex but it's a fundamental concept that enables many advanced programming patterns in JavaScript. 

To understand closures, let's start with an example:

```js
function outerFunction(x) {
    let y = 10;
    function innerFunction(){
        console.log(x + y);
    }
    return innerFunction;
}

let closure = outerFunction(5);
closure(); // Output: 15
```

In this example, `outerFunction` takes a parameter `x` and defines a local variable `y`. It then defines an `innerFunction` that uses both `x` and `y`. Finally it returns `innerFunction`. When we call `outerFunction(5)` it returns `innerFunction` which we assign to the variable `closure`. When we later call `closure()` it still has access to `x` and `y` from `outerFunction` even though `outerFunction` has already finished executing. This is the essence of a closure.

The inner function maintains a reference to its outer lexical environment, preserving access to the variables in that environment even after the outer function has completed.

Closures are particularly useful for creating private variables and functions. Consider this example:

```js
function createCounter() {
    let count = 0;
    return function () {
        count++;
        return count;
    };
}

let counter = createCounter();
console.log(counter()); // Output: 1
console.log(counter()); // Output: 2
```

In this case, `createCounter` returns a function that increments and returns a `count` variable. The `count` variable is not directly accessible from outside `createCounter`, but the returned function (our closure) has access to it. Each time we call `counter()`, it increments and returns the `count`.

Closures can also capture multiple variables from their outer scope. For example:

```js
function multiply(x) {
    return function (y) {
        return x * y;
    };
}

let double = multiply(2);
console.log(double(5)); // Output: 10
```

Here the inner function captures the `x` parameter from `multiply`. When we create `double` by calling `multiply(2)` it returns a function that always multiplies its argument by `2`.

One important thing to note about closures is that they capture variables, by reference not by value. This means if the value of a captured variable changes, the closure will see the new value. For example:

```js
function createIncrementer() {
    let count = 0;
    return function () {
        count++;
        console.log(count);
    };
}

let increment = createIncrementer();
increment(); // Output: 1
increment(); // Output: 2
```

Each time we call `increment` its working with the same `count` variable, not a copy of it's initial value. Closures are a powerful tool in JavaScript. as you continue to work with JavaScript you'll find that understanding and using closures effectively can greatly enhance your ability to write clean, efficient and powerful code.


### Lecture Block: Lecture The Var Keyword And Hoisting


## What Is the var Keyword, and Why Is It No Longer Suggested to Use It?

### Description

The `var` keyword in JavaScript is one of the original ways to declare variables. It has been part of the language since its inception and for many years it remained the primary method for creating variables. However as JavaScript evolved and developers gained more experience with the language, certain drawbacks of using `var` became apparent leading to the introduction of `let` and `const` in 2015.

When you declare a variable with `var`, it becomes function-scoped or globally-scoped. This means that if you declare a variable inside a function using `var` it's only accessible within that function. However if you declare it outside any function, it becomes a global variable accessible throughout your entire script. This behavior can sometimes lead to unexpected results and make your code harder to reason about.

A problem with `var` is that it allows you to redeclare the same variable multiple times without throwing an error. This can lead to accidental overwrites and make debugging more difficult.

```js
var num = 5;

// This is allowed and doesn't throw an error
var num = 10;
```

The most significant issue with `var` is its lack of block scoping. Variables declared with `var` inside a block like an `if` statement or a `for` loop are still accessible outside that block. 

```js
if (true) {
  var num = 5;
}
console.log(num); // 5
```

This behavior can lead to unintended variable leaks and make your code more prone to bugs.

Due to this issues, modern JavaScript development has largely moved away from `var` in favor of `let` and `const`. These keywords provide block scoping which aligns more closely with how scoping works in many other programming languages.

They also don't allow redeclaration within the same scope helping to prevent accidental overrides.

While `var` is still part of JavaScript and works in all browsers, it's generally recommended to use `let` and `const` in modern JavaScript development. They provide clear scoping rules help prevent common pitfalls and make your code's behavior more predictable.


## What Is Hoisting?

### Description

Hoisting is a behavior in JavaScript that often confuses beginners, but understanding it can help you avoid subtle bugs in your code. In simple terms hoisting is JavaScript's default behavior of moving declarations to the top of their respective scopes during the compilation phase before the code is executed.

To understand hoisting, it's important to know that JavaScript runs in two phases: the compilation phase and the execution phase. During the compilation phase, the JavaScript engine goes through your code and sets up memory space for variables and functions. This is where hoisting comes into play.

Let's start with variables hoisting, when you declare a variable using the `var` keyword, JavaScript hoists the declaration to the top of its scope. However it's crucial to note that only the declaration is hoisted, not the initialization. This means you can use a variable in your code before you have declared it, but its value will be `undefined` until you actually assign a value to it.

```js
console.log(x); // undefined
var x = 5;
console.log(5); // 5
```

In this code even though we use `x` before declaring it we don't get an error, instead we get `undefined`. This is because JavaScript hoists the declaration `var x` to the top of its scope but not the initialization `x = 5`. It's as if the code were rewritten like this:

```js
var x;
console.log(x); // undefined
x = 5;
console.log(x); // 5
```

Function hoisting works a bit differently. When you declare a function using the `function` declaration syntax both the function name and the function body are hoisted. This means you can call a function before you've declared it in your code. Here's an example of function hoisting:

```js
sayHello(); // "Hello, World!"

function sayHello(){
  console.log("Hello, World!");
}
```

In this case, we can call `sayHello()` before its declaration because the entire function is hoisted to the top of its scope.

It's important to note that hoisting works differently with `let` and `const` declarations introduced in ES6. 

```js
console.log(y); // Throws a ReferenceError
let y = 10;
```

These declarations are hoisted but they are not initialized and you can't access them before the actual declaration in your code. This is often referred to as the temporal dead zone.

Understanding hoisting can help you write cleaner, more predictable code. However, relying on hoisting can make your code harder to read and maintain. As a best practice, it's recommended to declare your variables at the top of their scope and your functions before you use them regardless of hoisting. This make your code's behavior more explicit and easier for other including your future self to understand.


### Lecture Block: Lecture Understanding Modules Imports And Exports


## What Is a Module in JavaScript, and How Can You Import and Export Modules in Your Program?

### Description

In JavaScript, a module is a self-contained unit of code that encapsulates related functions, classes, or variables.

Think of a module as a building block for your application, much like a chapter in a book. Each module focuses on a specific functionality, making your code more organized, maintainable, and reusable. Modules help prevent naming conflicts and allow you to structure your application into separate, interconnected pieces.

The concept of modules in JavaScript has evolved over time, but the most widely used and supported approach is the ES6 (ECMAScript 2015) module system. This system provides a standardized way to define and use modules across different JavaScript environments.

To create a module, you write your JavaScript code in a separate file. Any variables, functions, or classes you want to make available to other parts of your application need to be explicitly exported. You can do this using the `export` keyword.

For example, let's say you have a file called `math.js` with some math functions:

```js
export function add(a, b) {
    return a + b;
}

export function subtract(a, b) {
    return a - b;
}

const PI = 3.14159;
export { PI };
```

In this example, we're exporting two functions (`add` and `subtract`) and a constant (`PI`). You can export as many items as you need from a single module.

To use these exported items in another part of your application, you need to import them. This is done using the `import` keyword.

Let's say you want to use these math functions in a file called `app.js`:

```js
import { add, subtract, PI } from './math.js';

console.log(add(5, 3));        // Outputs: 8
console.log(subtract(10, 4));  // Outputs: 6
console.log(PI);               // Outputs: 3.14159
```

Here, we're importing the specific functions and constant we need from the `math.js` module. The `'./math.js'` part tells JavaScript where to find the module file relative to the current file.

Sometimes, you might want to import everything a module exports. You can do this using the asterisk (`*`) syntax:

```js
import * as Math from './math.js';

console.log(Math.add(5, 3));        // Outputs: 8
console.log(Math.subtract(10, 4));  // Outputs: 6
console.log(Math.PI);               // Outputs: 3.14159
```

In this case, all exports from `math.js` are imported as properties of an object called `Math`.

Another common pattern is to have a default export in a module. This is typically used when a module primarily exports a single function. You can only have one default export per module.

Here's how it looks:

```js
// In math.js
export default function multiply(a, b) {
    return a * b;
}

// In app.js
import multiply from './math.js';

console.log(multiply(4, 5));  // Outputs: 20
```

Notice that when importing a default export, you don't need to use curly braces, and you can name the import whatever you want.

It's important to note that to use ES6 modules in the browser, you need to specify the `type` as `module` in your `script` tag:

```html
<script type="module" src="app.js"></script>
```

Modules provide a powerful way to organize and structure your JavaScript code. They allow you to break your application into smaller, manageable pieces, promote code reuse, and help maintain a clean separation of concerns. As you build larger applications, you'll find that modules become an essential tool in your JavaScript development toolkit.


## Module: Higher Order Functions And Callbacks


### Lecture Block: Lecture Working With Higher Order Functions And Callbacks


## What Is a Callback Function, and How Does It Work with the forEach Method?

### Description

In JavaScript, a callback function is a function that is passed as an argument to another function and is executed after the main function has finished its execution. It's a way to ensure that certain code doesn't execute until a previous operation has been completed.

This concept is fundamental to understanding many aspects of JavaScript, including how the `forEach` method works.

Let's start by understanding what a callback function is in a simple context.

Imagine you have a function that performs a task, and you want to do something after that task is complete. Instead of writing all the code in one big function, you can pass a second function (the callback) to be executed when the first function is done. This allows for more flexible and modular code.

Now, let's introduce the `forEach` method. `forEach` is a built-in method for arrays in JavaScript. It allows you to iterate over each element in an array and perform an operation on each element. The operation you want to perform is defined in a callback function that you provide to `forEach`.

Here's an example of how `forEach` works with a callback function:

```js
let numbers = [1, 2, 3, 4, 5];

numbers.forEach(function(number) {
  console.log(number * 2);
});
```

In this example, we have an array of numbers. We use the `forEach` method on this array, and we provide a callback function as an argument to `forEach`.

This callback function takes one parameter, which represents each element in the array. The `forEach` method will call this callback function once for each element in the array.

The callback function in this case multiplies each number by `2` and logs the result. So, when this code runs, it will output:

```md
2
4
6
8
10
```

It's important to understand that the callback function is called once for each element in the array, in order. `forEach` takes care of the looping for you, so you don't have to write a `for` loop yourself.

You can also use an arrow function as the callback, which can make your code even more concise:

```js
let numbers = [1, 2, 3, 4, 5];
numbers.forEach(number => console.log(number * 2));
```

This does exactly the same thing as the previous example, but with less code.

The callback function in `forEach` can actually take up to three arguments: the current element, the index of the current element, and the array that `forEach` was called upon.

Here's an example using all three:

```js
let numbers = [1, 2, 3, 4, 5];
numbers.forEach((number, index, array) => {
  console.log(`Element ${number} is at index ${index} in array ${array}`);
});
```

This would log information about each element, its index, and the original array.

Understanding callback functions and methods like `forEach` is important as you progress in JavaScript. They form the basis for many more advanced concepts in the language, particularly in asynchronous programming which you will learn about in future lectures.


## What Are Higher-Order Functions?

### Description

Higher order functions are a powerful concept in JavaScript that can significantly enhance your coding abilities and make your code more flexible and reusable.

In essence, a higher order function is a function that either takes one or more functions as arguments, returns a function, or both.

To understand higher order functions, let's first consider functions as first-class citizens in JavaScript. This means that functions can be treated like any other value – they can be assigned to variables, passed as arguments to other functions, and returned from functions. This flexibility is what enables the creation and use of higher order functions.

One common use of higher order functions is to abstract away complex operations.

For example, you might have a function that performs a specific operation on each element of an array. Instead of writing separate functions for different operations, you can create a higher order function that takes the operation as an argument. This allows you to reuse the same function structure with different behaviors.

Here's an example to illustrate this concept:

```js
function operateOnArray(arr, operation) {
  let result = [];
  for (let i = 0; i < arr.length; i++) {
    result.push(operation(arr[i]));
}
  return result;
}

function double(x) {
    return x * 2;
}

let numbers = [1, 2, 3, 4, 5];
let doubledNumbers = operateOnArray(numbers, double);
console.log(doubledNumbers); // Outputs: [2, 4, 6, 8, 10]
```

In this example, `operateOnArray` is a higher order function. It takes an array and a function (`operation`) as arguments. It then applies the operation to each element of the array. The double function is passed as an argument to `operateOnArray`, demonstrating how functions can be used as values.

Higher order functions can also return functions. This is particularly useful for creating specialized functions based on more general ones. This concept is often referred to as function factories. Here's an example:

```js
function multiplyBy(factor) {
  return function(number) {
    return number * factor;
  }
}

let double = multiplyBy(2);
let triple = multiplyBy(3);

console.log(double(5)); // Outputs: 10
console.log(triple(5)); // Outputs: 15
```

In this case, `multiplyBy` is a higher order function that returns a new function. This new function is specialized based on the factor passed to `multiplyBy`. This allows us to create custom multiplication functions with ease.

Higher order functions are not just a theoretical concept – they're widely used in JavaScript.

Many built-in methods for arrays in JavaScript, such as `map()`, `filter()`, and `reduce()`, are higher order functions. These methods take a function as an argument and apply it to the elements of the array in various ways. You will learn more about these methods in future lectures.

The use of higher order functions can lead to more declarative and easier-to-understand code.

Instead of describing step-by-step how to accomplish a task (imperative programming), higher order functions allow you to describe what you want to accomplish (declarative programming). This can make your code more readable and maintainable.

As you continue to work with JavaScript, you'll encounter and use higher order functions frequently. They're a key part of functional programming in JavaScript and are essential for writing clean, efficient, and flexible code.

Understanding and utilizing higher order functions will significantly enhance your ability to write sophisticated and elegant JavaScript programs.


## What Is the Map Method, and How Does It Work?

### Description

The `map` method is a powerful and widely used function in JavaScript that operates on arrays. It is designed to create a new array by applying a given function to each element of the original array.

This method does not modify the original array but instead returns a new array containing the results of the function applied to each element.

Here is an example of using the `map` method on an array of numbers:

```js
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map((num) => num * 2);
console.log(numbers); // [1, 2, 3, 4, 5]
console.log(doubled); // [2, 4, 6, 8, 10]
```

To create a new array where each number is doubled, we are using the `map` method. The `map` method accepts a callback function where the function is called on every single element in the array.

In this case, each number in the array will be multiplied by `2`. The result will be a new array of the numbers `2,4,6,8,10`.

The callback function can accept up to three arguments.

The first argument is the current element being processed.

```js
const numbers = [3, 4, 5, 6, 7].map((element) => {
  console.log("Element:", element);
  return element * 2;
});
```

The second argument is the index of the current element being processed.

```js
const numbers = [3, 4, 5, 6, 7].map((element, index) => {
  console.log("Element:", element);
  console.log("Index:", index);
  return element * 2;
});
```

The third argument is the array where `map` is being called on.

```js
const numbers = [3, 4, 5, 6, 7].map((element, index, array) => {
  console.log("Element:", element);
  console.log("Index:", index);
  console.log("Array:", array);
  return element * 2;
});
```

Understanding and effectively using the `map` method can significantly improve your ability to work with arrays in JavaScript. In future lectures, we'll dive deeper into more advanced uses of `map` and explore how it can be a powerful tool for building dynamic and efficient programs.


## What Is the Filter Method, and How Does It Work?

### Description

The `filter` method is used to create a new array with elements that pass a specified test, making it useful for selectively extracting items based on criteria.

In this example, we are using the `filter` method, to create a new array of only even numbers:

```js
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const evenNumbers = numbers.filter((num) => num % 2 === 0);

console.log(evenNumbers); // [2, 4, 6, 8, 10]
```

In this example, the `filter` method applies a callback function to each element of the `numbers` array. The callback checks whether each number is even using the modulo operator (`%`).

If the number is even, the function returns `true`, and that number is included in the new array. If it's odd, the function returns `false`, and that number is excluded.

Just like the `map` method, the callback function for the `filter` method accepts the same three arguments: the current element being processed, the index, and the array.

It's important to note that if no elements pass the test, the `filter` method returns an empty array.

```js
const numbers = [2, 4, 6, 8].filter((num) => num > 10);

console.log(numbers); // []
```

`filter` is incredibly versatile and can be used in many scenarios. You can use it to remove `null` or `undefined` values from an array, to filter objects based on their properties, or to implement search functionality.

Here's an example of using the `filter` method to return an array of objects for individuals younger than `30` years old.

```javascript
const developers = [
  { name: "Alice", age: 25 },
  { name: "Bob", age: 30 },
  { name: "Charlie", age: 35 },
  { name: "David", age: 25 }
];

const youngPeople = developers.filter((person) => person.age < 30);
console.log(youngPeople);

// [{ name: "Alice", age: 25 }, { name: "David", age: 25 }]
```

Throughout the rest of this curriculum, you will be using the `map` and `filter` methods very frequently. So, building familiarity with them will not only streamline your coding process but also help you write cleaner and more efficient code.


## What Is the Reduce Method, and How Does It Work?

### Description

The `reduce` method is a function in JavaScript that allows you to process an array and condense it into a single value. This single value can be a number, a string, an object, or even another array.

It's called `reduce` because it reduces an array to a single output. While it might seem complicated at first, understanding `reduce` can greatly simplify your code in many situations.

At its core, `reduce` works by applying a function to each element in the array, in order, passing the result of each calculation on to the next. This function is often called the reducer function.

The reducer function takes two main parameters: an accumulator and the current value. The accumulator is where you store the running result of your operations, and the current value is the array element being processed.

Let's look at an example to illustrate how `reduce` works:

```js
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce(
  (accumulator, currentValue) => accumulator + currentValue,
  0
);

console.log(sum); // 15
```

In this example, we're using `reduce` to get the sum of all the numbers in the array.

The reducer function takes the accumulator (which starts at `0`, as specified by the second argument to `reduce`) and adds each number to it.

The result of each addition becomes the new accumulator for the next iteration.

The `reduce` method can also take an initial value as its second argument. This is the value that the accumulator starts with. In the example above, we set it to `0`.

If you don't provide an initial value, `reduce` will use the first element of the array as the initial accumulator and start the process from the second element.

One of the great things about `reduce` is its flexibility. Because you define the reducer function, you have complete control over how the array is processed and what kind of result you want to produce. This makes `reduce` extremely powerful, but it can also make it a bit challenging to understand at first.

With practice, you will get the hang of working with the `reduce` method.


## What Is Method Chaining, and How Does It Work?

### Description

Method chaining is a programming technique that allows you to call multiple methods on the same object in a single line of code. This technique can make your code more readable and concise, especially when performing a series of operations on the same object.

Let's look at an example using different string methods:

```js
const result = "  Hello, World!  "
  .trim()
  .toLowerCase()
  .replace("world", "JavaScript");

console.log(result); // "hello, JavaScript!"
```

In this example, we start with a string and perform three operations in sequence: trim whitespace, convert to lowercase, and replace the string `world` with `JavaScript`. Each method returns a new string, which becomes the target of the next method call.

Method chaining can significantly improve code readability when working with complex operations.

For instance, consider this example using the `filter`, `map` and `reduce` methods:

```js
const transactions = [
  { amount: 100, type: "credit" },
  { amount: 20, type: "cash" },
  { amount: 150, type: "credit" },
  { amount: 50, type: "cash" },
  { amount: 75, type: "credit" }
];

const totalCreditWithBonus = transactions
  .filter((transaction) => transaction.type === "credit")
  .map((transaction) => transaction.amount * 1.1)
  .reduce((sum, amount) => sum + amount, 0);

console.log(totalCreditWithBonus); // 357.5
```

In this example, we have an array of transactions where each object has an amount and a credit card or cash type.

We first filter through the transactions and create a new array of just credit card transactions. Then, we chain the `map` method to the filtered result and for each transaction amount, we multiply it by `1.1` which represents a `10%` bonus.

Then, we take that result and chain the `reduce` method to add up each of the amounts which results in `357.5`.

While method chaining can make code more concise and readable, it's important to use it judiciously.

Very long chains can become difficult to debug, as it's not immediately clear which step in the chain might be causing an issue. It's often a good practice to break very long chains into multiple steps for better clarity and easier debugging.


## How Does the Sort Method Work?

### Description

There are many different ways to sort your data in programming. In this lecture, we will focus on the built-in `sort` method in JavaScript.

The `sort` method is used to arrange the elements of an array and returns a reference to the sorted array. No copy is made because the elements are sorted in place.

Here is the basic syntax for the `sort` method:

```js
array.sort(compareFunction);
```

The `compareFunction` is an optional parameter that specifies a function that defines the sort order. We will take a look later on how to use a compare function when sorting numbers.

In this first example, we have an array of strings in random order.

```js
const fruits = ["Banana", "Orange", "Apple", "Mango"];
```

Our goal is to sort the array in alphabetical order. We can do this by calling the `sort` method on the `fruits` array.

```js
const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.sort();

console.log(fruits); // ["Apple", "Banana", "Mango", "Orange"]
```

The result will be a sorted array of fruits in alphabetical order starting with the fruit `Apple`.

In this next example, we want to sort the following array of numbers:

```js
const numbers = [414, 200, 5, 10, 3];
```

If we try to use the `sort` method on this `numbers` array, we will get unexpected results.

```js
const numbers = [414, 200, 5, 10, 3];
numbers.sort();

console.log(numbers); // [10, 200, 3, 414, 5]
```

We expected to see the result `[3, 5, 10, 200, 414]`, but instead we got `[10, 200, 3, 414, 5]`.

This is because the `sort` method converts the elements to strings and then compares their sequences of UTF-16 code units values.

UTF-16 code units are the numeric values that represent the characters in the string. Examples of UTF-16 code units are the numbers `65`, `66`, and `67` which represent the characters `A`, `B`, and `C` respectively.

So, the number `200` appears before the number `3` in the array, because the string `200` comes before the string `3` when comparing their UTF-16 code units.

The solution to this problem is to provide a compare function to the `sort` method.

Here is an example of how to sort the `numbers` array using a compare function:

```js
const numbers = [414, 200, 5, 10, 3];

numbers.sort((a, b) => a - b);

console.log(numbers); // [3, 5, 10, 200, 414]
```

The parameters `a` and `b` are the two elements being compared. The compare function should return a negative value if `a` should come before `b`, a positive value if `a` should come after `b`, and zero if `a` and `b` are equal.

The first comparison is between the numbers `414` and `200`. The result of `414 - 200` is `214`, which is a positive value. This means that `414` should come after `200` in the sorted array.

The next comparison is between the numbers `200` and `5`. The result of `200 - 5` is `195`, which is a positive value. This means that `200` should come after `5` in the sorted array.

We repeat this process for all the elements in the array, and the result is a sorted array of numbers.

Even though there are many more ways to sort data in programming, the `sort` method in JavaScript can be useful and efficient in a lot of cases when you need to sort an array of elements.


## How Do the every() and some() Methods Work?

### Description

When you're working with arrays in JavaScript, there are often times when you want to check if all elements in an array meet a certain condition, or if at least one element meets a condition.

This is where the `every()` and `some()` methods come in handy. These methods are powerful tools that can simplify your code and make it more readable.

Let's start with the `every()` method. This method tests whether all elements in an array pass a test implemented by a provided function. In simpler terms, it checks if every single item in your array satisfies a condition you specify.

The `every()` method returns `true` if the provided function returns `true` for all elements in the array. If any element fails the test, the method immediately returns `false` and stops checking the remaining elements.

Here's an example to illustrate how `every()` works:

```js
const numbers = [2, 4, 6, 8, 10];
const hasAllEvenNumbers = numbers.every((num) => num % 2 === 0);

console.log(hasAllEvenNumbers); // true
```

In this example, we're checking if all numbers in the array are even. The function we provide to `every()` checks if each number is divisible by `2` with no remainder. Since all numbers in our array are indeed even, `hasAllEvenNumbers` will be true.

Now, let's look at the `some()` method.

While `every()` checks if all elements pass a test, `some()` checks if at least one element passes the test. The `some()` method returns `true` as soon as it finds an element that passes the test. If no elements pass the test, it returns `false`.

Here's an example of how `some()` works:

```js
const numbers = [1, 3, 5, 7, 8, 9];
const hasSomeEvenNumbers = numbers.some((num) => num % 2 === 0);

console.log(hasSomeEvenNumbers); // true
```

In this example, we're checking whether any number in the array is even. The function we pass to `some()` is the same as before. Even though most numbers in our array are odd, `hasEven` will be `true` because there's at least one even number (`8`) in the array.

Both `every()` and `some()` are very useful when you need to validate data or check for certain conditions in your arrays. They can often replace more verbose loops and conditional statements, making your code cleaner and more expressive.

It's important to note that both methods stop executing as soon as they can determine the result. For `every()`, this means it stops as soon as it finds a `false` result. For `some()`, it stops as soon as it finds a `true` result. This can be beneficial for performance, especially with large arrays.


## Module: Dom Manipulation And Events


### Lecture Block: Lecture Working With The Dom Click Events And Web Apis


## What Is an API, and What Are Web APIs?

### Description

Let's learn about APIs and why they’re essential for web development. API stands for Application Programming Interface. APIs establish a set of rules and protocols that allow software applications to communicate with each other and exchange data efficiently.

You can think of them as constructs that allow developers to create more complex functionality based on simpler building blocks that are already implemented.

There are various types of APIs. Web APIs are specifically designed for web applications. There are different types of web APIs for client-side JavaScript development. They are not part of JavaScript itself.

These types of APIs are often divided into two main categories: browser APIs and third-party APIs.

Browser APIs expose data from the browser. As a web developer, you can access and manipulate this data using JavaScript.

They also provide access to various functionalities, such as manipulating the structure of the website, handling events, working with storage, and communicating with the network.

Some examples of commonly used Browser APIs include:

The DOM API, which you can use to manipulate HTML elements, their styles, and attributes. You will learn much more about the DOM in the coming lectures. It’s a core concept in web development.

The Storage API, to store data locally on the user’s device.

And more. 

There are various browser APIs that you can use to handle user interactions and to get more information from the browser, like the user's current location. 

You can also work with other types of elements, such as video and audio.

Browser APIs can be helpful tools for building powerful web applications. They already come built into the browser.

But you can also use third-party APIs, which are not built into the browser by default. To use them, you need to retrieve their code in some way. Typically, they come with detailed documentation explaining how to use their services.

An example is the Google Maps API, which you can use to display interactive maps on your website.

There are various types of third-party web APIs, including weather APIs, social media APIs, payment APIs, data APIs, translation APIs, and more. You just need to find the API that fits your needs.

Web APIs are essential tools for building modern web applications that can interact with various services and data sources. By learning how to leverage their power, you will expanding your toolset for creating dynamic and engaging websites.


## What Is the DOM, and How Do You Access Elements?

### Description

Let's learn about the DOM and why it's so important for web development. DOM stands for Document Object Model. It's a programming interface that lets us interact with HTML documents.

With the DOM, you can add, modify, or delete elements on a webpage. You can even make your website interactive by making elements listen to and respond to events.

In the DOM, an HTML document is represented as a tree of nodes. Each node represents an HTML element from the HTML document:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>DOM Example</title>
  </head>
  <body>
    <h1>What is the DOM?</h1>
    <h2>Let's learn about the DOM</h2>
  </body>
</html>
```

This is a diagram representing the basic DOM structure of our example:

```md
Document
========

HTML
-----

- Head
  - Title
- Body
  - H1
  - H2   
```

Of course, this can be more detailed and complex based on the structure of the HTML markup of a webpage.

The HTML document is the root node in the DOM hierarchy. It has one child node, the `html` element. This is the root element of the HTML document, since all other nodes descend from it.

The `html` element has two children: `head` and `body`.

The `head` element contains metadata about the document. It provides essential information about the webpage.

The `body` element contains the visible content of the webpage.

You can access these elements with JavaScript, work with them in your code, and even modify them dynamically. That's the power of the DOM and web APIs.

To access these elements in JavaScript, you can use `getElementById()` and `querySelector()` methods. These methods are web APIs because they provide standardized ways to interact with the DOM using JavaScript.

With `getElementById()`, you can get an object that represents the HTML element with the specified `id`. Remember that `id`s must be unique in every HTML document, so this method will only return one `Element` object. Here you can see an example:

```js
const container = document.getElementById("container");
```

This line of JavaScript code gets an element with the `id` value of `container` and assigns that object to a JavaScript constant. You must pass the `id` within quotation marks as an argument. If you log this object to the console, you will see it in the output:

```js
console.log(container); // <div id="container">...</div>
```

`querySelector()` is broader than `getElementById()`. With `querySelector()`, you can get the first element in the HTML document that matches the CSS selector passed as argument. In this example, you will get the first element with the class `section` and assign it to a variable:

```js
const section = document.querySelector(".section");
```

You also have other methods to match multiple elements, like `getElementsByClassName()` and `querySelectorAll()`. You'll learn more about them in a coming module.

By understanding how to use web APIs to manipulate the DOM efficiently, you can create powerful and interactive web applications.


## How Do DOM Nodes Exist Relative to Each Other in the DOM Tree?

### Description

Let's learn about DOM nodes and their relationships in the DOM tree.

Just as a real tree has large and small branches connected in a hierarchical structure, DOM nodes also have direct and indirect relationships with one another. We will use this example to illustrate these relationships:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>DOM Tree Example</title>
  </head>
  <body>
    <h1>Heading 1</h1>
    <p>Paragraph 1</p>
    <ul>
      <li>List item 1</li>
      <li>List item 2</li>
    </ul>
  </body>
</html>
```

Let's start at the top. The root of the DOM tree is the `html` element. It's the top-level container for all the content of an HTML document. All other nodes are descendants of this root node.

Then, below the root node, we find other nodes in the hierarchy. A parent node is an element that contains other elements. A child node is an element that is contained within another element.

In this example, the `body` element is the parent of the paragraph element while the paragraph element is a child of the `body` element. These elements are represented as nodes in the DOM tree with the same relationships.

Just like we have parent nodes and child nodes, we also have sibling nodes. Sibling nodes are elements that share the same parent. In our example, two list item elements share the same unordered list parent, so they are siblings. 

Similarly, the `h1` and paragraph elements are siblings because they share the same parent, the `body` element.

We also have indirect relationships across different levels in the hierarchy. Descendant nodes are elements that are contained within another element, either directly or indirectly. An element is considered a descendant of another one if it can be reached by going through the DOM tree downwards from its ancestor.

In our example, the list item `li` elements are descendants of the `body` element, since they are indirectly contained within it.

An ancestor node is an element that is higher up in the DOM tree hierarchy than another element. In our example, the `body` element is an ancestor of the list item `li` elements.

Understanding these relationships is essential for manipulating and navigating the DOM tree using JavaScript.


## What Is the querySelectorAll() Method, and When Should You Use It?

### Description

Let's learn about the `querySelectorAll()` method. You can use this method to get a list of all the DOM elements that match a specific CSS selector.

This is how you can call the `querySelectorAll()` method:

```js
document.querySelectorAll(selectors);
```

Call it on the `document` object and pass a string with the CSS selectors as an argument. The argument must be a valid CSS selector string. Otherwise, a `SyntaxError` exception will be thrown.

`querySelectorAll()` returns a `NodeList` object, a collection of nodes that match the specified CSS selector.

The list will contain one `Element` object for each element that matches the CSS selectors. If no matches are found, the list will be empty.

The elements will be in the order in which they appear in the HTML document. For example, you can match all elements of a specific type:

```js
document.querySelectorAll("div");
```

All elements with a specific class:

```js
document.querySelectorAll(".rounded");
```

All elements with a specific ID:

```js
document.querySelectorAll("#logo");
```

Or all elements with a specific attribute, like all links that take users to a specific URL:

```js
document.querySelectorAll("a[href='https://www.freecodecamp.org/']");
```

You can also use more complex CSS selectors, like this one, which matches all list items within an unordered list element with the class `ingredients`:

```js
document.querySelectorAll("ul.ingredients li");
```

Since the method will return a collection of nodes, you can assign this collection to a variable and use it in your programs to work with the individual elements, like you can see in this example with the general syntax:

```js
const matches = document.querySelectorAll(selectors); 
```

For example, if you have this unordered list with three list items:

```html
<ul class="ingredients">
  <li>Flour</li>
  <li>Cheese</li>
  <li>Water</li>
</ul>
```

You can call the `querySelectorAll()` method to match all list items within the unordered list with the class `ingredients` and assign the return value to the `matches` constant:

```js
const matches = document.querySelectorAll("ul.ingredients li");
```

This will return a collection of three nodes. Each node represents a list item element:

```js
// NodeList(3)
{
  0: `<li>Flour</li>`,
  1: `<li>Cheese</li>`,
  2: `<li>Water</li>`,
  length: 3,
}
```

You can work with this collection exactly like you would work with any other JavaScript array.

For example, you can show it in the console with `console.log()`:

```js
console.log(matches);
```

You can also check the length of the collection with the `length` property:

```js
console.log(matches.length);
```

The output will be an integer representing the number of nodes in the collection:

```md
3
```

You can also access the individual elements of the collection with their corresponding indices. The first element will be at index `0`:

```js
console.log(matches[0]);
console.log(matches[1]);
console.log(matches[2]);
```

This is the output: 

```html
<li>Flour</li>
<li>Cheese</li>
<li>Water</li>
```

The elements are printed one by one on the console.

You can also iterate over the elements with a `for` loop:

```js
for (let i = 0; i < matches.length; i++) {
  console.log(matches[i]);    
}
```

The output will be exactly the same in this case. But this can be very powerful for working with all the elements of the collection.

The `querySelectorAll()` method in JavaScript is a powerful tool for selecting multiple elements based on their CSS selectors. With this method, you can select specific elements within your web pages and manipulate them as needed.


## How Do You Create New Nodes Using innerHTML and createElement()?

### Description

Let's see how you can create nodes with `innerHTML` and `createElement()`.

We'll start with `innerHTML`.

`innerHTML` is a property of `Element` objects that you can use to set their HTML markup. With `innerHTML`, you can set the HTML structure of an existing element with a string, creating all the necessary nodes.

This is an example. We have an empty `div` and we'll add some elements within it using the `innerHTML` property:

```html
<div id="container">
  <!-- Add new elements here -->
</div>
```

First, we need to select the element by its ID:

```js
const container = document.getElementById("container");
```

Then, we set the `innerHTML` property of the container to a string. This string has to have all the markup necessary to represent the nodes and the structure that you want to create. You can think of it as writing HTML within a string.

```js
container.innerHTML = "<ul><li>Cheese</li><li>Tomato</li></ul>";
```

We will set the `innerHTML` of this element to an unordered list of pizza ingredients (cheese and tomato).

You can also write the string on multiple lines if it makes the markup easier to understand. The important thing is that the markup accurately represents the HTML structure you want to create.

After running this code, you will see the following HTML structure if you inspect your markup. 

```html
<div id="container">
  <ul>
    <li>Cheese</li>
    <li>Tomato</li>
  </ul>
</div>
```

The new nodes were created and added dynamically to the DOM after the string was parsed.

`innerHTML` can be very helpful for certain scenarios. However, it does have some security risks that you should be familiar with. You shouldn't use it if you won't have full control over the string. 

For example, if the string will be entered by the user, you shouldn't use `innerHTML` because the user might insert malicious content into your website. Because of this, it’s usually recommended to use `textContent` instead, to insert plain text.

Another way to create a new node is by using the `createElement()` method. With this new method, you can create a new element by specifying its tag name. 

For example, if you want to create an image element, you would pass the `img` tag as a string when calling this method:

```js
document.createElement("img");
```

And you can assign this new object to a variable:

```js
const img = document.createElement("img");
```

The `createElement()` method returns a new `HTMLElement` object if the document is an `HTMLDocument`.  Else, it returns an `Element` object.

Once you have this new element ready, you can add it to the DOM as a child of another existing element using the `appendChild()` method, or you can insert it at a specific location using other methods. Choose the one that best fits your needs.

Creating nodes with `innerHTML` and `createElement()` allows you to dynamically manipulate the structure and content of your websites. By combining these techniques, you can build interactive web applications.


## What Is the Difference Between innerText, textContent, and innerHTML?

### Description

Let's learn about `innerText`, `textContent`, and `innerHTML`.

These are properties that you can access in JavaScript to get or change the content of an HTML element. Even if they may look very similar at first, they do have key differences. Choosing the right one depends on your specific use case, so let's dive in.

Let's start with `innerText`.

`innerText` represents the visible text content of the HTML element and its descendants. This property doesn't include hidden text or HTML tags, only rendered text. 

For example, here you can see a `div` element that contains two paragraphs:

```html
<div id="container">
  <p>Hello, World!</p>
  <p>I'm learning JavaScript</p>
</div>
```

If we get a reference to this HTML element in our JavaScript code using `getElementById()`, we can access the `innerText` property of this element:

```js
const container = document.getElementById("container");
console.log(container.innerText);
```

This is the inner text of this element:

```md
Hello, World!
I'm learning JavaScript
```

The property returns a string with the text contained within the element, including text from its descendants.

You should know that `innerText` only returns the text that is visible at the particular moment when the string is requested. If a child element is hidden, its text won't be visible.

This is an example where the second paragraph is hidden:

```html
<div id="container">
  <p>Hello, World!</p>
  <p hidden>I'm learning JavaScript</p>
</div>
```

If we try to log the `innerText` again, now the output won’t have the text of the second paragraph:

```js
console.log(container.innerText);
```

This will be the output:

```md
Hello, World!
```

You can set the `innerText` of an HTML element like this, but this will replace the existing text and add a line break element (`br`) element for every line break:

```js
container.innerText = "JavaScript is awesome!";
```

Since `innerText` takes visibility into account, getting its value triggers a process called "reflow", that recalculates the position of certain elements on the website. This process can be computationally intensive, so you should avoid triggering it if possible.

Great. Now let's talk about `textContent`. 

`textContent` returns the plain text content of an element, including all the text within its descendants.

The most important difference between `innerText` and `textContent` is that `textContent` always returns the full text content of an HTML element and its descendants, regardless of whether it's visible or hidden.

Here we have the same example in HTML:

```html
<div id="container">
  <p>Hello, World!</p>
  <p>I'm learning JavaScript</p>
</div>
```

If you try to access this property, you'll see the text of the element and its descendants as the output, keeping the indentation and spacing:

```js
const container = document.getElementById("container");
console.log(container.textContent);
```

```md
Hello, World!
I'm learning JavaScript
``` 

If an HTML element is not visible, like you can see over here, where we’ve hidden the second paragraph, its text will still be included in this property:

```html
<div id="container">
  <p>Hello, World!</p>
  <p hidden>I'm learning JavaScript</p>
</div>
```

You will see the same output:

```md
Hello, World!
I'm learning JavaScript
``` 
  
`textContent` will also include the content of elements like `script` and `style`.

If you try to replace the value of `textContent` on a node, it will remove all its child nodes and replace them with a single text node containing the new string:

```js
const container = document.getElementById("container");
container.textContent = "Hello, World!";
```

And finally, let's talk about how `textContent` and `innerText` differs from `innerHTML`.

Remember that with `innerHTML` you can set the inner HTML content of an element. This is helpful for injecting new HTML into the DOM dynamically.

However, remember that this poses a security risk if you don't have control over the string, such as strings containing data entered by the user. If that data is malicious, it can lead to serious security issues.

To avoid this, it's recommended to use the `textContent` property to insert plain text instead.

The `innerText`, `textContent`, and `innerHTML` properties in JavaScript provide different ways to access and manipulate the content of HTML elements. You should understand the differences between these properties if your goal is to work with HTML content in JavaScript effectively.


## How Do You Add and Remove Nodes from the DOM with appendChild() and removeChild()?

### Description

There will be times where you will need to add or remove nodes from the DOM and there are a couple of Web APIs you can use.

In this lecture, we will cover the `appendChild()` and `removeChild()` methods.

The `appendChild()` method is used to add a node to the end of the list of children of a specified parent node.

Here is the basic syntax for the `appendChild()` method:

```js
parentNode.appendChild(newNode);
```

Let's take a look at an example to better understand how to use the `appendChild()` method.

In this example, we have an unordered list element with an ID of `desserts` inside the HTML. This list contains two list items of `Cake` and `Pie`:

```html
<ul id="desserts">
  <li>Cake</li>
  <li>Pie</li>
</ul>
```

To access that list inside the JavaScript file, we can use the `getElementById()` method:

```js
const dessertsList = document.getElementById("desserts");
```

We have a variable called `dessertsList` that stores the reference to the `ul` element with the ID of `desserts`.

Then we need to create a new list item element using the `createElement()` method:

```js
const dessertsList = document.getElementById("desserts");
const listItem = document.createElement("li");
```

The following code will create a new list item element and store it in a variable called `listItem`.

To add that node to the end of the list of children of the `ul` element, we can use the `appendChild()` method:

```js
const dessertsList = document.getElementById("desserts");
const listItem = document.createElement("li");

dessertsList.appendChild(listItem);
```

If you were to run this code, you will see that a new list item element is added to the end of the list of children of the `ul` element.

The problem is that the new list item element is empty. To add text content to the new list item element, you can use the `textContent` property:

```js
const dessertsList = document.getElementById("desserts");
const listItem = document.createElement("li");

listItem.textContent = "Cookies";
dessertsList.appendChild(listItem);
```

Now the list will show `Cake`, `Pie`, and `Cookies`.

To remove a node from the DOM, you can use the `removeChild()` method.

Here is the basic syntax for the `removeChild()` method:

```js
parentNode.removeChild(childNode);
```

Let's take look at an example where we want to remove that last paragraph element from this `section` element:

```html
<section id="example-section">
  <h2>Example sub heading</h2>
  <p>first paragraph</p>
  <p>second paragraph</p>
</section>
```

We can access the `section` element inside of the JavaScript file using the `getElementById()` method:

```js
const sectionEl = document.getElementById("example-section");
```

Once we have the reference to the `section` element, we can then access that last paragraph using the `querySelector()` method:

```js
const sectionEl = document.getElementById("example-section");
const lastParagraph = document.querySelector("#example-section p:last-of-type");
```

We are using the `:last-of-type` pseudo-class to select the last paragraph element inside the `section` element.

Now that we have the parent and child nodes, we can remove the last paragraph element from the `section` element using the `removeChild()` method:

```js
const sectionEl = document.getElementById("example-section");
const lastParagraph = document.querySelector("#example-section p:last-of-type");

sectionEl.removeChild(lastParagraph);
```

Here is the new HTML markup after removing the last paragraph element:

```html
<section id="example-section">
  <h2>Example sub heading</h2>
  <p>first paragraph</p>
</section>
```

So, when might you want to add or remove nodes from the DOM?

If you're working with dynamic content, you might need to add or remove nodes from the DOM. Real world examples include shopping carts, to-do lists, and social media feeds.


## How Do the Navigator, Window, and Document Work?

### Description

When working with the DOM, you will often come across the `Navigator`, `Window`, and `Document` interfaces. An interface is a collection of methods and properties that define a particular object.

In this lecture, we will explore how these interfaces work and how you can use them in your web applications.

Let's start by looking at the `Navigator` interface.

The `Navigator` interface provides information about the browser environment, such as the user agent string, the platform, and the version of the browser. A user agent string is a text string that identifies the browser and operating system being used.

Here is an example of how to access the user agent string using the `Navigator` interface:

```js
console.log(navigator.userAgent);
```

The result will be a string that contains information about the browser and operating system being used.

Here is an example string that you might see:

```md
Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.0.0 Safari/537.36
```

This could be helpful if you want to display different content based on the user's browser or operating system.

Another useful property of the `Navigator` interface is the `language` property, which returns the language of the browser. You can use this property to display content in the user's preferred language.

Here is an example of using the `language` property:

```js
console.log(navigator.language);
```

The result will be a string that contains the language code of the browser. If your preferred language is English, it will return `en-US`.

Next, let's look at the `Window` interface.

The `Window` interface represents the browser window that contains the DOM document. It provides methods and properties for interacting with the browser window, such as resizing the window, opening new windows, and navigating to different URLs.

Here is an example of working with the `innerWidth` property of the `Window` interface:

```js
console.log(window.innerWidth);
```

The result will be the width of the browser window in pixels. For example, if the browser window is 800 pixels wide, it will return `800`.

Another example would be the `location` property of the `Window` interface, which provides information about the current URL of the browser window:

```js
console.log(window.location);
```

The result will be an object that contains information about the current URL, such as the protocol, hostname, and pathname.

Most of the time you won't need to interact with the `Window` interface directly, as it is automatically available in the global scope of your JavaScript code.

For example, you can access the `location` property directly without using the `window` object:

```js
console.log(location);
```

You will see the same results as before when you were using `window.location`.

Finally, let's look at the `Document` interface.

The `Document` interface represents the DOM document that is displayed in the browser window. It provides methods and properties for interacting with the DOM, such as selecting elements, creating new elements, and modifying the content of elements.

Here is an example of using the `document.children` property:

```js
console.log(document.children);
```

The result will be an `HTMLCollection` object that contains all the child elements of the document.

There are many more properties and methods available on the `Document`, `Window`, and `Navigator` interfaces. However, this lecture has provided you with a basic understanding of how these interfaces work and how to use them in your web applications.


## How Do You Add Attributes with setAttribute()?

### Description

You have been used to working with attributes in your HTML and CSS projects. But did you know that you can add attributes to your HTML elements in your JavaScript file?

In this lecture, you will learn how work with the `setAttribute()` method to add attributes to your HTML elements.

Here is the basic syntax:

```js
setAttribute(attribute, value);
```

Let's take a look at a few examples to better understand how to use the `setAttribute()` method.

In this first example, we have a `p` element inside the HTML:

```html
<p id="para">I am a paragraph</p>
```

To add a `class` attribute we first need to access that `p` element using the `getElementById()` method. Then we can use the `setAttribute()` method to add the `class` attribute and set the value to `my-class`:

```js
const para = document.getElementById("para");
para.setAttribute("class", "my-class");
```

If we inspect the element inside the browser, we will see that the `class` attribute has been added to the `p` element.

If you have an existing attribute on an HTML element, you can update its value using the `setAttribute()` method.

In this example we have a `div` element with a `class` attribute set to `my-class`:

```html
<div class="my-class"></div>
```

To update the `class` attribute value to example, we can use the `setAttribute()` method again:

```js
const divEl = document.querySelector(".my-class");
divEl.setAttribute("class", "example");
```

If we inspect the element inside the browser, we will see that the `class` attribute value has been updated to example.

So, what are some real-world examples of when to use the `setAttribute()` method?

If you were building a dynamic image gallery, you might need to update the `src` attribute of an image element when a user clicks on a thumbnail.

Another example would be if you're dealing with form validation and need to add certain attributes like `required` or `minlength` to an `input` element.


## What Is the Event Object?

### Description

The `Event` object is a payload that triggers when a user interacts with your web page in some way. These interactions can be anything from clicking on a button or focusing an input to shaking their mobile device.

Like all JavaScript objects, the `Event` object has a number of properties that might be helpful. The properties available depend on the event that triggered this payload.

All `Event` objects will have the `type` property. This property reveals the type of event that triggered the payload, such as `"keydown"` or `"click"`. These values will correspond to the same values you might pass to `addEventListener()`, where you can capture and utilize the `Event` object.

`Event` objects will always have the `target` property. The `target` property is a reference to whatever object triggered the event. Most commonly, this will be some sort of `HTMLElement` object, or the `Document` or `Window` objects. But it can also be something more specific, like an `AudioContext`.

Events also have methods, which are functions exposed as properties on the object. One commonly used method is `preventDefault()`, which prevents the default behavior of the event when called.

If you want to handle form submissions yourself, for example, you might call `preventDefault()` to keep the browser from trying to submit the form data as a `POST` request. You will learn more about `POST` requests in future lectures.

You'll also likely run in to the `stopPropagation()` method. This method prevents the event from bubbling up or propagating to parent elements. You'll learn more about what this means in a later lecture.

There are also a large number of properties that are specific to certain implementations of the `Event` object. For example, a `FetchEvent` will have a request property to contain the request that triggered the event. 

If you are ever unsure of what properties are available, you can log the `Event` object in question or even check the documentation.


## How Does the addEventListener Method Work?

### Description

When the user clicks on a button or there is a change in a form, this is known as an event. In your programs, you will need to have a way to listen for these events and respond to them.

The `addEventListener()` method is used to listen for events. It takes two arguments: the event you want to listen for and a function that will be called when the event occurs.

Here is the basic syntax:

```js
element.addEventListener("event", listener);
```

The element is the HTML element to monitor for events, and event specifies the type of event to listen for, such as `"click"`.

The listener is an object that will receive the notification when the event occurs. Most of the time, this will be a function that you define to handle the event.

Here is an example:

```js
element.addEventListener("click", () => {
  // code to run when the click event occurs
});
```

You can also choose to pass in a function reference like this:

```js
function handleClick() {
  // code to run when the click event occurs
}

element.addEventListener("click", handleClick);
```

Sometimes you may want to create a separate function to handle the event. This can make your code easier to read and maintain.

The listener argument can also be `null`, or it can be an object that uses the `EventListener` interface. The `EventListener` interface defines a single method called `handleEvent()`. This method is automatically called whenever the event you're listening for occurs. Using this interface allows the same object to handle multiple events if needed.

Most of the time, you won't need to use this interface, and you can instead pass in a function that will be called when the event occurs.

Now, let's take a look at an example to better understand how this works:

In this example, we have a `button` element with the id of `btn`:

```html
<button id="btn">Show alert</button>
```

We want to listen for the `"click"` event on this button and show an alert when the button is clicked.

We first need to access that `button` element in our JavaScript code. Then we need to add an event listener to listen for the click event and show an alert when the button is clicked:

```js
const btn = document.getElementById("btn");

btn.addEventListener("click", () => alert("You clicked the button"));
```

Now each time the button is clicked, the user will see an alert message displayed on the screen like this:

```md
You clicked the button
```

Another type of event that you can listen for is the `"input"` event. This event is triggered when the value of an input element changes.

Here is an example:

```html
<input type="text" id="input" placeholder="Type something" />
```

We want to listen for the input event on this input element and log the value of the input to the console each time the user types something.

We first need to access that `input` element in our JavaScript code. Then we need to add an event listener to listen for the input event and log the value of the input to the console each time the user types something:

```js
const input = document.getElementById("input");

input.addEventListener("input", () => {
  console.log(input.value);
});
```

Here is what the console will look like when the user types something in the input field:

```md
h
he
hel
hell
hello
```

There are many more events that you can listen for using the `addEventListener()` method. Some common events include `mouseover`, `mouseout`, `keydown`, `keyup`, and `submit`.

In future lectures, we will cover more events and how to use the `addEventListener()` method to listen for them.


## How Does the removeEventListener Method Work?

### Description

In the previous lecture, you learned how to work with `"click"` and `"input"` events by using the `addEventListener()` method. In this lecture, you will learn how to remove event listeners using the `removeEventListener()` method.

The `removeEventListener()` method is used to remove an event listener that was previously added to an element using the `addEventListener()` method. This is useful when you want to stop listening for a particular event on an element.

Here is the basic syntax for the `removeEventListener()` method:

```js
element.removeEventListener("event", listener);
```

Just like the `addEventListener()` method, the `removeEventListener()` method takes two arguments: the event you want to remove and the listener function that was previously added.

There is also an additional optional third argument that can be passed to the `removeEventListener()` method. This argument can either be the `options` or `useCapture`.

The `options` argument is an object that specifies the options for the event listener, such as whether the event listener should be passive or once. 

The `useCapture` argument is a boolean value that specifies whether the event should be captured during the event propagation phase.

Most of the time, you will only need to pass the event and listener arguments to the `removeEventListener()` method.

Let's take a look at an example to better understand how the `removeEventListener()` method works:

In this example, we have heading, paragraph and button elements in the HTML:

```html
<h1>Event Listener examples</h1>
<p id="para">MouseOver this text to remove the event listener</p>
<button id="btn">Change background color</button>
```

Inside the CSS file, we are setting the `body` background color to grey:

```css
body {
  background-color: grey;
}
```

If we want to toggle the background color between grey and blue, then we can use an event listener for that.

We first need to access the paragraph and button elements along with the `body` element:

```js
const bodyEl = document.querySelector("body");
const para = document.getElementById("para");
const btn = document.getElementById("btn");
```

Then we need to create the function responsible for toggling between the grey and blue colors:

```js
let isBgColorGrey = true;

function toggleBgColor() {
  bodyEl.style.backgroundColor = isBgColorGrey ? "blue" : "grey";
  isBgColorGrey = !isBgColorGrey;
}
```

We are using a boolean variable `isBgColorGrey` to keep track of the current background color. If the background color is grey, then we change it to blue, and vice versa.

Then we need to add an event listener to the `button` element to call the `toggleBgColor` function when the button is clicked:

```js
btn.addEventListener("click", toggleBgColor);
```

Each time the button is clicked, the background color of the body will change between grey and blue.

To remove the event listener when the paragraph is hovered over, we can add an event listener to the paragraph element. We are using the `mouseover` event and passing in a function that removes the event listener from the `button` element:

```js
para.addEventListener("mouseover", () => {
  btn.removeEventListener("click", toggleBgColor);
});
```

When the paragraph is hovered over, the event listener for the button click event is removed, and the background color will no longer change when the button is clicked.

Real world examples of when to use the `removeEventListener()` method include removing event listeners when a modal is closed in a web application or when a user logs out of an application.


## What Are Inline Event Handlers, and Why Is It Best Practice to Use addEventListener Instead?

### Description

In the previous lectures, you learned how to work with events by using the `addEventListener()` method. But there is another, not recommended way, to work with events in JavaScript.

Inline event handlers are special attributes on an HTML element that are used to execute JavaScript code when an event occurs.

Here is an example of a `button` element with an inline click event handler:

```html
<button onclick="alert('Hello World!')">Show alert</button>
```

When the user clicks on the button, the `alert` function is called and an alert dialog is displayed with the message `Hello World!`.

Another way to use inline event handlers is to call a function that is defined in a `script` tag in the HTML document. 

Here is an example of defining a function called `changeBgColor` and calling it from an inline click event handler:

```html
<script>
  function changeBgColor() {
    document.body.style.backgroundColor = "lightblue";
  }
</script>

<button onclick="changeBgColor()">Change background color</button>
```

When the user clicks on the button, the `changeBgColor` function is called and the background color of the page is changed to light blue. While it is possible to use inline event handlers like this, it is not considered a best practice. 

For one reason, inline event handlers can only be used to attach one event listener to an element. If you want to attach multiple event listeners to the same element, you will need to use `addEventListener()`. Another reason is that inline event handlers mix HTML and JavaScript code together, which can make your code harder to read and maintain. It is better to keep your HTML code and JavaScript code separate by using `addEventListener()` to attach event listeners to elements.

Inline event handlers are not recommended for use in modern JavaScript. So, it is best practice to stick with the `addEventListener()` method when working with events in JavaScript.


## How Do You Manipulate Styles Using Element.style and Element.classList?

### Description

There will be times when you will need to manipulate the styles of an HTML element inside your JavaScript file. An example of this would be when you need to hide or show a menu when a user clicks on a button.

In this lecture, you will learn how to manipulate styles using the `Element.style` and `Element.classList` properties.

The `Element.style` property is a read-only property that represents the inline style of an element. You can use this property to get or set the style of an element.

Here is an example of a paragraph element with an ID of `para`:

```html
<p id="para">This is a paragraph</p>
```

You can use the `style` property to change the color of the paragraph element to red:

```js
const paraEl = document.getElementById("para");
paraEl.style.color = "red";
```

The `style` property can be used to set many CSS properties, such as `color`, `background-color`, `font-size`, `font-weight`, and so on.

Another way to manipulate styles is by using the `Element.classList` property. The `classList` property is a read-only property that can be used to add, remove, or toggle classes on an element. Let's take a look at a couple of examples.

In this first example, you are going to add a class called `highlight` to a paragraph element with an ID of `para`:

```html
<p id="para">This is a paragraph</p>
```

In the CSS, we will set the `highlight` class to change the background color of the paragraph element to yellow:

```css
.highlight {
  background-color: yellow;
}
```

In the JavaScript, we will add the `highlight` class to the paragraph element using the `classList.add()` method:

```js
const paraEl = document.getElementById("para");
paraEl.classList.add("highlight");
```

You can also add multiple classes to an element by passing them as arguments to the `classList.add()` method:

```js
classList.add("class1", "class2", "class3");
```

If you need to remove a class from an element, you can use the `classList.remove()` method like this:

```js
classList.remove("highlight");
```

To toggle a class on an element, you can use the `classList.toggle()` method. In this example, we have a `button` element with an ID of `toggle-btn` and a `nav` element with an ID of `menu`:

```html
<button id="toggle-btn">Toggle Menu</button>

<nav id="menu" class="menu">
  <ul>
    <li>Home</li>
    <li>About</li>
    <li>Products</li>
  </ul>
</nav>
```

Inside the CSS, we have added some styles for the menu and a class called `show` that will change the `display` property of the `.menu` to `block`:

```css
.menu {
  display: none;
  background-color: lightgray;
  width: 50%;
  padding: 10px;
}

.menu.show {
  display: block;
}
```

Inside the JavaScript, we are accessing the menu element and the `button` element using the `getElementById()` method. Then, we are adding an event listener to the `button` element that will toggle the `show` class on the `.menu` element when the button is clicked:

```js
const menu = document.getElementById("menu");
const toggleBtn = document.getElementById("toggle-btn");

toggleBtn.addEventListener("click", () => menu.classList.toggle("show"));
```

When a user clicks on the button, the `show` class will be added to the `.menu` element, and the menu will be displayed. If the user clicks on the button again, the `show` class will be removed from the `.menu` element, and the menu will be hidden.

By using methods and properties such as `style`, `add()`, `remove()`, and `toggle()`, you can easily manipulate an element's styles with JavaScript, creating dynamic and interactive web pages.


## What Is the DOMContentLoaded Event, and How Does It Work?

### Description

The `DOMContentLoaded` event is fired when everything in the HTML document has been loaded and parsed. If you have external stylesheets, or images, the `DOMContentLoaded` event will not wait for those to be loaded. It will only wait for the HTML to be loaded.

This differs from the `load` event, which waits for everything to be loaded, including external stylesheets, images, and so on.

Here is the example syntax for using the `DOMContentLoaded` event:

```js
document.addEventListener("DOMContentLoaded", function () {
  console.log("DOM is loaded.");
});
```

Once the DOM is loaded, the function will be executed and the message `DOM is loaded.` will be logged to the console.

Now, let's take a look at another example using the `DOMContentLoaded` event. In this example, we have an image inside the HTML:

```html
<h1>Image Change on DOM Loaded</h1>
<img
  id="example-img"
  src="https://cdn.freecodecamp.org/curriculum/cat-photo-app/relaxing-cat.jpg"
  alt="Cat relaxing"
/>
```

To update the image, we can create a function that changes the `src` attribute of the image:

```js
function changeImg() {
  const img = document.getElementById("example-img");
  img.src =
    "https://cdn.freecodecamp.org/curriculum/responsive-web-design-principles/FCCStickers-CamperBot200x200.jpg";
  console.log("image was just changed");
}
```

We can then check if the DOM is still loading and add an event listener for the `DOMContentLoaded` event. If the `DOMContentLoaded` event has already fired, we can call the `changeImg` function directly:

```js
if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", changeImg);
} else {
  console.log("DOMContentLoaded has already fired");
  changeImg();
}
```

If you were to run this code, and refresh the page, you would see the image change to the new image after the DOM has loaded. It happens pretty quickly, but you will see a slight flicker as the image changes.

The `DOMContentLoaded` event is useful when you want to run some JavaScript code as soon as the DOM is loaded, but before all the external resources like images and stylesheets are loaded.


## How Do the setTimeout and setInterval Methods Work?

### Description

When building your programs, you'll often want something to happen after a delay, or repeat at regular intervals. That's where the `setTimeout()` and `setInterval()` methods come in handy. Both methods accept two parameters: a function and a delay.

Let's look at each of the methods in more detail so you can start using them in your web projects. 

`setTimeout()` lets you delay an action for a specified time. Here's the basic syntax of the `setTimeout()` method:

```js
setTimeout(functionToRun, delay);
```

`functionToRun` is the code you want to execute after a specified delay, and `delay` is the time (in milliseconds) to wait before running the function. Here's an example:

```js
setTimeout(function () {
 console.log("This runs after 3 seconds");
}, 3000);
```

You can also use an arrow function for the callback, like this:

```js
setTimeout(() => {
 console.log("This runs after 3 seconds"); 
}, 3000);
```

`setInterval()` keeps repeating a function at a set interval. It's like having an alarm that goes off every few seconds. `setInterval()` is perfect when you want something to happen over and over again, like refreshing data or creating an animation that moves continuously.

Just like `setTimeout()`, it takes a function and a delay:

```js
setInterval(functionToRun, delay);
```

`functionToRun` is the code you want to run repeatedly, while `delay` is the time in milliseconds between each execution of that function. Here's an example:

```js
setInterval(() => {
 console.log("This runs every 2 seconds");
}, 2000);
```

And here's the result in the console:

```md
This runs every 2 seconds
This runs every 2 seconds
This runs every 2 seconds
```

Since `setInterval()` keeps executing the provided function at the specified interval, you might want to stop it. To do this, you have to use the `clearInterval()` method.

To do the work, `clearInterval()` takes the ID of the `setInterval()` you want to stop. This could be a variable you assign the interval to. One way to stop the interval is inside a `setTimeout()`, as that will stop the interval after a certain time:

```js
const intervalID = setInterval(() => {
 console.log("This will stop after 5 seconds");
}, 1000);

setTimeout(() => {
 clearInterval(intervalID);
}, 5000);
```

You can also stop a timeout with the `clearTimeout()` method:

```js
let timeoutID = setTimeout(() => {
 console.log("This will not run");
}, 5000);

clearTimeout(timeoutID);
```

With that code, the `setTimeout()` will not run at all. So, a more elegant way to do it is through the DOM, by adding a click event listener to a button to stop the timeout:

```html
<h1>Cancel Timeout Example</h1>
<button id="cancelButton">Cancel Timeout</button>

<script>
   let timeoutID = setTimeout(() => {
     console.log("This will run if not canceled");
   }, 5000);

   document
   .querySelector("#cancelButton")
   .addEventListener("click", () => {
     clearTimeout(timeoutID);
     console.log("Timeout canceled!");
   });
</script>
```


## What Is the requestAnimationFrame() API, and How Can It Be Used to Set Up an Animation Loop?

### Description

Creating smooth animations on a web page can be tricky, especially if you're not sure how to handle timing properly. The great news is that the `requestAnimationFrame()` API makes it easier. 

`requestAnimationFrame()` is a method that allows you to schedule the next step of your animation before the next screen repaint, resulting in a fluid and visually appealing experience.

The next screen repaint refers to the moment when the browser refreshes the visual display of the web page. This happens multiple times per second, typically around 60 times (or 60 frames per second) on most displays.

To use the `requestAnimationFrame()` method, all you need to do is to call it and pass a callback function into it:

```js
requestAnimationFrame(callback);
```

Calling `requestAnimationFrame()` must first occur inside a function that handles the animation, such as `animate()`, along with a function to update the animation, traditionally called `update()`:

```js
function animate() {
 // Update the animation...
 // for example, move an element, change a style, and more.
 update();
 // Request the next frame
 requestAnimationFrame(animate);
}
```

The `update()` function is where the magic happens. Inside it, you get to change whatever you want to animate. For example, updating a style or changing the position of an element:

```js
function update() {
 element.style.transform = `translateX(${position}px)`;
 position += 2;
}
```

What finally kicks off the animation is calling `requestAnimationFrame()` and passing in the `animate` function, this time outside the `animate` function:

```js
requestAnimationFrame(animate);
```

The loop will continue until you stop it.

Now, let's take a look at another example. The HTML for this example is a `div` element with the text `freeCodeCamp is Awesome`:

```html
<div id="rect" class="rect">freeCodeCamp is Awesome</div>
```

This is the CSS that makes the `div` a rectangle and hides anything that goes out of the viewport on the left or right:

```css
body {
  overflow-x: hidden;
}

.rect {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 400px;
  height: 250px;
  border-radius: 5px;
  background-color: #1b1b32;
  color: #f5f6f7;
  font-size: 2rem;
  position: absolute;
}
```

This is the commented JavaScript that moves the rectangle `2px` to the right at every call of `requestAnimationFrame(animate)` with the `animate` function as a callback:

```js
// reference the rectangle
const rect = document.getElementById("rect");

// start with a position of 0
let position = 0;

function update() {
  // Move the rectangle 2px to the right
  rect.style.left = position + "px";
  position += 2;

  // Reset the position when the rectangle reaches
  // the right side of the screen
  if (position > window.innerWidth) {
    // Move the rectangle just outside the left side of the screen
    position = -rect.offsetWidth;
  }
}

function animate() {
  // Update the position
  update();

  //request the next frame
  requestAnimationFrame(animate);
}

// Start the animation
requestAnimationFrame(animate);
```

The result in the browser will be an animated title card floating across the screen.


## What Is the Web Animations API, and How Does It Relate to CSS Animation Properties?

### Description

The `Web Animations` API (WAAPI) allows you to create and control animations directly within JavaScript. With WAAPI, you can work with animations more dynamically, making it easier to manipulate them.

Let's take a look at WAAPI in more detail, so you can start working with animations directly inside your JavaScript code. At the core of WAAPI is the `Animation` constructor, which provides several instance methods and properties that allow you to dynamically animate elements.

A significant method in the `Animation` constructor is `animate()`. It allows you to create an animation by specifying keyframes and options like duration, directions easing, and iterations.

Here's the basic syntax of the `animate()` method:

```js
element.animate(keyframes, options);
```

Let's look at an example. Here's a `div` element for the HTML:

```html
<div class="square" id="square"></div>
```

Here's the CSS that makes the `div` a square and centers everything on the page:

```css
body {
  background: #f1f1f1;
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100vh;
}

.square {
  background: #1b1b32;
  width: 10rem;
  aspect-ratio: 1/1;
}
```

And here's the JavaScript that uses the `animate()` method:

```js
const square = document.querySelector("#square");

const animation = square.animate(
  [{ transform: "translateX(0px)" }, { transform: "translateX(100px)" }],
  {
    duration: 2000, // makes animation lasts 2 seconds
    iterations: Infinity, // loops indefinitely
    direction: "alternate", // moves back and forth
    easing: "ease-in-out" // smooth easing
  }
);
```

The result in the browser will be a blue square moving back and forth horizontally.

The instance methods of the `Animation` constructor include:

```js
play()
pause()
reverse()
finish()
cancel()
```

And the instance properties include:

```md
playbackRate
currentTime
startTime
effect
timeline
playState
finished
onfinish
oncancel
```

Let's modify the example to use the `play()`, `pause()` methods and the `onfinish` property. Here's the HTML with play and pause buttons:

```html
<div class="square" id="square"></div>

<button id="playBtn">Play</button>
<button id="pauseBtn">Pause</button>
```

Here's the new CSS:

```css
body {
  background: #f1f1f1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
}
.square {
  background: #1b1b32;
  width: 10rem;
  aspect-ratio: 1/1;
  margin-bottom: 20px;
}
button {
  margin: 10px;
  padding: 10px 20px;
  font-size: 16px;
}
```

And here's the new JavaScript:

```js
const square = document.querySelector("#square");
const playBtn = document.querySelector("#playBtn");
const pauseBtn = document.querySelector("#pauseBtn");

const animation = square.animate(
  [{ transform: "translateX(0px)" }, { transform: "translateX(200px)" }],
  {
    duration: 5000, // Animation lasts 5 seconds
    // iterations: Infinity, // Loops indefinitely
    direction: "alternate", // Moves back and forth
    easing: "ease-in-out" // Smooth easing function
  }
);

// Set the onfinish property to log a message when the animation ends
animation.onfinish = () => {
  console.log("Animation finished!");
};

// Play the animation when the "Play" button is clicked
playBtn.addEventListener("click", () => {
  animation.play();
  console.log("You start the animation");
});

// Pause the animation when the "Pause" button is clicked
pauseBtn.addEventListener("click", () => {
  animation.pause();
  console.log("You pause the animation");
});
```

The result in the browser will show the blue box moving from left to right when the `play` button is clicked.

WAAPI extends the capabilities of CSS animations by providing more dynamic control over animations right inside JavaScript.

With CSS animations, you define animations declaratively using properties like `animation-name`, `animation-duration`, and `animation-timing-function`. You also have the opportunity to do the same thing using the `animate()` method of WAAPI.

The difference is that you can control the animations you create with the `animate()` method more directly and dynamically, but with CSS animations, you need to do way more by defining custom styles and triggering them inside your JavaScript file.

CSS animation is ideal for simple and declarative animations that run automatically. Those include hover effects, transitions or animations that don't need much interaction once triggered. If your animation needs to respond to user interactions like clicks, and scrolls, or you want the user to be able to pause, reverse, or change speed dynamically, WAAPI is the better choice. 

You can consider combining both WAAPI and CSS animations when you want the simplicity of CSS for basic setup but need to control animations at runtime.


## What Is the Canvas API, and How Does It Work?

### Description

The `Canvas` API is a powerful tool that lets you manipulate graphics right inside your JavaScript file. Everything begins with a `canvas` element in HTML. This element serves as a drawing surface that you can manipulate using the instance methods and properties of the `Canvas` API.

The `Canvas` API provides everything you need to create amazing visuals, including shapes, text, animations, and even complex games. It has interfaces like `HTMLCanvasElement`, `CanvasRenderingContext2D`, `CanvasGradient`, `CanvasPattern`, `TextMetrics` which provide methods and properties you can use to create graphics in your JavaScript file.

Let's look at how the `Canvas` API works so you can start creating graphics with JavaScript.

First, you need to create a `canvas` element in your HTML file:

```html
<canvas id="my-canvas"></canvas>
```

The `canvas` element is represented by the `HTMLCanvasElement` interface, which provides methods and properties for manipulating it. Additionally, you can use methods and properties from other interfaces in the `Canvas` API.

You can give your `canvas` a `width` and `height` inside the HTML:

```html
<canvas id="my-canvas" width="400" height="400"></canvas>
```

Or you can use the `width` and `height` properties of the `HTMLCanvasElement` interface:

```js
const canvas = document.getElementById("my-canvas");
canvas.width = 400;
canvas.height = 400;
```

For now, you can't see anything on the screen yet. After creating your `canvas` element, the next thing to do is to get access to the drawing context of the canvas with the `getContext()` method of the `HTMLCanvasElement` interface. 

The most common context is `2d`, which allows you to draw in two dimensions:

```js
const canvas = document.getElementById("my-canvas");
const ctx = canvas.getContext('2d');
```

If you log the `ctx` variable to the console, you'll see the methods and properties of `CanvasRenderingContext2D` that you can use to create shapes, colors, lines, and more, along with their default values:

```js
console.log(ctx);
```

Once you have the 2D context, you can start drawing on the canvas.

The `Canvas` API provides several methods and properties for drawing shapes, lines, and text. One of those is the `fillStyle` property, which you can combine with the `fillRect()` method to draw a rectangle or square:

```js
const canvas = document.getElementById("my-canvas");

const ctx = canvas.getContext("2d");

// Set the background color
ctx.fillStyle = "crimson";

// Draw a rectangle
ctx.fillRect(1, 1, 150, 100);
```

`fillRect` takes 4 number values which represent the x axis, y axis, width, and height, respectively.

There's something on the screen now. You can also draw text or even create an animation. Here's a canvas to represent text:

```html
<canvas id="my-text-canvas" width="300" height="70"></canvas>
```

To finally draw the text, pass the text into the `fillText()` method as the first argument, followed by the values for the x and y axis:

```js
const textCanvas = document.getElementById("my-text-canvas");

const textCanvasCtx = textCanvas.getContext("2d");

// Set font family and size
textCanvasCtx.font = "30px Arial";

// Set text color
textCanvasCtx.fillStyle = "crimson";

// Draw the text
textCanvasCtx.fillText("Hello HTML Canvas!", 1, 50);
```

The result in the browser will be the red text `Hello HTML Canvas!`.

These's much more you can do with the `Canvas` API. For example, you can combine it with `requestAnimationFrame` to create custom animations, visualizations, games, and more.


## How Do You Open and Close Dialog Elements Using JavaScript?

### Description

Dialogs let you display important information or actions to users. With HTML's built-in `dialog` element, you can easily create these dialogs (both modal and non-modal dialogs) in your web apps.

A modal dialog is a type of dialog that forces the user to interact with it before they can access the rest of the application or webpage. It effectively blocks interaction with other content until the user completes an action, such as closing the dialog or submitting a form.

In contrast, a non-modal dialog allows the user to continue interacting with other parts of the page or application even when the dialog is open. It doesn't prevent access to the rest of the content.

In this lecture, you will learn how to open and close modals using the `showModal()` and `close()` methods.

When you want to make sure the user focuses on a specific action or message of a modal, you can open the modal dialog using the `showModal()` method. This will add a backdrop to the other items on the page and disable them. This is ideal for modals that display forms, confirmations, and critical information that requires user action. 

Here's the HTML for the modal dialog:

```html
<dialog id="my-modal">
   <p>This is a modal dialog.</p>
</dialog>
```

For now, you can't see anything on the page because the modal is closed on the initial render. You can automatically open the modal by using the `showModal()` method:

```js
const dialog = document.getElementById("my-modal");
dialog.showModal();
```

The result in the browser will show a modal with the text `This is a modal dialog.`

It's best to give control to the user. To achieve this, you can add a click event listener to a button and use the `showModal()` method:

```html
<dialog id="my-modal">
   <p>This is a modal dialog.</p>
</dialog>
<button id="open-modal">Open Modal Dialog</button>
```

Here's the JavaScript:

```js
const dialog = document.getElementById("my-modal");
const openButton = document.getElementById("open-modal");

openButton.addEventListener("click", () => {
  dialog.showModal();
});
```

If you needed to show a dialog while still allowing interaction with content outside of the dialog, then you can use the `show()` method:

```js
const dialog = document.getElementById("my-modal");
const openButton = document.getElementById("open-modal");

openButton.addEventListener("click", () => {
  dialog.show();
});
```

To close a modal, you can add a button to the modal inside the `dialog` element:

```html
<dialog id="my-modal">
   <p>This is a modal dialog.</p>
   <button id="close-modal">Close Modal</button>
</dialog>
<button id="open-modal">Open Modal Dialog</button>
```

Then use the `close()` method on the button:

```js
const dialog = document.getElementById("my-modal");
const openButton = document.getElementById("open-modal");
const closeButton = document.getElementById("close-modal");

openButton.addEventListener("click", () => {
  dialog.show();
});

closeButton.addEventListener("click", () => {
  dialog.close();
});
```


### Lecture Block: Lecture Understanding The Event Object And Event Delegation


## What Is the Change Event, and How Does It Work?

### Description

The `change` event is a special event which is fired when the user modifies the value of certain input elements. More specifically:

- When a checkbox is ticked or unticked.

- When a radio button is ticked.

- When the user makes a selection from something like a date picker or dropdown menu.

- When an input loses focus (the user tabs to the next field, or clicks out of the form) after the user has changed the value.

- When the user otherwise confirms the value, such as by hitting enter after typing some text.

Note that the `change` event does NOT fire when your user types in an input. The `change` event will only fire after they have focused on another element.

The `change` event still generates an `Event` object, but unlike most other events it does not generate a custom implementation – the only properties and methods you will have access to are those on the base `Event` object.

This differs from the `input` event, which generates a dedicated `InputEvent` object. The change event also differs in a few ways. An `input` event WILL trigger when a user types content into a field, for example.

These differences are important to remember, as you might get tripped up by the timing of these events firing.


## How Do Event Bubbling, and Event Delegation Work?

### Description

Event bubbling, or propagation, refers to how an event "bubbles up" to parent objects when triggered. For example, consider this code:

```html
<p>
  <span>Click me~!</span>
</p>
```

The `p` element here would be considered the parent of the `span` element. 

When you click on the `span` element, like you are instructed to, the `span` element becomes the target of a `click` event. That event, however, also bubbles up to the parent – the `p` element can receive and consume that event as needed.

But what does this actually mean? Well, you could attach an event listener to the `p` element:

```js
const p = document.querySelector("p");
p.addEventListener("click", (event) => {
  console.log(event.target);
});
```

Then, when you click on the `span` element you will see the text `Click me~!` logged to the console.

The event propagates to the parent `p` element, which consumes it in an event listener to display the target of the event. 

Notice how the target is still the `span` element. This is because the `span` element received the initial click.

Just to be sure how things are working, let's expand our code:

```js
const p = document.querySelector("p");
const span = document.querySelector("span");
p.addEventListener("click", (event) => {
  console.log("P listener: ");
  console.log(event.target);
});
span.addEventListener("click", (event) => {
  console.log("Span listener: ");
  console.log(event.target);
});
```

To give you an idea of how the event bubbles up, here's what you'll see in the console after clicking the `span` element:

```html
"Span listener: "
<span>Click me~!</span>
"P listener: "
<span>Click me~!</span>
```

Now let's see what happens when you prevent the propagation of an event with `stopPropagation()`. We'll call it in our `span`'s event listener:

```js
const p = document.querySelector("p");
const span = document.querySelector("span");
p.addEventListener("click", (event) => {
  console.log("P listener: ");
  console.log(event.target);
});
span.addEventListener("click", (event) => {
  console.log("Span listener: ");
  console.log(event.target);
  event.stopPropagation();
});
```

And then click our `span` again:

```html
"Span listener: "
<span>Click me~!</span>
```
 
This time, we don't see our `p` listener trigger. The event never fires for the `p` element, because we told it to stop propagation while it was being processed for the child `span` element.

Event delegation can be thought of as the opposite. It's the process of taking a captured event, and delegating it to another element. 

Going back to our code, let's update it so clicking on a `span` element changes it to red:

```js
const p = document.querySelector("p");
const span = document.querySelector("span");
p.addEventListener("click", (event) => {});
span.addEventListener("click", (event) => {
  event.target.style.color = "red";
});
```

But what if you have twenty `span` elements? Or maybe you use JavaScript to create more `span` elements on the fly?

Rather than having to attach an event listener to every single `span` element, you can actually use the listener on the `p` element for all of them. In other words, you can delegate the handling of the `span` clicks to the parent `p` element.

Our code might now look something like this:

```js
const p = document.querySelector("p");
p.addEventListener("click", (event) => {
  event.target.style.color = "red";
});
```

Notice how we no longer have any listener attached to the `span` element at all. You have properly delegated the event handling to the `p` element. But does it work?

Let's generate a few extra `span` elements and see:

```html
<p>
  <span>Click me~!</span>
  <span>Click me~!</span>
  <span>Click me~!</span>
  <span>Click me~!</span>
</p>
```

Now, each time we click on a `span`, that element's text will become red. 

And just like that, with a single event listener we've properly allowed a `click` event to bubble up from `span` elements to the parent `p`, and delegated the logic for that `click` event to the `p` element.

Event propagation and delegation can be a complex topic, especially as you get into heavily nested elements like tables. You are encouraged to explore this further and experiment with some of the code we've written here.


## Module: Js A11Y


### Lecture Block: Lecture Understanding Aria Expanded Aria Live And Common Aria States


## What Is the aria-expanded Attribute, and How Does It Work?

### Description

The `aria-expanded` attribute is used for accessibility purposes to indicate if a control is expanded or collapsed. It's used in conjunction with collapsible widgets like menus, accordions and other disclosure widgets that control the visibility of content. The `aria-expanded` attribute is set to `true` if the control is expanded, or `false` if it is collapsed.

The information provided by `aria-expanded` allows people using screen readers to understand the current state of the control (whether it is expanded or collapsed).

The `aria-expanded` attribute is applied to the interactive element that toggles the visibility of a collapsible widget. For example, if a button toggles an expandable menu, the `aria-expanded` attribute is placed on the button.

When the menu is expanded, the `aria-expanded` attribute should be set to `true` like in this example:

```html
<button aria-expanded="true">Menu</button>
```

When the menu is collapsed, it should be set to `false` instead.

```html
<button aria-expanded="false">Menu</button>
```

You must always have the `aria-expanded` attribute set to either `true` or `false` on the controlling element. For example, if a button toggles the visibility of a menu, the default value for `aria-expanded` should be  based on the default visibility of the menu.

If the menu is expanded by default, `aria-expanded` should initially be set to `true`. If the menu is collapsed by default, `aria-expanded` should initially be set of `false`.

The value of `aria-expanded` should be updated dynamically using JavaScript as the user interacts with the element.

Additionally, the properties, `aria-controls` and `aria-owns` can be used in combination with `aria-expanded` to establish a programmatic connection between the controlling element and the element it controls.

Let's start with `aria-controls`. When used with `aria-expanded`, the `aria-controls` attribute is used to specify the element being controlled. For example, a button might expand or collapse a list acting as a menu. The value of `aria-controls` will be the `id` of the controlled element (the menu list in this example).

```html
<button aria-expanded="false" aria-controls="menu1">Menu</button>
<ul id="menu1">
  <li>...</li>
  <li>...</li>
</ul>
```

Notice that the list immediately follows the controlling button. For expandable controls like this, it is best to have the expanded content immediately follow the element that controls it in the DOM. This prevents screen reader users from having to search for the expanded content, and makes it easier for keyboard users to navigate through any interactive controls in the expanded content.

If it is not possible to place the expanded content immediately after the controlling element, the `aria-owns` attribute allows you to virtually move it after the control in the accessibility tree. This allows assistive technology like screen readers to pretend the expanded content is placed directly after the control in the DOM.  

```html
<button aria-owns="menu1" aria-expanded="true">Menu</button>
<main>
  <!-- an entire page worth of content --->
</main>
<ul id="menu1">
  <li>...</li>
  <li>...</li>
</ul>
```

There are drawbacks to using the `aria-owns` attribute. It creates unnecessary verbosity for screen reader users since most screen readers will automatically read out the entire contents of the expanded element when first expanded. It also does not change the tab order, potentially forcing keyboard users to tab through all of the other interactive controls on the page before reaching the expanded content, unless you manage the tabbing order with JavaScript.

Ideally, the expandable content should be placed after the control element, and the `aria-owns` attribute should only be used in a worst case scenario when that is not possible. If it must be used, you will need to thoroughly test with a wide range of screen readers and browsers to ensure that your implementation is accessible for everyone.

And just a reminder, when you use either `aria-controls` or `aria-owns`, the value of `aria-expanded` must continue to be updated as the control is expanded and collapsed.

The `aria-expanded` attribute indicates whether a control  is expanded or collapsed. This information is essential for screen reader users, helping them understand the current state of collapsible elements like menus, accordions, and other similar disclosure widgets.

By using `aria-expanded` correctly, you can create an intuitive user experience for everyone.


## What Is the aria-live Attribute, and How Does It Work?

### Description

The `aria-live` attribute creates a live region on your page which can be used to notify screen reader users of dynamic content changes in the live region as they occur.

Common uses of live regions include messages that are displayed after an action has been taken (such as an error message or confirmation), content that updates periodically (such as a ticker, marquee, or countdown timer), or general status messages (such as updates about a process).

Because the reading focus for screen readers can only be at one place at a time, screen reader users will not notice a content change if their focus is on another part of the page. Live regions allow screen reader users to be automatically notified of changes that happen on the page in real time. Without a live region, screen reader users might miss important content updates available to sighted users, since a sighted user has the ability to scan the entire page. 

There are three possible values for this attribute, based on the priority of the information.

If you set `aria-live` to the value `assertive` that means that the update is very important. It has the highest priority, so the user should be notified immediately.

This means that the screen reader will interrupt any announcement it is currently making to announce the content change in the live region. Such interruptions can be extremely disruptive, so the `assertive` value should only be used for time-sensitive or critical notifications.

```html
<div aria-live="assertive">
  <p>Your session will expire in 30 seconds.</p>
</div>
```

The next value in order of priority is `polite`.

This value means that the update is not urgent, so the screen reader can wait until any current announcement is finished or until the user stops typing before announcing the update. Most live regions will use the `polite` value.

```html
<div aria-live="polite">
  <p>File successfully uploaded</p>
</div>
```

The lowest priority value for `aria-live` is `off` which means that the update will not be announced unless the content is in an element that currently has keyboard focus. Realistically, this value is almost never used as the use case is very narrow and it is not implemented consistently (if at all) across screen readers. If you need live regions, plan on using `polite` for everything except critical messages that need `assertive`.

It's also important to note that the `aria-live` attribute is not required if the updated information is contained in an element with an ARIA role of `alert`, `log`, `marquee`, `status`, or `timer`, as these roles already have default `aria-live` values. But the default value can be changed by explicitly setting `aria-live` on the element.

Choosing the right `aria-live` value depends on the priority of the updated information.

If the updates are urgent, you should notify the user immediately with `assertive`. But you should use this only if the updates are really urgent because sudden interruptions can potentially disorient users and affect the user experience.

If the update can wait until the current task is finished, you should use `polite` instead.

The `aria-live` attribute lets assistive technologies know when the content is changing dynamically on a web page. This helps users with disabilities stay updated on important announcements and updates.

By using `aria-live` appropriately, you can ensure that users are aware of these updates based on their priority.


## What Are Some Common ARIA States Used on Custom Control Elements?

### Description

Semantic form control elements like `input`, `select`, `textarea`, `button`, and `fieldset` have built-in states that are conveyed to assistive technologies.

For example, you could use the `disabled` attribute to disable a button or the `checked` attribute to indicate that a checkbox is checked.

But if you are creating a custom control element, you need to use ARIA attributes to convey the state of the control to assistive technologies.

In this lecture, we will discuss a few common ARIA states that you can use on custom control elements.

The first ARIA state we will discuss is `aria-selected`. This state is used to indicate that an element is selected. You can use this state on custom controls like a tabbed interface, a listbox, or a grid.

Here is an example of how you can use `aria-selected` on a custom tab control:

```html
<div role="tablist">
  <button role="tab" aria-selected="true">Tab 1</button>
  <button role="tab" aria-selected="false">Tab 2</button>
  <button role="tab" aria-selected="false">Tab 3</button>
</div>
```

Tabs are used to display multiple panels of content in a limited space. The `aria-selected` state is used to indicate which tab is currently selected.

When the user selects a tab, the `aria-selected` state of the selected tab is set to `true`, and the `aria-selected` state of the other tabs is set to `false`.

Another common ARIA state is `aria-disabled`. This state is used to indicate that an element is disabled only to people using assistive technologies, such as screen readers. It is important to note that `aria-disabled` does not actually disable the element. It is up to you, the developer, to make it look and act like a disabled element. This attribute is also commonly used on native HTML elements in place of the `disabled` attribute. Which one you choose will depend on the context the button is being used.

Here is an example of how you can use `aria-disabled` on a custom edit button:

```html
<div role="button" tabindex="-1" aria-disabled="true">Edit</div>
```

The `aria-disabled` attribute is used to tell screen reader users that the edit button is disabled and cannot be interacted with. Again, it does not actually disable the button. When using `aria-disabled`,you will need to apply styling and JavaScript to make the control look and behave like a disabled button.

In most cases, you will probably use the native button element, but there are cases where you might need to use a custom control. So, it is essential to know how to convey the state of the control to assistive technologies.

The next ARIA state we will discuss is `aria-haspopup`. This state is used to indicate that an interactive element will trigger a popup element when activated. You can only use the `aria-haspopup` attribute when the popup has one of the following roles: `menu`, `listbox`, `tree`, `grid`, or `dialog`. The value of `aria-haspopup` must be either one of these roles or `true`, which defaults to the `menu` role. 

Here is an example of a file editor menu  that uses `aria-haspopup`:

```html
<button id="menubutton" aria-haspopup="menu" aria-controls="filemenu" aria-expanded="false">File</button>
<ul id="filemenu" role="menu" aria-labelledby="menubutton" hidden>
  <li role="menuitem" tabindex="-1">Open</li>
  <li role="menuitem" tabindex="-1">New</li>
  <li role="menuitem" tabindex="-1">Save</li>
  <li role="menuitem" tabindex="-1">Delete</li>
</ul>
```

The `aria-haspopup` state is used to indicate that the `File` menu button will open a popup menu when activated. Screen reader users may hear this additional information when they navigate to the button.

You will need to use JavaScript to show and hide the popup menu, and to implement proper keyboard support for interacting with the menu. Also, please note that the ARIA `menu` role refers to a very specific type of menu. It generally refers to a list of actions that the user can invoke, similar to a menu on a desktop application. It does not include more common uses of what we typically refer to as "menus", such as navigation menus. Realistically, most "menus" you create on the web will not be ARIA menus and you will not use `aria-haspopup` with them.

The next ARIA state we will discuss is `aria-required`. The `aria-required` attribute is used to indicate that a field needs to be filled out before the form is submitted.
Here is an example of working with the `aria-required` attribute for a custom form control.

```html
<div id="name-label">Full Name*</div>
<div role="textbox" contenteditable aria-labelledby="name-label" aria-required="true" id="name"></div>
```

We need to use the `contenteditable` attribute so users can type in their input. We are also using the `aria-required` attribute set to `true` to indicate that this custom form control is required.

To make the form control look like a normal form control, you would need to add CSS. You would also need to add JavaScript to prevent the form from being submitted without content.

If the label already has the word `required`, then you should omit the `aria-required` attribute. This ensures that screen readers only announce the word required once.

In most cases, you will probably use the native `label` and `form` elements with the `required` attribute. But if you need to create a custom form control, then it is important to add the `aria-required` attribute when necessary.

Additionally, the `aria-required` attribute can also be used on native form inputs, such as the `input`, `textarea`, and `select` elements. This is often preferred to the native required attribute, since the required attribute may have potential usability and accessibility concerns, particularly with the default error handling provided by the browser. Ultimately, you will need to test in order to determine which attribute is best for your situation.

The last ARIA state we will discuss is `aria-checked`. This attribute is used to indicate whether an element is in the checked state. It is most commonly used when creating custom checkboxes, radio buttons, switches, and listboxes.

Here is an example of how you can use `aria-checked` on a custom checkbox control:

```html
<div role="checkbox" aria-checked="true" tabindex="0">Checkbox</div>
```

Native checkbox elements have a built-in `checked` state that is conveyed to assistive technologies. But if you are creating a custom checkbox control, you will need to use the `aria-checked` attribute to indicate its state.

When the user interacts with the custom checkbox control, you will need to use the `aria-checked` state to reflect the new state of the checkbox. When the checkbox is checked, the `aria-checked` attribute is set to `true`. When it is unchecked, it is set to `false`.

Native elements typically have better support and built-in accessibility features.

However, if you must create custom controls, using ARIA attributes is essential to convey the state of these controls to assistive technologies effectively.

As always, test your work to ensure that ARIA attributes are applied correctly and that the custom control functions in a way that is both accessible and user-friendly.


## What Is the aria-controls Attribute, and How Does It Work?

### Description

The `aria-controls` attribute is used to create a programmatic relationship between an element that controls the presence of another element on the page, and the element it controls. This relationship can help screen reader users better understand how the control works. Common uses include a set of tabs that control the visibility of different sections of content, or a button that toggles the visibility of a menu.

Let's take a look at an example to see how this works.
In this example of a tabbed interface, we have a `div` element with a set of three buttons:

```html
<div role="tablist">
  <button role="tab" id="tab1" aria-controls="section1" aria-selected="true">
    Tab 1
  </button>
  <button role="tab" id="tab2" aria-controls="section2" aria-selected="false">
    Tab 2
  </button>
  <button role="tab" id="tab3" aria-controls="section3" aria-selected="false">
    Tab 3
  </button>
</div>
```

Each button represents a tab and has a `role` attribute set to `tab`. In most tabbed interfaces, the first tab panel is visible by default, so the first tab button has an `aria-selected` attribute set to `true` to indicate that its associated section of content is currently visible The `aria-controls` attribute is used to associate each button with the section of content that it controls.

Here are the three sections of content that correspond to the tabs:

```html
<div id="section1" role="tabpanel" aria-labelledby="tab1">
  Section 1 content
</div>

<div id="section2" role="tabpanel" aria-labelledby="tab2" hidden>
  Section 2 content
</div>

<div id="section3" role="tabpanel" aria-labelledby="tab3" hidden>
  Section 3 content
</div>
```

Each section of content has a `role` attribute set to `tabpanel` and an `aria-labelledby` attribute that points to the corresponding tab to give the panel an accessible name. The `hidden` attribute is used to hide the sections of content that are not currently selected. Each section id matches the value of the `aria-controls` attribute on the corresponding button. The `section1` id matches the `aria-controls` attribute on the first button, `section2` matches the `aria-controls` attribute on the second button, and `section3` matches the `aria-controls` attribute on the third button. This is how the association between the tabs and their sections of content is established.

To switch between the different sections you will need to use JavaScript to update the `hidden` attribute on the section and the `aria-selected` attribute on the button based on which section is currently visible. Only one section can be visible at a time and it should not have the `hidden` attribute and `aria-selected` should be set to `true` on its button. The remaining hidden sections should all have the `hidden` attribute and `aria-selected` should be set to `false` on their buttons.

Tabs are a common use case for the `aria-controls` attribute, but it can be used in other scenarios where one element controls the visibility or behavior of another element. Other examples include accordions, dropdown menus, and modals.

The next time you design a user interface that involves controlling the visibility  of elements, consider using the `aria-controls` attribute to establish the relationship between the controlling element and the controlled element.


## Module: Debugging Javascript


### Lecture Block: Lecture Debugging Techniques


## What Are Some Examples of Common JavaScript Errors?

### Description

As you've been programming in JavaScript, you've inevitably run into error messages. Understanding common error messages will help you debug more effectively and develop into a stronger programmer. The four common types of error messages are `SyntaxError`, `ReferenceError`, `TypeError`, and `RangeError`.

A `SyntaxError` happens when you write something incorrectly in your code, like missing a parenthesis, or a bracket. Think of it like a grammar mistake in a sentence. Here is a common mistake developers make when creating arrays:

```js
const arr = ["Beau", "Quincy" "Tom"]
```

Each array element needs to be separated by a comma otherwise it will result in an error message.

The second common JavaScript error is a `ReferenceError`. There are several types of `ReferenceError`s, triggered in different ways. The first type of `ReferenceError` would be not defined variables.

```js
console.log(price);
```

In this example, we are trying to log the `price` variable to the console but it hasn’t been defined. This is will result in a `ReferenceError`.

Another example of a `ReferenceError` is trying to access a variable, declared with `let` or `const`, before it has been defined:

```js
console.log(b);
const b = 50;
```

The example above will result in a `Cannot access 'b' before initialization` error. 

The third common error would be a `TypeError`. These errors occur when you try to perform an operation on the wrong type. Here is an example of trying to use the `map` method on an object:

```js
const developerObj = {
  name: "Jessica",
  country: "USA",
  isEmployed: true
};

developerObj.map()
```

This example will result in a `developerObj.map is not a function` error because the `map` method is used for arrays and not objects. 

The last common error we will look at is the `RangeError`.

A `RangeError` happens when your code tries to use a value that’s outside the range of what JavaScript can handle. Here is an example of trying to assign an invalid index to the length of the array:

```js
const arr = [];
arr.length = -1; 
```

Since `-1` is not a valid index used for arrays, this will result in a `RangeError`.

As you continue to program in JavaScript, just be aware of these different types of errors you will probably encounter and why they are happening.


## How Does the Throw Statement Work?

### Description

The `throw` statement in JavaScript is used to throw a user defined exception. An exception in programming, is when an unexpected event happens and disrupts the normal flow of the program.

As programmers it is important to handle these exceptions, so your programs don’t crash unexpectedly when errors occur. Here is the basic syntax for the `throw` statement:

```js
throw expression;
```

The `expression` in this case would be the object or value that represents the exception you want to throw. Examples of this would be the built in exception classes like the `Error`, `TypeError`, or `RangeError` class. Here is an example of using the `throw` statement to throw a `TypeError`:

```js
function validateNumber(input) {
  if (typeof input !== "number") {
    throw new TypeError("Expected a number, but received " + typeof input);
  }
  return input * 2;
}
```

In this example, we are checking if the type of `input` is not of type `number`. If not, then we are throwing a `TypeError` with a custom message. Otherwise, the function will return the result of multiplying the `input` by `2`. 

If you wanted to throw a more generic error message, then you can reference the `Error` constructor like this:

```js
function divide(numerator, denominator) {
  if (denominator === 0) {
    throw new Error("Cannot divide by zero");
  }
  return numerator / denominator;
}
```

Here is an example of a function that will check if the denominator is `0`. If that is the case, then it will throw a custom error message saying `Cannot divide by zero`.

In the next lecture, we will look at how to throw errors messages within the context of the `try`/`catch` block which is used to gracefully handle exceptions in JavaScript.


## How Does try...catch...finally Work?

### Description

In the previous lecture, you learned how to throw exceptions in your programs. In this lecture, we will take a look at how to gracefully handle these errors in a `try…catch…finally` block.

The `try` block is used to wrap code that might throw an error. It acts as a safe space to try something that could fail.

The `catch` block captures and handles errors that occur in the `try` block. You can use the `Error` object inside `catch` to inspect what went wrong.

The `finally` block runs after the `try` and `catch` blocks, regardless of whether an error occurred. It’s commonly used for cleanup tasks, such as closing files or releasing resources.

Here is an example of using a `try…catch` block:

```js
function processInput(input) {
  if (typeof input !== "string") {
    throw new TypeError("Input must be a string.");
  }

  return input.toUpperCase();
}

try {
  console.log("Starting to process input...");
  const result = processInput(9);
  console.log("Processed result:", result);
} catch (error) {
  console.error("Error occurred:", error.message);
} 
```

In this example, we have a function called `processInput` that first checks if the `input` is not of type `string`. If that is the case, then we throw an error. Otherwise, we return the result of using the `toUpperCase` method on the `input`.

We call the function inside of a `try` block. Since the function call throws an error, then it will be caught inside the `catch` block and the error message will be displayed in the console. 

The error passed into the `catch` block is an `Error` object which contains information about that error. In this case, we are using the `message` property which displays human readable information to the user. 

We are using the `console.error` because it is designed specifically to log errors. In many modern browsers, the output of `console.error()` appears in red in the console.

The `finally` statement is executed regardless of if an exception was thrown or not.

```js
try {
  // Code that might throw an error
} catch (error) {
  // Code to handle the error
} finally {
  // Code that runs regardless of whether an error occurred or not
}
```

A good use case for the `finally` statement is if you were working with files. In JavaScript, you can open a file, use a `try` block to write data to the file. If there are any errors, you can use the `catch` to catch those errors. Then use the `finally` statement to close the file.


## How Does the Debugger Statement Work?

### Description

The `debugger` statement is a powerful JavaScript tool that lets you pause your code at a specific line to investigate what's going on in the program. When used correctly, the `debugger` statement can save you a lot of time trying to figure out why something is not working as it should.

JavaScript executes your code from top to bottom. While JavaScript executes your code and hits a `debugger` statement, it immediately pauses execution at that line. This gives you the chance to inspect variables, check functions, and the flow of of the code in general.

With that, you can see exactly what is going right or wrong. However, this only happens if your browser's developer tools are open. Otherwise, the `debugger` statement is ignored, and the code continues to run as usual.

In addition, when you use the `debugger` statement, modern browsers will pause code execution at the specified line. They also allow you to resume execution by clicking the play button, but the page itself does not automatically reload unless manually triggered.

To use the `debugger` statement, place it at the line in which you want the code execution to pause. Here's an example:

```js
let firstNumber = 5;
let secondNumber = 10;
debugger; // Code execution pauses here
let sum = firstNumber + secondNumber;
console.log(sum);
```

With this example, if you don't have the console open before the code runs and you eventually open it, you'll see `15` in there. While the console is open and you reload the page, the execution is paused for you so you can inspect the code. 

Here's a more complex example:

```js
function calculateTotalPrice(price, discountPercentage) {
 debugger
 let discountAmount = (price * discountPercentage) / 100
 let totalPrice = price - discountAmount

 console.log(`Original Price: ${price}`)
 console.log(`Discount Amount: ${discountAmount}`)
 console.log(`Total Price after Discount: ${totalPrice}`)

 return totalPrice
}

let price = 100
let discount = 15

let finalPrice = calculateTotalPrice(price, discount)
console.log(`Final Price: ${finalPrice}`);
```

In this example the `debugger` statement is placed at the top of the `calculateTotalPrice`. When the function is called, the function execution will be paused.

If you reload the page with the console opened, you'll see that the page keeps reloading, confirming that the execution of the code is only paused, not stopped. If you want the execution to continue, you can click the play button.

As you continue to build out your JavaScript programs, test out the `debugger` statement in your code to see how it can help you better understand the flow of execution, inspect variables in real-time, and quickly identify where things might be going wrong.


## What Are Some Examples of Using Advanced JavaScript Debugging Techniques?

### Description

Debugging your JavaScript programs goes beyond using `console.log()` statements in your code. There are more advanced techniques that make debugging a breeze once you get used to them. Let's go through those more advanced techniques so you'll be happy to debug your JavaScript program once you run into errors.

The first concept we will take a look at is working with breakpoints. Breakpoints let you pause the execution of your code at a specific line of your choice. After the pause, you can inspect variables, evaluate expressions, and examine the call stack.

To add a breakpoint to any line in your code in the Chrome browser, open the developer tools and navigate to the Sources tab, open the JavaScript file you want to debug, and click on a line number to set a breakpoint.

After the execution reaches the breakpoint and stops, you can step through the code by using the icons on the top right corner. You can also add a conditional breakpoint by right-clicking on a line and selecting "Add conditional breakpoint…"

Now, let’s move on to watching expressions. Watch expressions lets you monitor the values of variables or expressions as the code runs even if they are out of the current scope.

To add a watch expression, navigate to the Sources tab of the developer tools, look for the watch panel on the right and click the plus (`+`) icon to add it.

The next concept we will look at is profiling. Profiling helps you identify performance bottlenecks by letting you capture screenshots and record CPU usage, function calls, and execution time.

To do that for your code, open the Performance tab, click record, and perform the action you want to profile. After you're done executing that action, stop the recording to analyze the results.

This could be useful if your application is lagging during certain operations. With the profiler, you can see which function or other data in the code consumes the most resources.

Now, let’s move onto inspecting network requests. Inspecting network requests can help you debug issues related to API requests such as parameter errors, address errors, or server errors.

To use the Network tab for debugging, open the developer tools and head over to the Network tab, then click on individual requests to see details like headers, responses, and payloads.

For the last portion of this lecture, we will focus on `console.table` and `console.dir`.

`console.table()` displays tabular data as a table in the console. It takes one mandatory argument, which must be an array or an object, and one optional argument to specify which properties or columns to display.

`console.dir()` on the other hand lets you display an interactive list of the properties of a specified JavaScript object. It outputs a hierarchical listing that can be expanded to see all nested properties.

Now that you have an expanded toolkit of debugging techniques, put these new skills to the test in your upcoming JavaScript projects. By applying these strategies, you'll be able to identify and resolve issues more efficiently, leading to cleaner, more reliable code.


## Module: Basic Regex


### Lecture Block: Lecture Working With Regular Expressions


## What Are Regular Expressions, and What Are Some Common Methods?

### Description

Regular expressions, or regex, are a feature supported by many different programming languages.

A regular expression is a special syntax to create a "pattern", which you can then use to check against a string, extract text, and more.

Let's take a look at a basic regular expression:

```js
const regex = /freeCodeCamp/;
```

Notice how, in JavaScript, you define a regular expression by creating your pattern between two forward slashes (`/`). Try not to confuse this with a comment, where the text comes after both forward slashes.

This particular regular expression will match the text `freeCodeCamp`, with capital `C`s, anywhere in a string. But how can you actually do that?

That brings us to our first method – the `test()` method. The `test()` method is present on `RegExp` objects, which are objects representing a regular expression (such as the one we just defined).

The `test()` method accepts a string, which is the string to test for matches against the regular expression. For example, let's try testing the string `e`:

```js
const regex = /freeCodeCamp/;
const test = regex.test("e");
console.log(test);
```

You can see we've called the `test()` method on our new regex, and passed the string `e` as the argument. We've also logged the result:

```js
console.log(test); // false
```

The `test()` method returned `false` because the string `e` does not match the pattern `freeCodeCamp`. Even though the pattern `freeCodeCamp` includes the letter `e`, that's the opposite direction of how regular expressions work.

Let's take a look at a few more examples. Take a moment to consider these:

```js
const regex = /freeCodeCamp/;
console.log(regex.test("freeCodeCamp"));
console.log(regex.test("freeCodeCamp is great"));
console.log(regex.test("I love freeCodeCamp"));
console.log(regex.test("freecodecamp"));
console.log(regex.test("FREECODECAMP"));
console.log(regex.test("free"));
console.log(regex.test("code"));
console.log(regex.test("camp"));
```

What do you think each line will print? Well, here's the result:

```js
const regex = /freeCodeCamp/;
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("freeCodeCamp is great")); // true
console.log(regex.test("I love freeCodeCamp")); // true
console.log(regex.test("freecodecamp")); // false
console.log(regex.test("FREECODECAMP")); // false
console.log(regex.test("free")); // false
console.log(regex.test("code")); // false
console.log(regex.test("camp")); // false
```

Did that surprise you? Notice how the first three strings returned `true`. These strings all contain the text, `freeCodeCamp`, exactly, somewhere in the string. 

Lines 5 and 6 return `false`. While they contain the text `freecodecamp`, the case does not match. Regular expressions are case-sensitive by default.

Finally, while the last three contain a portion of the pattern, the strings do not contain the entire pattern.

The `test()` method returns a `boolean`, indicating whether the string matches the regular expression at all.

But what if you wanted more information than that? Well, strings have a `match()` method. This method accepts a regular expression, although you can also pass a string which will be constructed into a regular expression.

`match()` returns the match array for the string. What's a match array? Well, let's take a look:

```js
const regex = /freeCodeCamp/;
const match = "freeCodeCamp".match(regex);
console.log(match);
```

If we run this, we get an array back! But it's a strange looking array. It's got some extra properties:

```js
console.log(match);
// [
//   'freeCodeCamp',
//   index: 0,
//   input: 'freeCodeCamp',
//   groups: undefined
// ]
```

The `groups` property would show any captured groups. You will learn what that means in a future lecture.

The `index` property tells you at what character in the string the match was found. In our case, it was found at the beginning of the string.

The `input` property tells you the string the `match()` method was called on.

Let's try a few more again, and see how the result changes:

```js
const regex = /freeCodeCamp/;
console.log("freeCodeCamp".match(regex)); // ['freeCodeCamp', index: 0, input: 'freeCodeCamp', groups: undefined]
console.log("freeCodeCamp is great".match(regex)); // ['freeCodeCamp', index: 0, input: 'freeCodeCamp is great', groups: undefined]
console.log("I love freeCodeCamp".match(regex)); // ['freeCodeCamp', index: 7, input: 'I love freeCodeCamp', groups: undefined]
console.log("freecodecamp".match(regex)); // null
console.log("FREECODECAMP".match(regex)); // null
console.log("free".match(regex)); // null
```

We know already that the first three strings should produce a match, so let's take a look at those:

```js
// ['freeCodeCamp', index: 0, input: 'freeCodeCamp', groups: undefined]
// ['freeCodeCamp', index: 0, input: 'freeCodeCamp is great', groups: undefined]
// ['freeCodeCamp', index: 7, input: 'I love freeCodeCamp', groups: undefined]
```

Is that what you expected? You can see how the `input` and `index` have changed depending on the string provided, and the location of the match in the string. 

The other three lines, which do not match, return `null` instead of an array.

Now that we can test and match strings with our regular expression, what if we want to replace the content of a string? Maybe someone has written `freecodecamp` in all lowercase, and we want to automatically fix the casing for them.

First, we need to update our regular expression to match the lowercase form of `freecodecamp`, and create our test string:

```js
const regex = /freecodecamp/;
const str = "freecodecamp is rly kewl";
```

Now, strings have a `replace()` method which accepts two arguments: the regular expression to match (or a string, if you don't need all of the features of regex), and the string to replace the match with (or a function to run against each match). 

So if we wanted to replace our `freecodecamp` with the proper casing:

```js
const regex = /freecodecamp/;
const str = "freecodecamp is rly kewl";
const replaced = str.replace(regex, "freeCodeCamp");
console.log(replaced);
```

And we'll peek at the result:

```js
console.log(replaced); // freeCodeCamp is rly kewl
```

You can see that `replace()` returns the updated string with the matching pattern `replaced`.

Regular expressions, and all of the methods associated with them, can seem complex and overwhelming. But you'll get the chance to explore them further in this next set of lectures.


## What Are Some Common Regular Expression Modifiers Used for Searching?

### Description

Modifiers, often referred to as "flags", modify the behavior of a regular expression. Let's recall our example from an earlier lecture:

```js
const regex = /freeCodeCamp/;
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("freeCodeCamp is great")); // true
console.log(regex.test("I love freeCodeCamp")); // true
console.log(regex.test("freecodecamp")); // false
console.log(regex.test("FREECODECAMP")); // false
console.log(regex.test("free")); // false
console.log(regex.test("code")); // false
console.log(regex.test("camp")); // false
```

If you remember, the all-lowercase and all-uppercase `freeCodeCamp` strings failed to match the pattern. This is because, by default, regular expressions are case-sensitive.

But what if we could tell the regular expression to be case-insensitive? Well, there's a modifier for that. The `i` flag makes a regex ignore case. How can we use it? Flags go after the closing forward slash in a regular expression:

```js
const regex = /freeCodeCamp/i;
```

Notice the change to the regular expression on the first line. Now we can check how this changes things:

```js
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("freeCodeCamp is great")); // true
console.log(regex.test("I love freeCodeCamp")); // true
console.log(regex.test("freecodecamp")); // true
console.log(regex.test("FREECODECAMP")); // true
console.log(regex.test("free")); // false
console.log(regex.test("code")); // false
console.log(regex.test("camp")); // false
```

Because our regular expression is now case-insensitive, the all-lowercase and all-uppercase strings have "passed" the test. This can also work for a string with a random mix of uppercase and lowercase letters:

```js
console.log(regex.test("dO yOu LoVe fReEcOdEcAmP?")); // true
```

There are quite a few other flags that you can use. The `g` flag, or global modifier, allows your regular expression to match a pattern more than once. 

Let's see how that affects our code. You'll notice we kept the `i` flag – a regular expression can use multiple flags (as many as needed) to achieve your desired behavior:

```js
const regex = /freeCodeCamp/gi;
```

Wait a second... what's this? It would seem that the global modifier is making some of our strings that should be passing fail instead:

```js
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("freeCodeCamp is great")); // false
console.log(regex.test("I love freeCodeCamp")); // true
console.log(regex.test("freecodecamp")); // false
console.log(regex.test("FREECODECAMP")); // true
console.log(regex.test("free")); // false
console.log(regex.test("code")); // false
console.log(regex.test("camp")); // false
```

Why? Well, the global modifier makes your regular expression stateful. This means it keeps track of where it has previously matched a pattern. So when it matches the first `freeCodeCamp` string, it remembers that it found a match starting at index `0`.

We then test it against `freeCodeCamp is great`, but it doesn't start at index `0`. The regular expression "knows" it found a match at index `0` already, so even though this is a different string, it starts from the end index of the match. 

`freeCodeCamp` is `12` characters long, so a match at `0` ends at index `11`. The matching will resume at index `12`. And since `is great` does not match `freeCodeCamp`, it returns `false`.

Then, because it fails to find a match, it "loses" its state and starts the following match back at `0`.

If we switch our logs around so that a string with the match at `0` is followed immediately by a string that has a match later than index `11`:

```js
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("I loooooooove freeCodeCamp")); // true
```

When a regular expression is global, it gets a new property called `lastIndex`. Grabbing our previous code, let's see how this property works:

```js
console.log(regex.lastIndex); // 0
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.lastIndex); // 12
console.log(regex.test("freeCodeCamp is great")); // false
console.log(regex.lastIndex); // 0
console.log(regex.test("I love freeCodeCamp")); // true
console.log(regex.lastIndex); // 19
console.log(regex.test("freecodecamp")); // false
console.log(regex.lastIndex); // 0
console.log(regex.test("FREECODECAMP")); // true
console.log(regex.lastIndex); // 12
console.log(regex.test("free")); // false
console.log(regex.lastIndex); // 0
console.log(regex.test("code")); // false
console.log(regex.lastIndex); // 0
console.log(regex.test("camp")); // false
```

Looking at this example, you can see how the state of the regular expression changes with each test call using the `lastIndex` to track its previous matches.

The global flag is great when you need to get multiple matches from a single string. But if you're testing multiple strings with the same regular expression it's best to leave the `g` flag off.

Before learning about the next flag, you need to learn about anchors. The carrot (`^`) anchor, at the beginning of the regular expression, says "match the start of the string":

```js
const start = /^freecodecamp/i;
```

The dollar sign (`$`) anchor, at the end of the regular expression, says "match the end of the string":

```js
const end = /freecodecamp$/i;
```

Take a moment to compare the outputs on the right:

```js
const start = /^freecodecamp/i;
const end = /freecodecamp$/i;
console.log(start.test("freecodecamp")); // true
console.log(end.test("freecodecamp")); // true
console.log(start.test("freecodecamp is great")); // true
console.log(end.test("freecodecamp is great")); // false
console.log(start.test("i love freecodecamp")); // false
console.log(end.test("i love freecodecamp")); // true
console.log(start.test("have met freecodecamp's founder")); // false
console.log(end.test("have met freecodecamp's founder")); // false
```

See how the start anchor only matches at the beginning of the string, and the end anchor only matches at the end of the string? But what about matching across multiple lines? Let's take a look at that:

```js
const start = /^freecodecamp/i;
const end = /freecodecamp$/i;
const string = `I really love
freecodecamp
it's my favorite`;
console.log(start.test(string)); // false
console.log(end.test(string)); // false
```

Even though `freecodecamp` is in there on its own line, it fails both tests. This is because, by default, anchors look for the beginning and end of the entire string.

But you can make a regex handle multiple lines with the `m` flag, or the multi-line modifier. Let's add that to our regular expressions to see what we get:

```js
const start = /^freecodecamp/im;
const end = /freecodecamp$/im;
const string = `I really love
freecodecamp
it's my favorite`;
console.log(start.test(string)); // true
console.log(end.test(string)); // true
```

Now they both match! Because the `freecodecamp` is entirely on its own line, the start anchor matches the beginning of that line, and the end anchor matches the end of that line.

Finally, you have the `d` flag, or indices modifier. Remember that the `i` flag is for case-insensitivity, so the indices modifier needed a different flag.

The `d` flag expands the information you get in a match object. Let's add it to our regular expression:

```js
const regex = /freecodecamp/di;
const string = "we love freecodecamp isn't freecodecamp great?";
console.log(string.match(regex));
```

And the result is:

```js
// [
//   'freecodecamp',
//   index: 8,
//   input: "we love freecodecamp isn't freecodecamp great?",
//   groups: undefined,
//   indices: [
//     0: [8, 20],
//     groups: undefined
//   ]
// ]
```

Our match object gets a new `indices` property! This property is an array of two numbers, the first being the index in the original string where the match starts, and the second being the index after the match ended. This array also has an extra `groups` property, which is also for named capture groups.

There are a few other flags that you should know are available to you, but are less common in typical code.

The first is the unicode modifier, or `u` flag. This expands the functionality of a regular expression to allow it to match special unicode characters.

You'll learn more about character classes in a later lecture, but the `u` flag gives you access to special classes like `Extended_Pictographic` to match most emoji:

```js
const regex = /🍎/u;

const str = "I have an apple 🍎";
console.log(regex.test(str)); // true
```

There is also a `v` flag, which further expands the functionality of the unicode matching.

The second is the sticky modifier, or the `y` flag. The sticky modifier behaves very similarly to the global modifier, but with a few exceptions.

The biggest one is that a global regular expression will start from `lastIndex` and search the entire remainder of the string for another match, but a sticky regular expression will return `null` and reset the `lastIndex` to `0` if there is not immediately a match at the previous `lastIndex`.

And the last is the single-line modifier, or the `s` flag. Remember that the multiline modifier allows start and end anchors to match the start and end of a line, instead of the entire string. 

The single-line modifier allows a wildcard character, represented by a period (`.`) in regex, to match linebreaks – effectively treating the string as a single line of text.

There are quite a few of these modifiers, but the `i` and `g` flags are the ones you'll use most frequently, and are the most important to remember.


## How Can You Match and Replace All Occurrences in a String?

### Description

Let's learn how to match or replace all occurrences of a pattern in a string.

You have previously learned about the `replace()` and `match()` methods, as well as the global `g` modifier. Now you can combine that knowledge to handle all patterns in a string. Let's recall our original match code:

```js
const regex = /freeCodeCamp/;
const match = "freeCodeCamp".match(regex);
console.log(match);
```

And our resulting match object:

```js
// [
//   'freeCodeCamp',
//   index: 0,
//   input: 'freeCodeCamp',
//   groups: undefined
// ]
```

But what if we have a string with multiple occurrences of `freecodecamp` to match? Let's take a look at how `match()` behaves with that. We'll throw in our old `replace()` example too, just to compare:

```js
const regex = /freecodecamp/;
const str = "freecodecamp is the best we love freecodecamp";
const matched = str.match(regex);
const replaced = str.replace(regex, "freeCodeCamp");
console.log(matched);
console.log(replaced);
```

And the result is this:

```js
// [
//   'freecodecamp',
//   index: 0,
//   input: 'freecodecamp is the best we love freecodecamp',
//   groups: undefined
// ]
// freeCodeCamp is the best we love freecodecamp
```

Oh no! `match()` only returned the first match, and `replace()` only replaced the first match. This is because, by default, `match()` and `replace()` only operate against the first pattern occurrence.

Thankfully, you can avoid this by using the global modifier on your regular expression. Let's add that to ours:

```js
const regex = /freecodecamp/g;
const str = "freecodecamp is the best we love freecodecamp";
const matched = str.match(regex);
const replaced = str.replace(regex, "freeCodeCamp");
console.log(matched);
console.log(replaced);
```

And confirm the result:

```js
// [ 'freecodecamp', 'freecodecamp' ]
// freeCodeCamp is the best we love freeCodeCamp
```

That worked! Our replace call replaced all of the lowercase `freecodecamp` strings, and our `match()` method matched both of them.

What's interesting here is that when you use the global modifier with `match()`, you lose the extra information about capture groups and string indices that would come in the match array.

Thankfully, 2019's ECMAScript update brought us two new methods: `matchAll()` and `replaceAll()`. Like their singular counterparts, these methods accept a string or regular expression, and `replaceAll()` also accepts a second argument as the string to replace with. 

But unlike the previous methods, `replaceAll()` and `matchAll()` will throw an error if you give them a regular expression without the global modifier. Let's update our code to use these new methods:

```js
const pattern = "freecodecamp";
const str = "freecodecamp is the best we love freecodecamp";
const matched = str.matchAll(pattern);
const replaced = str.replaceAll(pattern, "freeCodeCamp");
console.log(matched);
console.log(replaced);
```

And our result:

```js
// {}
// freeCodeCamp is the best we love freeCodeCamp
```

Good news! Our `replaceAll()` worked exactly as we wanted – it replaced all occurrences of the lowercased `freecodecamp` with the properly camelCased version.

But what is that empty object? Well, `matchAll()` returns a special type of object called an `Iterator`, which the freeCodeCamp console isn't prepared to handle.

If we peek in our browser console, the `Iterator` has a `next()` method, which we can call to get the next value:

```js
// RegExpStringIterator {  }
//  <prototype>: RegExp String Iterator {
//    next: ƒ next(),
//    Symbol(Symbol.toStringTag): "RegExp String Iterator"
//    <prototype>: Object { ... }
//  }
```

Let's go ahead and call `matched.next()`, and log the result:

```js
// {
//   "done": false,
//   "value": [
//     0: "freecodecamp"
//     groups: undefined
//     index: 0
//     input: "freecodecamp is the best we love freecodecamp"
//   ]
// }
```

There's our match array! `next()` gives us an object with two values: `done`, which is `false` when there are more elements available in the iterator, and `value` which is the value we just iterated over. So, if we call it one more time:

```js
const regex = /freecodecamp/g;
const str = "freecodecamp is the best we love freecodecamp";
const matched = str.matchAll(regex);
const replaced = str.replaceAll(regex, "freeCodeCamp");
console.log(matched);
console.log(replaced);
console.log(matched.next());
console.log(matched.next());
```

```js
// {
//   "done": false,
//   "value": Array [ "freecodecamp"]
// }
//
// {
//   "done": false,
//   "value": Array [ "freecodecamp"]
// }
```

Wait, why does it say `done` is still `false`? There should only be two matches in the array, right? Let's call it a third time and see what we get:

```js
// {
//   "done": false,
//   "value": Array [ "freecodecamp"]
// }
//
// {
//   "done": false,
//   "value": Array [ "freecodecamp"]
// }
//
// {
//   "done": true,
//   "value": undefined
// }
```

`done` is finally `true`, but why is that value `undefined`? Well, as it turns out, the `matchAll()` iterator is lazy. It doesn't find all of your matches at once. It only finds a match when you tell it to by calling `next()`.

As long as it finds a match, it isn't `done`. Once it fails to find a match and brings back `undefined`, it is `done`. This may seem inconvenient, but it can be quite helpful when your regular expression is computationally expensive.

If your example is less so, like ours, you can skip that feature and extract all of the matches at once by converting it to an array. This is achieved by calling `Array.from()` and passing your iterator as the argument.

Let's update our code to use that – we'll go ahead and clean up our `replaceAll` calls since we know that works:

```js
const regex = /freecodecamp/g;
const str = "freecodecamp is the best we love freecodecamp";
const matched = str.matchAll(regex);
console.log(Array.from(matched));
```

And we finally get our array of matches:

```js
// [
//   'freecodecamp',
//   index: 0,
//   input: 'freecodecamp is the best we love freecodecamp',
//   groups: undefined
// ]
//
// [
//   'freecodecamp',
//   index: 33,
//   input: 'freecodecamp is the best we love freecodecamp',
//   groups: undefined
// ]
```

These powerful methods can help you manipulate and extract data from strings without having to sacrifice performance or readability.


## What Are Character Classes, and What Are Some Common Examples?

### Description

Let's learn about character classes in regular expressions, including some common examples.

Character classes are a special syntax you can use to match sets or subsets of characters.

The first character class you should learn is the wildcard class.

The wildcard is represented by a period or dot (`.`), and matches any single character except line breaks. To allow the wildcard class to match line breaks, remember that you would need to use the `s` flag.

A regular expression that matched the letter `a` followed by one single character might look like:

```js
const regex = /a./;
```

This can be helpful when you are looking for specific patterns in a string, but don't know what might be between those two patterns. But you can also use character classes to narrow down your matches.

For example, what if you wanted to match a numerical character? You might have to write out every possible digit, separating them with the or operator (`|`):

```js
const regex = /0|1|2|3|4|5|6|7|8|9/;
```

A character class exists for this exact pattern, and gives you a shorthand syntax for writing the same thing. In this case, the character class is written as a backslash (`\`) followed by a `d` character:

```js
const regex = /\d/;
```

This regular expression will match the exact same pattern as our previous expression: a single numerical character anywhere in the string.

Now consider a regular expression which also needs to match any letter character `a` through `z`. You could write out each individual character separated by the or operator. Or you could use another character class.

The `\w` class, which is a backslash followed by a `w`, represents any word character:

```js
const regex = /\w/;
```

A word character is defined as any letter, from `a` to `z`, or a number from `0` to `9`, or the underscore (`_`) character.

The inclusion of the underscore might seem strange, but consider the naming conventions for variables – variable names can often include underscores, so `\w` is designed to match that as well.

There is one more special character class to consider: the whitespace class `\s`, represented by a backslash followed by an `s`. This character class will match any whitespace, including new lines, spaces, tabs, and special unicode space characters.

These special character classes can be negated. To negate one of these character classes, instead of using a lowercase letter after the backslash, use the uppercase equivalent:

```js
const regex = /\D/;
```

This regular expression, for example, does not match a numerical character. Instead, it matches any single character that is not a numerical character.

Negating the `\w` class would match any character that is not `a` to `z`, `0` to `9`, or an underscore, and negating the `\s` character class would match any character that is not a whitespace.

But what if you wanted to match more specific subsets of characters?

Maybe you're a professor grading papers, and you need to make sure your grades are valid. A valid grade can be `A`, `B`, `C`, `D`, or `F`. You can use square brackets to construct your own character class:

```js
const regex = /[abcdf]/;
```

This regular expression will match a single character that is in the list `a`, `b`, `c`, `d`, or `f`.

What about checking only grades that pass? A passing grade would be an `A`, `B`, `C`, or `D`. You can modify your character class to stop matching `f` by removing that character from the list:

```js
const regex = /[abcd]/;
```

You may have noticed now that our character class consists only of consecutive characters. `a`, `b`, `c`, and `d` are all directly next to each other in the alphabet. For numbers, consecutive characters might be `4`, `5`, and `6`.

When you have consecutive characters, you can create a range using the hyphen character.

Using a range, we can turn our regular expression into a shorter syntax while matching the exact same pattern.

```js
const regex = /[a-d]/;
```

Remember that regular expressions are case-sensitive by default. This means our character class will only match the lowercase variants of `a`, `b`, `c`, and `d`. You could use the `i` flag to achieve this, but you can also bake it directly into your character class by including the uppercase variants:

```js
const regex = /[a-zA-Z]/;
```

You can also mix digits and numbers in your character class. For example, if you wanted the behavior of the `\w` class without the underscore, you could construct your own:

```js
const regex = /[a-zA-Z0-9]/;
```

Note that if you want your character class to match a literal hyphen, you need to place a hyphen at the beginning or end of the class:

```js
const regex = /[-a-zA-Z0-9]/;
```

And finally, you can include special character classes in your custom class. Maybe you want to include a hyphen in the set matched by `\w`:

```js
const regex = /[-\w]/;
```

Character classes are a powerful tool that gives you incredible control over your pattern matching.


## What Are Lookahead and Lookbehind Assertions, and How Do They Work?

### Description

Let's learn about lookahead and lookbehind assertions in regular expressions.

Lookahead and lookbehind assertions allow you to match specific patterns based on the presence or lack of surrounding patterns. There are four variations of these assertions.

First is the positive lookahead assertion. This assertion will match a pattern when the pattern is followed by another pattern.

To construct a positive lookahead, you need to start with the pattern you want to match. Then, use parentheses to wrap the pattern you want to use as your condition. After the opening parenthesis, use `?=` to define that pattern as a positive lookahead.

This pattern will only match the word `free` if it is followed by `code`:

```js
const regex = /free(?=code)/i;
```

Let's test the behavior of our pattern:

```js
const regex = /free(?=code)/i;
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("free code camp")); // false
console.log(
  regex.test("I need someone for free to write code for me")
); // false
```

Notice how only the string where `free` is immediately followed by `code` passes the test.

But what if you want to match the presence of `free` when it is NOT followed by `code`? You can turn your positive lookahead into a negative lookahead to invert the behavior. To do this, change your `?=` to `?!`:

```js
const regex = /free(?!code)/i;
```

Let's test this against our same strings:

```js
const regex = /free(?!code)/i;
console.log(regex.test("freeCodeCamp")); // false
console.log(regex.test("free code camp")); // true
console.log(
  regex.test("I need someone for free to write code for me")
); // true
```

As expected, the results are reversed. The only string that fails is the first string, where `free` is immediately followed by `code`.

Lookbehind assertions function similarly to lookahead assertions, except that, instead of matching conditionally based on a following pattern, they match conditionally based on a preceding pattern. Let's take a look at a positive lookbehind.

A positive lookbehind is denoted with `?<=` instead of `?=`. Let's make our regular expression match `code` when it is preceded by `free`:

```js
const regex = /(?<=free)code/i;
```

Just like with our positive lookahead, our positive lookbehind matches the first string because `code` is immediately preceded by `free`:

```js
const regex = /(?<=free)code/i;
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("free code camp")); // false
console.log(
  regex.test("I need someone for free to write code for me")
); // false
```

To match `code` when it is NOT preceded by `free`, we can use a negative lookbehind. A negative lookbehind is defined by replacing `?<=` with `?<!`:

```js
const regex = /(?<!free)code/i;
```

This would match any occurrence of `code` that is NOT immediately preceded by `free`.

```js
const regex = /(?<!free)code/i;
console.log(regex.test("freeCodeCamp")); // false
console.log(regex.test("free code camp")); // true
console.log(
  regex.test("I need someone for free to write code for me")
); // true
```

Remember that `Regex.prototype.test` only confirms whether a string matches the regular expression. Let's use our negative lookbehind with `String.prototype.match` to see how assertions affect that:

```js
const regex = /(?<!free)code/i;
console.log("freeCodeCamp".match(regex)); // null
console.log("free code camp".match(regex)); // ['code', index: 5, input: 'free code camp', groups: undefined]
console.log(
  "I need someone for free to write code for me".match(regex)
); // ['code', index: 33, input: 'I need someone for free to write code for me', groups: undefined]
```

Notice how even though our regular expression uses a lookbehind to check for the presence of `free`, it does not match `free`. The only text included in the match is `code`.

Lookaheads and lookbehinds are incredibly useful for conditionally matching text without impacting the returned value of your match.


## What Are Regex Quantifiers, and How Do They Work?

### Description

Let's learn about quantifiers in regular expressions.

Consider a scenario where you want to match a four-digit identification code. You know you can use the `\d` character class, so you might write that four times. And to avoid any extraneous characters, you'd include both the start and end anchors:

```js
const regex = /^\d\d\d\d$/;
```

And this does work – it will match four numerical characters. But rather than having to write out the same class multiple times, you can give it a quantifier.

Quantifiers are defined by curly braces containing one or two numbers. Let's use a quantifier in our pattern:

```js
const regex = /^\d{4}$/;
```

Notice how our quantifier contains only the number `4`. This syntax means "match the previous character exactly four times". Let's see how that behaves:

```js
const regex = /^\d{4}$/;
console.log(regex.test("123")); // false
console.log(regex.test("1234")); // true
console.log(regex.test("12345")); // false
console.log(regex.test("123456")); // false
console.log(regex.test("1234567")); // false
```

The pattern only matches the string with exactly four digits, because we have used the anchors and our quantifier only allows exactly four digits. But maybe the identification code only needs to be a minimum of four digits.

To allow for four or more digits, add a comma after the number in your quantifier:

```js
const regex = /^\d{4,}$/;
```

Now, our syntax allows the pattern to match four or more digits. Let's test it:

```js
const regex = /^\d{4,}$/;
console.log(regex.test("123")); // false
console.log(regex.test("1234")); // true
console.log(regex.test("12345")); // true
console.log(regex.test("123456")); // true
console.log(regex.test("1234567")); // true
```

A seven-digit identifier is rather long. These identifiers should have a maximum of 6 digits, and a minimum of 4 digits. To achieve this, you can add a second number to your quantifier after the comma:

```js
const regex = /^\d{4,6}$/;
```

And now our pattern no longer matches the seven-digit identifier, because it is greater than our six-digit maximum.

```js
const regex = /^\d{4,6}$/;
console.log(regex.test("123")); // false
console.log(regex.test("1234")); // true
console.log(regex.test("12345")); // true
console.log(regex.test("123456")); // true
console.log(regex.test("1234567")); // false
```

Note that you cannot use this syntax to set a maximum alone – you must always set a minimum. But if you set the minimum to `1`, you can effectively achieve the same result.

We've received updated requirements from our users. Identifiers can now optionally start with a letter. We already know the character class for this, so let's add that to our regular expression:

```js
const regex = /^[a-zA-z]\d{4,6}$/;
```

But now we mandate the presence of a letter. How can we make it optional?

You could use the quantifier syntax with `0` as the minimum and `1` as the maximum:

```js
const regex = /^[a-zA-Z]{0,1}\d{4,6}$/;
```

But there's actually a special shorthand quantifier for a single optional character – the question mark (`?`). Let's replace our quantifier with the question mark:

```js
const regex = /^[a-zA-Z]?\d{4,6}$/;
```

We should validate the result:

```js
const regex = /^[a-zA-Z]?\d{4,6}$/;
console.log(regex.test("123")); // false
console.log(regex.test("a1234")); // true
console.log(regex.test("12345")); // true
console.log(regex.test("az12345")); // false
console.log(regex.test("X123456")); // true
console.log(regex.test("1234567")); // false
```

Our pattern now allows for a single optional letter, followed by four to six digits.

Unfortunately, we've just realized we read the requirements wrong. We need to allow for any number of letters before the numbers. We can use our quantifier with a `0` minimum and no defined maximum:

```js
const regex = /^[a-zA-Z]{0,}\d{4,6}$/;
```

But our pattern is getting long again. Thankfully, there's another short-hand for "match the previous character zero or more times" –  the asterisk (`*`) symbol. Let's replace our quantifier with that in the pattern, and test it:

```js
const regex = /^[a-zA-Z]*\d{4,6}$/;
console.log(regex.test("123")); // false
console.log(regex.test("a1234")); // true
console.log(regex.test("12345")); // true
console.log(regex.test("az12345")); // true
console.log(regex.test("X123456")); // true
console.log(regex.test("1234567")); // false
```

Now we successfully match any identifier with zero or more letters followed by four to six numbers. But it turns out this is crashing our system – we actually have to require at least one letter.

Again, we could use a quantifier with a minimum of one and no defined maximum, or we could use yet another special syntax – the plus (`+`) symbol:

```js
const regex = /^[a-zA-Z]+\d{4,6}$/;
console.log(regex.test("123")); // false
console.log(regex.test("a1234")); // true
console.log(regex.test("12345")); // false
console.log(regex.test("az12345")); // true
console.log(regex.test("X123456")); // true
console.log(regex.test("1234567")); // false
```

Now the identifiers that do not start with at least one letter fail, regardless of how many numbers there are.

You can use quantifiers to greatly enhance the brevity and readability of your regular expressions.


## What Are Capturing Groups and Backreferences, and How Do They Work?

### Description

Let's learn about capturing groups and backreferences in regular expressions.

A capturing group allows you to "capture" a portion of the matched string to use however you might need. Capturing groups are defined by parentheses containing the pattern to capture, with no leading characters like a lookahead.

Let's capture the `code` from our `freeCodeCamp` regular expression. To do that, we'll enclose `code` in parentheses and define it as a capture group:

```js
const regex = /free(code)camp/i;
```

To confirm the behavior, we can test it against a `freecodecamp` string:

```js
const regex = /free(code)camp/i;
console.log(regex.test("freecodecamp")); // true
```

But this doesn't actually make use of our captured group. Instead, let's take a look at the result of using `match`:

```js
const regex = /free(code)camp/i;
console.log("freecodecamp".match(regex));
// [
//   'freecodecamp',
//   'code', <--
//   index: 0,
//   input: 'freecodecamp',
//   groups: undefined
// ]
```

Here we can see that our `match` array has a second element, which is the portion of the string which was captured by our capture group.

Notice how the capture group matches the exact pattern `code`, where a character class would match a single character from the list `c`, `o`, `d`, and `e`.

But how can we actually use this? Well, capture groups are often used when replacing contents of a string. Let's set up some code to do that. We're going to turn `freecodecamp` into `paidcodeworld`:

```js
const regex = /free(code)camp/i;
console.log("freecodecamp".replace(regex, "paidcodeworld"));
```

This works on its own, but what if we didn't know how many `o`'s were in `code`? If we need a quantifier for one or more `o`s:

```js
const regex = /free(co+de)camp/i;
console.log("freecoooooooodecamp".replace(regex, "paidcodeworld"));
```

We're getting `paidcodeworld` as our result. We want to preserve the number of `o`'s, so we need to reuse what was captured by the regular expression.

This is where a backreference comes in. Instead of hardcoding the `code` portion of our replacement string, we can reference the captured group directly.

In a `replace` call, you achieve a backreference by using a dollar sign (`$`) followed by the number of the capture group to use. In our case, that would be `$1`, since `code` is captured in the first capture group:

```js
const regex = /free(co+de)camp/i;
console.log("freecoooooooodecamp".replace(regex, "paid$1world")); // paidcooooooooworld
```

We have now successfully preserved an unknown number of `o` characters when converting `freecodecamp` into `paidcodeworld`. But backreferences aren't just limited to the replace call. You can actually use them directly in a regular expression.

This would allow you to match a previously captured pattern later on in the regular expression.

Let's say we want to match `freecodecamp` twice, with the same number of `o`'s, but anywhere in the string.

First, we need to separate them with our wildcard character, and allow any number of characters to match that wildcard:

```js
const regex = /free(co+de)camp.*free(co+de)camp/i;
```

This current expression won't ensure that the number of `o` characters is the same, however. To achieve that, we need to replace the second capture group with a reference to the first.

Inside a regular expression, a backreference is denoted with a backslash followed by the number of the capture group:

```js
const regex = /free(co+de)camp.*free\1camp/i;
console.log(regex.test("freecooooodecamp is great i love freecooooodecamp")); // true
console.log(regex.test("freecooooodecamp is great i love freecodecamp")); // false
```

And with that, we can see that a string with the correct number of `o`s matches, while a string with two different numbers of `o`s does not.

This syntax is great, but can quickly get confusing when you are referencing multiple capture groups. Thankfully, instead of using numbers, you can give your groups names.

To define a named capture group, you add a question mark (`?`) followed by the name enclosed in less than and greater than signs to the beginning of the group. Let's name our capture group `code`:

```js
const regex = /free(?<code>co+de)camp.*free\1camp/i;
```

Now we can update our backreference in the regular expression to refer to this group. A named backreference starts with a backslash followed by the letter `k` in JavaScript. Then you add the name, again enclosed in less than (`<`) and greater than (`>`) signs. Let's take a look at that:

```js
const regex = /free(?<code>co+de)camp.*free\k<code>camp/i;
```

Now if we check our `test()` call, we can see that we still pass:

```js
const regex = /free(?<code>co+de)camp.*free\k<code>camp/i;
console.log(regex.test("freecooooodecamp is freecooooodecamp")); // true
```

To use our named capture group in a `replace()` call, we'd insert a dollar sign into the string, followed by the name enclosed in less than and greater than signs:

```js
const regex = /free(?<code>co+de)camp/i;
console.log("freecooooodecamp".replace(regex, "paid$<code>camp")); // paidcooooodecamp
```

Finally, sometimes you want to create a group of characters, but don't need the captured result.

Let's say we want to match either `freecodecamp` or `freecandycamp`. You could create two patterns separated by an OR assertion:

```js
const regex = /freecodecamp|freecandycamp/i;
```

But this can become quite lengthy for larger-scale regular expressions. Instead, you can create a non-capturing group around the characters that you need to OR:

```js
const regex = /free(?:code|candy)camp/i;
```

A non-capturing group does not store the `code|candy` match separately in memory. But it can be helpful for creating alternate patterns without sacrificing readability or performance.


## Module: Form Validation


### Lecture Block: Lecture Understanding Form Validation


## What Are Some Ways to Validate Forms Using JavaScript?

### Description

Let's learn about how to use JavaScript to validate your forms.

In a previous lecture, you've learned how to use HTML to restrict the values your users can submit in your form. But sometimes that's not enough. If you want to get more complex, such as displaying your own error messages to the user, you will need to use JavaScript.

Certain HTML elements, such as the `textarea` and `input` elements, expose a Constraint Validation API. This API allows you to assert that the user's provided value for that element passes any HTML-level validation you have written, such as minimum length or pattern matching.

But how can you actually use it? Let's say you wanted employees at a company to send feedback messages through a form like this:

```html
<form>
  <label>Enter your email: </label>
  <input required type="email" />

  <label>Enter your feedback: </label>
  <textarea required placeholder="Your feedback here..."></textarea>

  <button type="submit">Submit Feedback</button>
</form>
```

We are using the email `input` which comes with built in validation to check for basic validation like if the input includes the at (`@`) sign.

But what if the user provides an email address like `example@email.com`? This would pass the basic validation, but we want to be more specific about accepting emails from those with a company email address.

This is where we can use the `pattern` attribute to specify that the email address must end in a company email address. Here is what the updated example will look like:

```html
<form>
  <label>Enter your email: </label>
  <input required placeholder="username@sampleCompany.com" type="email" pattern=".+@sampleCompany\.com" />

  <label>Enter your feedback: </label>
  <textarea required placeholder="Your feedback here..."></textarea>

  <button type="submit">Submit Feedback</button>
</form>
```

Now, if you try to submit the feedback, you will see a message saying "Please match the requested format."

Even though the `input` does have placeholder text showing them the desired format, it would be better to also include a customized error message using JavaScript.

Let's first take a look at the `checkValidity()` method:

```js
const input = document.querySelector("input");

input.addEventListener("input", (e) => {
  console.log(e.target.checkValidity())
})
```

In the above example, we've queried our input from the DOM, and added an input event listener.

We know that `e.target` refers to the element that triggered the event. In this case, our `input`. But what is the `checkValidity()` method?

This is part of the Constraint Validation API. The `checkValidity()` method returns `true` if the element matches all HTML validation (based on its attributes), and `false` if it fails.

When we try with an invalid input, we see `false` gets logged in the console. Now that we know the input is invalid, let's report the invalidity:

```js
const input = document.querySelector("input");

input.addEventListener("input", (e) => {
  if (!e.target.checkValidity()) {
    e.target.reportValidity();
  }
})
```

And as a result, you will see the browser's error message "Please match the requested format."

It reports the invalid state immediately, instead of waiting for us to submit the form. But it's still using the default message. This is because the `reportValidity` method only tells the browser that the input is invalid. The browser still chooses how to display why it's invalid. That's where the `setCustomValidity` method comes in.

```js
const input = document.querySelector("input");

input.addEventListener("input", (e) => {
  if (!e.target.checkValidity()) {
    e.target.setCustomValidity(
      "You must use a company email address that ends in @sampleCompany.com"
    );
  }
});
```

This method accepts a custom error message, which is displayed to the user. As a result, you will see the custom error message `You must use a company email address that ends in @sampleCompany.com`.

If you are interested in exploring more about the different types of validity states and why a particular validation has failed, you can log out the `validity` property like this:

```js
const input = document.querySelector("input");

input.addEventListener("input", (e) => {
  console.log(e.target.validity);
})
```

The `validity` property is an instance of the `ValidityState` object. Here is an example of what the object might look like in the browser:

```javascript
ValidityState {
  badInput: false,
  customError: false,
  patternMismatch: true,
  rangeOverflow: false,
  rangeUnderflow: false,
  stepMismatch: false,
  tooLong: false,
  tooShort: false,
  typeMismatch: true,
  valueMissing: false,
  valid: true
}
```

There are several helpful properties which all hold the value of a boolean of `true` or `false`.

Some of these helpful properties that you can explore more on your own would be the `valueMissing` property which is `true` when a required input field is left empty. Or the `patternMismatch` which is `true` if the value doesn't match the specified regular expression pattern.

After this lecture, I encourage you to play around with the examples given in this lecture and explore more about the different validity properties.


## What Is the Purpose of e.preventDefault?

### Description

Let's learn about the purpose of the `preventDefault()` method on events.

Every event that triggers in the DOM has some sort of default behavior. The `click` event on a checkbox toggles the state of that checkbox, by default. Pressing the space bar on a focused button activates the button. The `preventDefault()` method on these event objects stops that behavior from happening.

Let's take a look at an example. Let's define an `input` element for a user to type in:

```html
<label>Enter some characters:
  <input type="text">
</label>
```

And if we look at the result, we can type in the input field as expected. But maybe we don't want that. Maybe, instead, we'd like to show the character the user types in a separate element. First, let's define our element for that:

```html
<label>Enter some characters:
  <input type="text">
</label>
<p id="output"></p>
```

And then, we need to hook into the `keydown` event to listen for a character being typed on the keyboard. Note that we do not want the `change` or `input` events here, because we need the keyboard information.

```javascript
const input = document.querySelector("input");

input.addEventListener("keydown", (e) => {
    
})
```

The `keydown` event fires when you press down on a keyboard key. When this happens, let's display the character in our `p` element.

```javascript
const input = document.querySelector("input");
const output = document.getElementById("output");

input.addEventListener("keydown", (e) => {
  output.innerText = `You pressed the ${e.key} key`;
});
```

`e.key` gives you the value of the key pressed, such as `a` for the `a` key or `Enter` for the `Enter` key.

With the above code, when you type in the `input`, the character you type will be displayed in the `p` element. 

This is great, but we don't want to show the characters in the `input` as well. This is where our `preventDefault()` method comes in. The default behavior of a `keydown` is to render the character in the input. Let's avoid that by calling `e.preventDefault()`:

```javascript
const input = document.querySelector("input");
const output = document.getElementById("output");

input.addEventListener("keydown", (e) => {
  e.preventDefault();
  output.innerText = `You pressed the ${e.key} key`;
});
```

And just like that, you have prevented the default behavior to allow yourself to implement your own custom event handling.

Another common example of when to use the `e.preventDefault` method has to deal with form submissions. By default, submitting a form sends data to the server and reloads the page. Using `e.preventDefault()` prevents this from happening.

```js
const form = document.querySelector("form");

form.addEventListener("submit", (e) => {
  e.preventDefault();
  // rest of code goes here
});
```

Preventing the default behavior is great when you need more control over how a user interacts with the page, but it's important to keep things like accessibility in mind – your custom behavior should provide the same features as the default.


## How Does the Submit Event Work with Forms?

### Description

Let's learn about how the `submit` event works with HTML forms. First, we need to understand how to submit a form. There are three ways a form can be submitted.

The first is when the user clicks a button in the form which has the `type` attribute set to `submit`.

The second is when the user presses the Enter key on any editable input field in the form.

The third is through a JavaScript call to the `requestSubmit()` or `submit()` methods of the form element.

But what happens when a form is submitted? There's a few things that happen, and the behavior of the form depends on its attributes.

The first attribute that we need to look at is the `action` attribute. The `action` attribute should contain either a URL or a relative path for the current domain. This value determines where the form attempts to send data. If you do not set an `action` attribute, the form will send data to the current page's URL. Here is an example of a form with an `action` attribute set to a specific URL:

```html
<form action="https://freecodecamp.org">
  <input type="number" id="input" placeholder="Enter a number" name="number" />
  <button type="submit">Submit</button>
</form>
```

When this form is submitted, it will send data to freeCodeCamp's homepage, which probably won't do anything.

Here's another form, which submits to a relative path:

```html
<form action="/data">
  <input type="number" id="input" placeholder="Enter a number" name="number" />
  <button type="submit">Submit</button>
</form>
```

This one submits to the `/data` path on the current domain. In our case, it would submit to `http://127.0.0.1:5500/data`.

The second attribute to control how a submission behaves is the `method` attribute. This attribute accepts a standard HTTP method, such as `GET` or `POST`, and uses that method when making the request to the `action` URL.

HTTP stands for Hypertext Transfer Protocol and it is used to transfer data over the web.

HTTP methods are used to define the actions that can be performed on resources, such as `GET`, `POST`, `PUT`, `DELETE`, and so on. You will more about these methods in future lectures.

When a method is not set, the form will default to a `GET` request. A `GET` request is used to retrieve data from a specified resource without making any changes to it, and the parameters are typically appended to the URL in the form of a query string.

The data in the form will be URL encoded as `name=value` pairs and appended to the `action` URL as query parameters. For instance, by submitting the form from our previous example with the value of `3342` for the `input` field, the form would try to `GET` the URL `http://127.0.0.1:5500/data?number=3342`.

This is great for something like a search form, where your user is querying data. But if you want your user to submit new data, such as in a registration form, the idiomatic method to use would be the `POST` method. The `POST` method is used to send data to the server to create or update a resource.

Let's set the `method` attribute to the value of `POST`:

```xml
<form action="/data" method="POST">
  <input type="number" id="input" placeholder="Enter a number" name="number" />
  <button type="submit">Submit</button>
</form>
```

When you send a `POST` request, a body can be included which contains the data for your request. So unlike a `GET`, the data are not appended to the URL, and our form sends the `POST` request to `http://127.0.0.1:5500/data`. The data, instead, can be found in the body of the request, still as URL-encoded form data.

URL-encoded form data is when form data is converted into a string of key-value pairs, like `name=John+Doe&email=john%40example.com`, where special characters are replaced with encoded versions to safely send the data over the web. You will learn more about this in future lectures.

But maybe you don't want to send the data as a URL-encoded form payload?

The `form` element accepts an `enctype` attribute, which represents the encoding type to use for the data.

This attribute only accepts three values: `application/x-www-form-urlencoded` (which is the default, sending the data as a URL-encoded form body), `text/plain` (which sends the data in plaintext form, in `name=value` pairs separated by new lines), or `multipart/form-data`, which is specifically for handling forms with a file upload.

In this lecture, you've learned the basics of form submissions. In future lectures, we'll dive deeper into working with forms and how they interact with the server.


## Module: Javascript Dates


### Lecture Block: Lecture Working With Dates


## How Does the JavaScript Date Object Work, and What Are Some Common Methods?

### Description

Dates and times in JavaScript have not always been easy to work with. In a professional codebase, you will probably be using a library that has solved a lot of those issues for you.

But there will be times where you will need to work JavaScript's built-in `Date` object.

In this lecture, we will go over the basics of the `Date` object and some of the most common methods that you will use when working with dates and times in JavaScript.

The `Date` object is a built-in object in JavaScript that allows you to work with dates and times. Here is the basic syntax for creating a new `Date` object:

```js
const now = new Date();
```

The `new` keyword is used to create a new instance of the `Date` object, and the `Date` object is then assigned to the variable `now`. If you were to log the value of `now` to the console, you would see the current date and time based on the system clock of the computer running the code.

Here is an example response you would see if you logged the value of `now` to the console:

```js
const now = new Date();
console.log(now);
// Mon Mar 15 2021 14:30:00 GMT-0700 (Pacific Daylight Time)
```

For the time, it is using the military time format, so `14:30` is `2:30 PM`. `GMT-0700` is the timezone offset, and `Pacific Daylight Time` is the timezone name.

You can also pass in a specific date and time to the `Date` object by providing the year, month, day, hour, minute, second, and millisecond values as arguments.

Here is an example of creating a new `Date` object with a specific date and time:

```js
const specificDate = new Date("July 4, 1776 12:00:00");

console.log(specificDate);
// Wed Jul 04 1776 12:00:00 GMT-0700 (Pacific Daylight Time)
```

This is useful when you need to work with a specific date and time rather than the current date and time. The input always needs to be a string, and the format should be recognizable by the `Date` object.

To get the current date and time, you can use the `Date.now()` method, which returns the number of milliseconds since `January 1, 1970, 00:00:00 UTC`. This is known as the Unix epoch time.

Unix epoch time is a common way to represent dates and times in computer systems because it is an integer that can be easily stored and manipulated. UTC stands for Universal Time Coordinated, which is the primary time standard by which the world regulates clocks and time.

If you need to get a day of the month based on the current date, you can use the `getDate` method. Here is an example of using the `getDate` method:

```js
const now = new Date();
const date = now.getDate();
console.log(date); // 15
```

In this example, we create a new date instance using the `Date` object and assign it to the variable `now`. We then call the `getDate` method on the `now` object to get the day of the month and assign it to the variable `date`. Finally, we log the value of `date` to the console, which will output the current day of the month.

`getDate` will return an integer value between `1` and `31`, depending on the day of the month. If the date is invalid, it will return `NaN` (Not a Number).

To get the month, you can use the `getMonth` method like this:

```js
const now = new Date();
const month = now.getMonth();
console.log(month);
// 2
```

The month is zero-based, so `January` is `0`, `February` is `1`, and so on. In this example, the output is `2`, which corresponds to `March`. If the month is invalid, it will return `NaN`.

If you need to get the full year, then you can use the `getFullYear` method like this:

```js
const now = new Date();
const year = now.getFullYear();
console.log(year);
// Output: 2024
```

In this example, the output is `2024`, which is the current year. If the year is invalid, it will return `NaN`.

There are many more methods available on the `Date` object including `getHours`, `getMinutes`, `getSeconds`, and so on. I encourage you to explore some more on your own through Mozilla's documentation or other resources.


## What Are the Different Ways to Format Dates?

### Description

In the previous lecture, you learned how to work with the `Date` object in JavaScript. But there are a few different ways to format dates in JavaScript.

In this lecture, we'll take a look at how to work with the `toISOString()`, `toString()`, and `toLocaleDateString()` methods to format dates in JavaScript.

Before we look at the different methods, let's first review what the `Date` object looks like:

```js
const date = new Date();
console.log(date);
```

When you log the `date` object to the console, you will see the current date and time based on the user's system settings. Here is an example of the output you might see:

```js
Sun Sep 29 2024 19:45:37 GMT-0700 (Pacific Daylight Time)
```

If you were to use the `toString()` method on the `date` object, you would see the same output as above.

To format the date in an extended ISO format (ISO 8601), you can use the `toISOString()` method like this:

```js
const date = new Date();
console.log(date.toISOString());
```

ISO 8601 is an international standard for representing dates and times. The format is `YYYY-MM-DDTHH:mm:ss.sssZ`.

The following example will log the current date and time in the ISO 8601 format like this:

```js
2024-09-30T02:47:20.292Z
```

Another way to format the date, would be to use the `toLocaleDateString()` method. This method allows you to format the date based on the user's locale. Here is the basic syntax for using the `toLocaleDateString()` method:

```js
const date = new Date();
console.log(date.toLocaleDateString());
```

The example output would show the user's locale date format like this:

```js
9/29/2024
```

The `toLocaleDateString()` method accepts two optional parameters: `locales` and `options`.

The `locales` parameter is a string representing the locale to use. For example, you can pass in `en-US` for English (United States) or `fr-FR` for French (France). If you don't pass in a `locales` parameter, the default locale is used. Here is an example of how to use the `locales` parameter:

```js
const date = new Date();
console.log(date.toLocaleDateString("fr-FR"));
```

The second optional parameter is the `options` parameter. This parameter is an object that allows you to specify the format of the date string. Here is an example of how to use the `options` parameter:

```js
const date = new Date();
const options = {
  weekday: "long",
  year: "numeric",
  month: "long",
  day: "numeric",
};
console.log(date.toLocaleDateString("en-GB", options));
```

In the above example, we specified the options to be in English (Great Britain) and to include the full weekday, year, month, and day. Here is an example of what the output would look like:

```js
Sunday, September 29, 2024
```

In this lecture, we have only covered a few of the ways to format dates in JavaScript. There are many other methods and libraries available to help you format dates in JavaScript. But the `toISOString()`, and `toLocaleDateString()` methods are a good starting point for formatting dates in JavaScript.


## Module: Audio And Video Events


### Lecture Block: Lecture Working With Audio And Video


## How Does the Audio Constructor Work, and What Are Some Common Methods?

### Description

Let's learn about the `Audio` constructor and its common methods.

The `Audio` constructor, like other constructors, is a special function called with the `new` keyword. It returns an `HTMLAudioElement`, which you can then use to play audio for the user, or append to the DOM for the user to control themselves.

When you call the constructor, you can optionally pass a URL as the (only) argument. This URL should point to the source of the audio file you want to play. Or, if you need to change the source dynamically, you can assign the URL to the `src` property of the returned audio element.

The returned audio element offers various methods for controlling the audio. You'll most likely use the `play()` method, which begins audio playback. There is also the `pause()` method, which pauses the audio playback but preserves the current location in the track allowing `play()` to resume playback from that point.

You might expect there to be a `stop()` method, to pause audio playback and reset the track to the beginning. But instead, you should call `pause()` and set the `currentTime` property directly.

Finally, the `canPlayType()` method can be used to determine if a browser is likely to be able to play your specific audio format. You will learn about audio and video formats in the next lecture.


## What Are the Different Types of Video and Audio Formats?

### Description

Let's learn about the different types of audio and video formats.

You have probably heard of, or even used, a few common ones. If the terms MP3, MP4, MOV, or WebM are familiar to you, those are all different formats for video and audio. And there are quite a few more that are available.

Before we dive in to file formats, we need to talk about MIME types. A MIME type, standing for Multipurpose Internet Mail Extensions, is a standardized way to programmatically indicate a file type.

Nearly every file format has a MIME type. HTML, for example, has the type `text/html`. A JSON object has the type `application/json`. Even a Windows `.exe` installer has a MIME type: `application/vnd.microsoft.portable-executable`.

The MIME type can tell an application, such as your browser, how to handle a specific file. In the case of audio and video, the MIME type indicates it is a multimedia format that can be embedded in the web page.

An MP3 file has the MIME type `audio/mp3`. An MP4, however, can have the MIME type `audio/mp4` OR `video/mp4`, depending on whether it's a video file or audio-only. This distinction tells the browser how to handle the file.

There are plenty of other file formats, such as the waveform format WAV, the multipurpose OGG, WMV for the Windows media player, the open source MKV, and many more.

Knowing the differences between these file formats can help you ensure your users get the best experience, but sometimes you can't know what format a user's computer will support (or not support). Thankfully, `video` and `audio` elements both support the `source` element.

With the `source` element, you can specify a file type and `source` and can include multiple different types by using multiple `source` elements. When you do this, the browser will determine the best format to use for the user's current environment.

This takes away the guess work and allows you to focus on building engaging applications.


## What Is Codecs and How Does It Work?

### Description

Let's learn about codecs and how they work.

If you have worked with videos or audio before, you may have heard about codecs. A codec, short for "encoder/decoder", is an algorithm or software that can convert audio and video between analogue and digital formats.

Codecs can be specified as part of the MIME type. The basic syntax to define a codec is to add a semi-colon after the media type, then `codecs=` and the codec.

For example, an OGG audio file which uses the Vorbis codec might have a MIME type of `audio/ogg; codecs=vorbis`. Or, if a file supports multiple codecs, you can specify them as comma separated, but must surround them with quotes: `video/webm; codecs="vp8, vorbis"`.

But some file types have a much more complicated syntax for codecs. For example, an MP4 might have a codec of `codecs="avc1.4d002a"`, indicating it was encoded with H.264.

But when might you actually use these? Well, you can include them in the `type` attribute for a `source` element. This allows you to specify different codecs for the same format, giving the browser more granular options when determining which format to use for that user's environment.

But you can also use them as part of the MIME type you pass to the global `MediaSource.isTypeSupported()` method. This method accepts a MIME-type, and returns `true` if the environment is likely to support it. Or rather, it returns `false` if it fails to instantiate a buffer for that file type. This approach allows you to programmatically select a source yourself, rather than relying on whatever the browser determines is "best".


## What Is the HTMLMediaElement API and How Does It Work?

### Description

The `HTMLMediaElement` API is a powerful tool to control the behavior of audio and video elements on your page. It extends the base `HTMLElement` interface, so you have access to the base properties as well as these helpful methods.

You've already explored some of the methods in a previous lecture about the `Audio` element, such as `play()` and `pause()`. These same methods are available on video elements as well.

There are some other helpful methods, such as the `addTextTrack()` method. This method allows you to specify a text track to associate with the media element which is especially helpful for adding subtitles to a video.

Or the `fastSeek()` method, which allows you to move the playback position to a specific time within the media.

The `HTMLMediaElement` API also provides access to some new events that a standard element does not have.

The `play` and `pause` events are fired when the media starts and stops playing. The `ended` event fires when the end of the media has been reached.

The `waiting` event fires when playback is automatically paused due to data buffering.

And the `canplay` and `canplaythrough` events fire when the media can be partially played, or played in totality.

The `HTMLMediaElement` offers a great deal of control over your interactive media, and we've only scratched the surface. I encourage you to explore and experiment with the API to find the best ways to integrate it with your applications.


## How Can You Work with the Media Streams to Capture Video and Audio from a Local Device?

### Description

Instead of playing audio and video, you may sometimes want to capture audio or video. The Media Capture and Streams API, or the MediaStream API, allows you to do this.

In order to use the API, however, you need to create the `MediaStream` object. You could do this with the constructor, but it would not be tied to the user's hardware. Instead, the `mediaDevices` property of the global `navigator` object has a `getUserMedia()` method for you to use.

This method accepts a single `constraints` object which defines the type of media you want to receive. This object has an `audio` and `video` property, reflecting audio and video streams. These properties can be `false`, if you do not want to receive that type of stream, `true` if you do, or objects defining additional constraints.

For example, you can require a specific resolution of video output:

```js
window.navigator.mediaDevices.getUserMedia({
  audio: true,
  video: {
    width: {
      min: 1280,
      ideal: 1920,
      max: 3840
    },
    height: {
      min: 720,
      ideal: 1080,
      max: 2160
    }
  }
});
```

This constraint object specifies minimum and maximum resolutions for the video feed. The `ideal` property specifies the resolution you'd most like to have – and the stream will provide the resolution closest to your ideal.

Once you've created your MediaStream (assuming the user approves the automated request to access their hardware), you can use the stream data however you need.

Note that `getUserMedia()` returns a Promise, which means you will either need a callback function to consume the stream, or use async/await syntax. You will learn more about Promises and asynchronous programming in future lectures. 

Here's a basic example which renders the user's webcam feed to the page.

```js
const video = document.querySelector("video");
const stream =
  await window.navigator.mediaDevices.getUserMedia({ video: true });
video.srcObject = stream;
await video.play();
```

It is worth noting that this API does not offer access to screen capture. You'll learn about that API in the next lecture.


## What Are Some Other Examples of Video and Audio APIs?

### Description

You've learned about the `HTMLMediaElement` and MediaStreams APIs, but there are a few more APIs that can be quite helpful in working with video and audio.

The first is the Screen Capture API. As the name might suggest, this API allows you to record a user's screen. This API is exposed by calling the `getDisplayMedia()` method of the `mediaDevices` object and consuming the returned media stream.

Then there is the MediaStream Recording API. This API works in tandem with the MediaStreams APIs, allowing you to record a MediaStream (or even an `HTMLMediaElement` directly). It then fires `dataavailable` events with Blob payloads you can write to the local file storage.

Underlying all of this technology is the Media Source Extensions API. The Media Source Extensions API is what allows you to directly pass a user's webcam feed to a video element with the `srcObject` property, for example. 

And finally, the Web Audio API which powers everything audible on the web. This API includes important objects like an `AudioBuffer` (representing a Buffer specifically containing audio data) or the `AudioContext`. 

And that wraps up our lectures on audio and video!


## Module: Maps And Sets


### Lecture Block: Lecture Working With Maps And Sets


## What Are Sets in JavaScript, and How Does It Differ from WeakSets?

### Description

In JavaScript, `Set` is a built-in object for managing data collections. It lets you store unique values of any type, whether primitive or object references. `Set` ensures that each value in it appears only once, making it useful for eliminating duplicates from an array or handling collections of distinct values.

As for `WeakSet`, it’s a special type of `Set` with fewer features that allows you to store weakly held object references and symbols. Unlike `Set`, `WeakSet` does not support primitives like numbers or strings.

Unlike a regular `Set`, a `WeakSet` only stores objects, and the references to those objects are "weak" meaning WeakSets do not prevent the stored objects from being garbage-collected if there are no other references to them. In simpler terms, if the object is not being used anywhere else in your code, it is removed automatically to free up memory.

To create a `Set`, you use the `Set` constructor and assign it to a variable:

```js
const myFirstSet = new Set();
```

You can also initialize the `Set` with values:

```js
const treeSet = new Set(['Baobab', 'Jackalberry', 'Mopane Tree', 'Breadfruit']);
```

If you log the `Set` to the console, this is what the output looks like:

```js
/*
Set(4) {'Baobab', 'Jackalberry', 'Mopane Tree', 'Breadfruit'}
  [[Entries]]
  0: "Baobab"
    value: "Baobab"
  1: "Jackalberry"
    value: "Jackalberry"
  2: "Mopane Tree"
    value: "Mopane Tree"
  3: "Breadfruit"
    value: "Breadfruit"
  size: 4
  [[Prototype]]: Set
*/
```

If you didn't initialize the `Set` with values, you can use the `add()` method to add an item to the `Set`:

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');
```

The result and appearance of the result in the console remains the same.

Don't forget that duplicate items will be ignored in the `Set`:

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');
treeSet.add('Baobab'); //duplicate item will be ignored

console.log(treeSet);
// Set(4) {'Baobab', 'Jackalberry', 'Mopane Tree', 'Breadfruit'}
```

The other methods you can use to manipulate a `Set` are:

- `delete()`  
- `clear()`
- `has()`
- `entries()`
- `forEach()`
- `keys()`
- `values()`

Let's look at how these methods work one by one. `delete()` removes a specified item from the `Set`:

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

console.log(treeSet); // Set(3) {'Baobab', 'Jackalberry', 'Mopane Tree'}
```

`has()` checks if a specified value exists in the `Set`:

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

console.log(treeSet.has('Breadfruit')); // false
```

`entries()` returns a `Set` iterator containing an array of the values in a `[value, value]` format:

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

console.log(treeSet.entries());
// SetIterator {'Baobab' => 'Baobab', 'Jackalberry' => 'Jackalberry', 'Mopane Tree' => 'Mopane Tree'}
```

`keys()` and `values()` show the values in the `Set`. `keys()` is just an alias for the `values()` method:

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

console.log('Keys: ', treeSet.keys());
console.log('Values: ', treeSet.values());
// Keys: SetIterator {'Baobab', 'Jackalberry', 'Mopane Tree'}
// Values: SetIterator {'Baobab', 'Jackalberry', 'Mopane Tree'}
```

`forEach()` lets you iterate through the `Set`:

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

treeSet.forEach((tree) => console.log(tree));
/*
Baobab
Jackalberry
Mopane Tree
*/
```

`clear()` removes all the items of the array:

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

treeSet.clear();

console.log(treeSet); // Set(0) {size: 0}
```

It is also worth mentioning that there's a `size` property that returns the number of items in the `Set`:

```js
const treeSet = new Set();

// Add items to the treeSet
treeSet.add('Baobab');
treeSet.add('Jackalberry');
treeSet.add('Mopane Tree');
treeSet.add('Breadfruit');

treeSet.delete('Breadfruit');

console.log(treeSet.size); // 3
```

Just like `Set`, there's also a `WeakSet` constructor you can use to create a `WeakSet`:

```javascript
const treeWeakSet = new WeakSet();
```

`WeakSet` also has the `add()`, `delete()`, and the `has()` methods:

```javascript
const treeWeakSet = new WeakSet();

treeWeakSet.add({ name: 'Baobab' });
treeWeakSet.add({ name: 'Jackalberry' });
treeWeakSet.add({ name: 'Mopane Tree' });
treeWeakSet.add({ name: 'Breadfruit' });

treeWeakSet.delete('Jackalberry');
console.log(treeWeakSet.has('Jackalberry')); // false

console.log(treeWeakSet);
```

In the output, the contents of the `WeakSet` appear like this:

```javascript
/*
WeakSet {{…}, {…}, {…}, {…}}
  [[Entries]]
    No properties
  [[Prototype]]: WeakSet
    .
    .
    .
*/
```

The contents appear empty because WeakSets are not iterable and do not expose their contents directly.

Don't forget that only symbols and objects with well-defined keys and values are supported. Adding a primitive, such as numbers or strings, will result in an error:

```js
treeWeakSet.add('Alan Smith');

console.log(treeWeakSet); // Invalid value used in weak set
//    at WeakSet.add (<anonymous>)
```

The key difference between a `Set` and a `WeakSet` is that a `Set` stores any value, while a `WeakSet` can only store objects.

Here are some other noticeable differences between a `Set` and a `WeakSet`:

| Feature | Set | WeakSet |
| --- | --- | --- |
| Type of Values Stored | Stores any data type | Stores only objects |
| Referencing | Strong referencing | Weak referencing |
| Iteration | Supports iteration with `forEach` and loops | Does not support iteration |
| Methods and Properties | `add()`, `delete()`, `has()`, `keys()`, `values()`, `size`, and more | `add()`, `delete()`, and `has()` only |
| Use case | General-purpose collection of unique values and removing duplicates from arrays | Efficient memory tracking of object references |

You can see the differences in the types of values that the two kinds of sets can store, their support for iterating over the stored objects and their ideal use cases. Please take a moment to read the content of this table.


## What Is the Map Object, and How Does It Differ from WeakMaps?

### Description

In JavaScript, a `Map` is a built-in object that stores key-value pairs, similar to an object. However, it differs from standard JavaScript objects by allowing keys of any type, including objects and functions.

A `WeakMap` is a collection of key-value pairs, similar to a `Map`, but it uses weak references for its keys. The keys must be objects, while the values can be of any type.

Think of the relationship between a `WeakMap` and a `Map` as similar to the relationship between a `WeakSet` and a `Set`, as you learned in the previous lecture.

To create a `Map`, you use the `Map()` constructor prepended with the `new` keyword:

```js
const myFirstMap = new Map();
```

You can initialize the Map with values:

```js
const myTreesMap = new Map([
 [{ type: 'deciduous' }, 'Maple tree'],
 [['forest', 'grove'], 'Pine tree'],
 [42, 'Oak tree'],
 [true, 'Birch tree'],
 [function() { return 'I am a function key'; }, 'Willow tree'],
]);
```

If you didn't initialize the `Map` with values, you can use the `set()` method to add them:

```js
const myTreesMap = new Map();
myTreesMap.set({ type: 'deciduous' }, 'Maple tree');
myTreesMap.set([1, 2], 'Pine tree');
myTreesMap.set(42, 'Oak tree');
myTreesMap.set(true, 'Birch tree');
myTreesMap.set(function() { return "I'm a function key"; }, 'Willow tree');

console.log(myTreesMap);
```

Here's what a `Map` looks like in the console:

```js
/*
Map(5) {{…} => 'Maple tree', Array(2) => 'Pine tree', 42 => 'Oak tree', true => 'Birch tree', ƒ => 'Willow tree'}
  [[Entries]]
    0:{Object => "Maple tree"}
      key: {type: 'deciduous'}
      value: "Maple tree"
    1:{Array(2) => "Pine tree"}
      key: (2)
      value: "Pine tree"
    2:{42 => "Oak tree"}
      key: 42
      value: "Oak tree"
    3:{true => "Birch tree"}
      key: true
      value: "Birch tree"
    4:{function () { return "I'm a function key"; } => "Willow tree"}
      key: f ()
      value: "Willow tree"
    size: 5
    [[Prototype]]: Map
*/
```

Other methods you can use to work with a `Map` are:

- `get(key)` to retrieve the value associated with the specified `key`.
- `has(key)` to check if a `key` exists in the `Map`.
- `delete(key)` to remove a key-value pair from the `Map`.
- `clear()` to remove all key-value pairs.
- `entries()` to check the entries of the `Map` (it returns the entries in a `MapIterator`).
- `forEach()` to loop through the entries of the `Map`.
- `size` to indicate the number of key-value pairs in the `Map`.
    

There's a `WeakMap()` constructor you can use to create a `WeakMap`:

```js
const myFirstWeakMap = new WeakMap();
```

The `set()`, `get()`, `has()`, and `delete()` methods are all available for use with a `WeakMap` as well. For example here's how you can assign items to the `Map` with the `set()` method:

```js
const myTreeWeakMap = new WeakMap();

myTreeWeakMap.set({ id: 1 }, 'Maple tree');
myTreeWeakMap.set({ id: 2 }, 'Pine tree');
myTreeWeakMap.set({ id: 3 }, 'Oak tree');
myTreeWeakMap.set({ id: 4 }, 'Birch tree');
myTreeWeakMap.set({ id: 5 }, 'Willow tree');

console.log(myTreeWeakMap);
```

Here's what a `WeakMap` looks like in the console:

```js
/*
WeakMap {{…} => 'Willow tree', {…} => 'Maple tree', {…} => 'Pine tree', {…} => 'Oak tree'}
  [[Entries]]
    No properties
  [[Prototype]]: WeakMap
*/
```

Here are the differences between a `Map` and a `WeakMap`:

| **Feature** | **Map** | **WeakMap** |
| --- | --- | --- |
| **Key Type** | Keys can be of any data type, including strings, numbers, objects, or even functions. | Keys must be objects. |
| **Use Case** | Use a `Map` when you need to associate data with any type of key. | Use a `WeakMap` when you only need to associate data with objects. |
| **Iteration** | You can loop through a `Map` using `forEach()`, `keys()`, `values()`, or `entries()`. | A `WeakMap` is not iterable. |
| **Size Property** | `Map` has a `size` property to get the number of key-value pairs. | `WeakMap` does not have a `size` property. |

In the table above, you can see the differences summarized including the key type, use case, iteration and size property. Please take a moment to read the content of this table to learn more about their differences.


## Module: Localstorage And Crud Operations


### Lecture Block: Lecture Working With Client Side Storage And Crud Operations


## What Does CRUD Stand For, and How Do the Basic Operations Work?

### Description

CRUD is an acronym that stands for Create, Read, Update, and Delete. These are the four operations of persistent storage.

Persistent storage refers to saving data in a way that makes it available even after the power is turned off or the device is restarted.

Understanding how the basic operation of CRUD works is crucial to web development because it forms the foundation for working with databases and building applications where users can add, view, modify, and delete data. 

Now, let’s take a look at each part of CRUD more closely

- Create refers to the process of creating new data. For example, in a web app, this could be when a user adds a new post to a blog.

- Read is the operation where data is retrieved from a database. For instance, when you visit a blog post or view your profile on a website, you’re performing a read operation to fetch and display data stored in the database.

- Update involves modifying existing data in the database. An example would be editing a blog post or updating your profile information.

- Delete is the operation that removes data from a database. For instance, when you delete a blog post or account, you’re performing a delete operation.

CRUD is used when working with databases, the UI, and RESTful APIs. RESTful APIs are a set of conventions for building web services that allow the client to interact with a database or backend system by performing CRUD operations through standard HTTP methods.

HTTP stands for Hypertext Transfer Protocol and it is the foundation for data communication on the web. There are HTTP methods which define the actions that can be performed on resources over the web. The common methods are `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.

You will learn more about RESTful APIs and HTTP in future lectures, but here is a quick break down of how CRUD maps to the different HTTP methods.

- `POST` is used to create a new resource.

- `GET` is used to retrieve or read data.

- `PUT` is used to update a resource by replacing it entirely.

- `PATCH` is used to partially update a resource.

- `DELETE` is used to remove a resource.

Here’s an example of how CRUD operations might be represented in code using a simple array in JavaScript:

```js
let items = [];

// Create
function createItem(item) {
  items.push(item);
}

// Read
function readItems() {
  return items;
}

// Update
function updateItem(index, newItem) {
  items[index] = newItem;
}

// Delete
function deleteItem(index) {
  items.splice(index, 1);
}

// Example Usage
createItem('Book');
console.log(readItems()); // ['Book']
updateItem(0, 'Magazine');
console.log(readItems()); // ['Magazine']
deleteItem(0);
console.log(readItems()); // []
```

In this example:

- We create an item by pushing it into an array.

- We read the items by returning the array.

- We update an item by modifying the array element at a given index.

- We delete an item by removing it from the array using `splice()`.

This is a basic representation of how CRUD operations work at a conceptual level.


## What Is localStorage, and What Are Some Common Methods?

### Description

The Web Storage API provides a mechanism for browsers to store key-value pairs right within the browser, allowing developers to store information that can be used across different page reloads and sessions. 

The two main components in the Web Storage API are `localStorage` and `sessionStorage`.

`localStorage` is the part of the Web Storage API that allows data to persist even after the browser window is closed or the page is refreshed. This data remains available until it is explicitly removed by the application or the user. 

`sessionStorage` is another part of the Web Storage API that stores data for the duration of the page session, meaning the data is available as long as the browser tab or window is open. However, unlike `localStorage`, the data in `sessionStorage` is cleared when the tab or window is closed. You will learn more about `sessionStorage` in the next lecture. 

Common use cases for `localStorage` include storing user settings, such as themes or language preferences, remembering form data across browser sessions, and caching small pieces of information to improve the performance of web apps.

Caching refers to storing frequently accessed data in a temporary storage location, known as a cache, so that subsequent requests for that data can be served more quickly without having to recompute or fetch it from a slower data source, such as a database or external server.

Some common `localStorage` methods include the `setItem`, `getItem`, `removeItem` and `clear` methods. 

Here is an example of using the `setItem()` method which stores a key-value pair in `localStorage`.

```js
localStorage.setItem('username', 'JaneDoe');
```

Then if we want retrieve that value of a given key from `localStorage`, we can use the `getItem()` method.

```js
let username = localStorage.getItem('username');
console.log(username); // JaneDoe
```

To remove an item from `localStorage` using its key, you can use the `removeItem()` method.

```js
localStorage.removeItem('username');
```

To clear all data in `localStorage`, you can use the `clear()` method.

```js
localStorage.clear();
```

Now, let’s take a look at an example where we use `localStorage` to store the preferred theme of a user.

```js
// Store the user's theme preference
localStorage.setItem('theme', 'dark');

// Retrieve the stored theme preference
const userTheme = localStorage.getItem('theme');
console.log(userTheme); // 'dark'

// Remove the theme preference
localStorage.removeItem('theme');

// Clear all localStorage data
localStorage.clear();
```

In this example:

- We first store a theme choice (`dark`) for the user.

- We then retrieve that theme and output it to the console.

- Finally, we demonstrate how to remove a specific item or clear all stored data.

`localStorage` is very useful for storing small pieces of data that need to persist between sessions, but it's important to note that `localStorage` should not be used to store sensitive information, such as passwords, because it can pose security risks.


## What Is sessionStorage, and What Are Some Common Methods?

### Description

In the previous lecture, we learned about working with `localStorage` and were briefly introduced to `sessionStorage`.

Recall, that `sessionStorage` is when the data is cleared as soon as the user closes the tab or window in which the web application is running. It’s ideal for situations where data only needs to persist for the length of a single session, such as maintaining form data during navigation or storing temporary state information during a checkout process.

Much like `localStorage`, `sessionStorage` uses key-value pairs to store and retrieve data. The methods used with `sessionStorage` are also the same as `localStorage`, with the only real difference being how long the data is stored. 

Here are a few examples of working with the different methods:

- `sessionStorage.setItem()`: Stores a key-value pair in `sessionStorage`.

```js
sessionStorage.setItem('cart', '3 items');
```

- `sessionStorage.getItem()`: Retrieves the value of a given key from `sessionStorage`.

```js
let cart = sessionStorage.getItem('cart');
console.log(cart); // Outputs: '3 items'
```

- `sessionStorage.removeItem()`: Removes a specific item from `sessionStorage` using its key.

```js
sessionStorage.removeItem('cart');
```

- `sessionStorage.clear()`: Clears all data stored in `sessionStorage`.

```js
sessionStorage.clear();
```

Let’s look at an example where we store data in `sessionStorage` which only lasts as long as the browser tab or window is open:

```js
// Store data in sessionStorage
sessionStorage.setItem('currentUser', 'JohnDoe');

// Retrieve the stored data
const user = sessionStorage.getItem('currentUser');
console.log(user); // 'JohnDoe'

// Remove a specific key from sessionStorage
sessionStorage.removeItem('currentUser');

// Clear all sessionStorage data
sessionStorage.clear();
```

In this example, we:

1. Store the current user’s name (`JohnDoe`) in `sessionStorage`.

2. Retrieve and display it.

3. Remove the item associated with the key `currentUser`.

4. Clear all `sessionStorage` data.

The key difference from `localStorage` is that as soon as the user closes the tab, all stored session data will be lost.

`sessionStorage` is particularly useful in scenarios like:

- Storing temporary data such as form entries during a multi-page form process.

- Storing temporary selections or preferences that don’t need to persist across sessions.

- Maintaining state on a single-page application that doesn’t need to be remembered once the tab is closed.

`sessionStorage` ensures that once the user leaves the page, the session data is cleared, which is great for scenarios where you don’t want to hold onto information beyond the current session.


## What Are Cookies, and How Do They Work?

### Description

Cookies, also known as web cookies or browser cookies, are small pieces of data that a server sends to a user's web browser. These cookies are stored on the user's device and sent back to the server with subsequent requests. 

Cookies are essential in helping web applications maintain state and remember user information, which is especially important since HTTP is a stateless protocol.

Cookies can store a variety of information such as user preferences, session data, or tracking information.

Cookies are always stored as name-value pairs. This means each cookie has a name (key) and an associated value. 

For example, a cookie might store a user's session ID like this: `sessionId=abc123`. The key is `sessionId`, and the value is `abc123`. Each time the browser communicates with the server, the browser sends these cookies in the form of name-value pairs.

When a user visits a website, the server can send one or more cookies to the user's browser by including a Set-Cookie header in the HTTP response. A header is a key-value pair that provides additional information about the HTTP request or response. You will learn more about HTTP requests and responses in future lectures.

Once the cookies are set, the browser stores them and automatically includes them in the Cookie header with every subsequent request to the same domain. This allows the server to access the stored cookies and use them for things like maintaining user sessions or tracking preferences.

Here’s an example of how a cookie is set in an HTTP response:

```http
Set-Cookie: sessionId=abc123; Expires=Wed, 21 Oct 2021 07:28:00 GMT; Secure; HttpOnly
```

The browser will store the cookie, and in future requests to the same server, it will include the cookie in the `Cookie` header:

```http
Cookie: sessionId=abc123
```

The server can then read the cookie and use the stored session ID to retrieve information about the user, such as whether they are logged in.

Here is a breakdown of the different types of cookies.

- Session Cookies only last for the duration of the user's session on the website. Once the user closes the browser or tab, the session cookie is deleted. These cookies are typically used for tasks like keeping a user logged in during their visit.

- Persistent Cookies have an expiration date and remain stored on the user's device until that date is reached. Persistent cookies are often used for remembering user preferences or login details across sessions.

- Secure Cookies are only sent over HTTPS, ensuring that they cannot be intercepted by an attacker in transit.

- HttpOnly Cookies cannot be accessed or modified by JavaScript running in the browser, making them more secure against cross-site scripting (XSS) attacks. Cross-site scripting (XSS) attacks happen when an attacker injects malicious scripts into a web page that is viewed by other users. These scripts can then execute in the context of the victim's browser, potentially stealing cookies, session data, or performing other malicious actions without the user's knowledge or consent. By marking cookies as HttpOnly, they are protected from being accessed via JavaScript, reducing the risk of such attacks.

You can create cookies via server responses using the `Set-Cookie` header or through JavaScript using `document.cookie`.

Here's an example of setting a cookie using JavaScript:

```js
document.cookie = "username=JohnDoe; expires=Fri, 31 Dec 2021 23:59:59 GMT; path=/";
```

This command sets a cookie named `username` with the value `"JohnDoe"` that will expire at the end of 2021. You can update an existing cookie by simply setting it again with a new value.

To delete a cookie, you set its expiration date in the past:

```js
document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";
```

This will remove the `username` cookie from the browser.


## What Is the Cache API, and How Does It Work?

### Description

The `Cache` API is used to store network requests and responses, making web applications work more efficiently and even function offline. It is part of the broader Service Worker API and is critical for creating Progressive Web Apps (PWAs) that can work under unreliable or slow network conditions. 

Before we continue with the `Cache` API, we first need to understand how service workers, PWAs, and network requests work on a basic level. 

A network request is a request made by a web browser or application to a server to retrieve data or resources over the internet. For example, when you visit a website, your browser sends a network request to the web server to get the files (such as HTML, images, or videos) needed to display the page.

A service worker is a special type of JavaScript file that runs in the background of a web application, separate from the main browser thread. It acts as a middleman between the web page and the network, allowing developers to intercept network requests, cache resources, and handle things like push notifications or background sync.

A PWA, or Progressive Web App, is a type of web application that uses modern web technologies to provide a native app-like experience on the web. PWAs are designed to work reliably on any device, regardless of network conditions, and can be accessed through a browser or installed on a user's device like a traditional app. 

Now that we have a better understanding of service workers, PWAs, and network requests, we can dive deeper into the Cache API.

The `Cache` API is a storage mechanism that stores `Request` and `Response` objects. When a request is made to a server, the application can store the response and later retrieve it from the cache instead of making a new network request. This reduces load times, saves bandwidth, and improves the overall user experience.

The browser provides a storage area known as `CacheStorage`, where developers can save key-value pairs of network requests and their corresponding responses.

With the `Cache-Control` header, developers can specify how long a cached resource should remain stored, as well as whether it should be revalidated or served directly from the cache. 

By using the `Cache` API, developers can build offline-first web applications, allowing a PWA, for example, to serve cached assets when the user is disconnected from the network.


## What Are Some Negative Patterns Associated with Client-Side Storage?

### Description

Client-side storage allows websites to store data on a user's device. However, like many technologies, it can be misused. 

Let’s explore some negative patterns associated with client-side storage, focusing on cookies and their misuse for tracking and fingerprinting.

Let's start with cookies. 

In an earlier lecture, you learned that cookies are data stored on a user's device when they visit a web app. A common misuse of cookies is excessive tracking.

Websites use cookies to track a user's interactions with a web app, creating a history of their digital activities. This is done for targeted advertising but can raise significant privacy concerns.

For example, a shopping website might use a tracking cookie like this:

```js
document.cookie = "userID=123; path=/; expires=Thu, 18 Dec 2024 6:00:00 UTC";
```

This code sets a cookie named `userID` with a value of `123`. The cookie will be sent with every request to the website, allowing it to track the user's actions. While this might seem harmless, imagine hundreds of websites sharing this information – it could create a very detailed picture of your online life and choices.

Another concerning practice is browser fingerprinting. 

This technique uses client-side information to create a unique "fingerprint" of a user's browser. Websites have the ability to gather information about your browser version, installed plugins, screen resolution, and other data to uniquely identify you. 

Here's a simple example of how a website can create a fingerprint of you:

```js
let fingerprintExample = navigator.userAgent + screen.width + screen.height;
console.log(fingerprintExample);
```

This code combines your browser's user agent with your screen dimensions. While this is a basic example, real fingerprinting methods are much more complex and can be highly accurate in identifying users.

`localStorage` can also be misused as some websites use it to store sensitive information insecurely. For instance:

```js
localStorage.setItem('userPassword', 'someonesPasswordHere');
```

This code stores a user's password in `localStorage`. This is a serious security risk as the data in `localStorage` is not encrypted and can be accessed easily.

In conclusion, while client-side storage offers many benefits, it's crucial to use it responsibly. As you continue your web development journey, always consider the privacy and security of your users' data on the client side.


## How Can You Use Cookies to Store Arbitrary Data, Normally Controlled by HTTP Headers?

### Description

As you learned in previous lectures, cookies are simple data that websites can store on a user's device.

However, you can actually store more complex data structures in cookies. One common method is to use JSON to store objects or arrays. Here's an example:

```js
const userData = {
  name: "John Doe",
  age: 30,
  role: "admin"
};

document.cookie = "userInfo=" + JSON.stringify(userData) + "; path=/";
```

In this example, we're creating an object with user data, converting it to a JSON string, and then storing it in a cookie. When we want to retrieve this data, we can parse the JSON string into an object using `JSON.parse()`.

Now, you might be wondering about the "HTTP headers" aspect of our topic. Typically, cookies are set by the server using HTTP headers.

For example, a server might send a header like this:

```http
Set-Cookie: username=John Doe; expires=Thu, 31 Dec 2024 6:00:00 IST; path=/
```

This header tells the browser to set a cookie. 

We can also set cookies directly in the browser using JavaScript. This is useful for storing data that doesn't need to be sent to the server immediately.

Please note that cookies have a size limit of around 4KB, and storing too much data in them may slow down your web app.

Storing large amounts of data in cookies can increase network traffic as cookies are sent with every HTTP request.


## What Is IndexedDB, and How Does It Work?

### Description

`IndexedDB` is a tool for storing structured data in the browser. This is built into modern web browsers, allowing web apps to store and fetch JavaScript objects efficiently.

Unlike other storage mechanisms like `localStorage`, which is limited to storing strings, `IndexedDB` can store JavaScript objects, files, and pretty much any other type of data. This makes it easy for web applications that need to work with large and complex data structures.

Now, let's look at how `IndexedDB` works. 

The first step is to open a database. Here's an example:

```js
let request = indexedDB.open("Sample DB", 1);

request.onerror = function(event) {
  console.log("Error opening database");
};

request.onsuccess = function(event) {
  let db = event.target.result;
  console.log("Database opened successfully");
};
```

In this code, we're opening a database named `"Sample DB"` with version 1. We provide two callback functions: one for handling errors, and another for when the database is successfully opened. The `db` object we get in the success callback is what we'll use to interact with the database.

If you check the browser dev tools application interface, you will see your `Sample DB` in the `IndexedDb` section has been opened. Once you have your database open, you can start working with object stores.

Object stores in IndexedDB are similar to tables in traditional databases. They hold the actual data you want to store. Here's how to create an object store: 

```js
request.onupgradeneeded = function(event) {
  let db = event.target.result;
  let objectStore = db.createObjectStore("customers", { keyPath: "id" });
};
```

This code creates an object store named `"customers"` with `"id"` as its key path. The key path is like a primary key in a traditional database - it's used to uniquely identify each record.

To add data to our object store, we'd do something like this. The `db` in this example represents the `IndexedDB` database instance.

```js
let transaction = db.transaction(["customers"], "readwrite");
let objectStore = transaction.objectStore("customers");
let request = objectStore.add({ id: 1, name: "John Doe", email: "john@example.com" });

request.onerror = function(event) {
  console.log("Error adding data");
};

request.onsuccess = function(event) {
  console.log("Data added successfully");
};
```

This code adds a new customer to our `"customers"` object store. We start a transaction (which is how we group database operations), get a reference to our object store, and then add our data.

Retrieving data works in a similar way. We start a transaction, get our object store, and then use methods like `get` to retrieve data:

```js
let transaction = db.transaction(["customers"]);
let objectStore = transaction.objectStore("customers");
let request = objectStore.get(1);

request.onerror = function(event) {
  console.log("Error retrieving data");
};

request.onsuccess = function(event) {
  console.log("Customer:", request.result);
};
```

This code retrieves the customer with `id` of `1` from our `"customers"` object store.

One of the key features of `IndexedDB` is that it's asynchronous.

This means that when you interact with `IndexedDB`, operations don't block the main thread of the web application. This ensures that your web application remains responsive even when dealing with large amounts of data.

While `IndexedDB` provides powerful capabilities, it has a steeper learning curve compared to other simpler storage API options which can be challenging for beginners. However, for applications that need to handle large amounts of structured data on the client-side, `IndexedDB` offers unparalleled capabilities.


## What Are Cache and Service Workers, and How Do They Work?

### Description

Caching is the process of storing copies of files in a temporary storage location so they can be accessed more quickly. 

When you visit a website, your browser can save certain files (such as images, CSS, and JavaScript) locally. This means that the next time you visit the same site, it can load these files from your device instead of fetching them again from a server, making the site load faster.

A service worker is a script that runs in the background, separate from your web page. It can intercept network requests, access the cache, and enable the web app to work offline. It is a key component of Progressive Web Apps.

So, how do cache and service workers work together in Progressive Web Apps?

PWAs are web apps that can offer an app-like experience. They can work offline, send push notifications, and even be installed on the home screen of a mobile device or computer.

When a user first visits a PWA, the service worker can cache important files. 

Users can continue to use the app offline, and when they come back online, any upcoming changes can be synced with the server.

The combination of caching and service workers enables web apps to provide a fast and reliable experience even in poor network conditions.


## Module: Classes And The This Keyword


### Lecture Block: Lecture Understanding How To Work With Classes In Javascript


## What Are Classes, and How Do They Work in JavaScript?

### Description

Let's learn about classes in JavaScript.

In modern JavaScript, classes are like blueprints that you can define in code for creating multiple objects of the same kind.

For example, if you're modeling an inventory system, you'll need to create multiple objects per type of product.

Each individual product will have its own properties and actions but products of the same kind can be created from the same "blueprint". That's what classes are used for.

Classes can be defined as either a class expression or class declaration.

Here is the basic syntax for a class declaration:

```js
class MyClassName {
  // Class Methods
  constructor() { ... }
  method1() { ... }
  method2() { ... }
  ...
}
```

You start by writing the `class` keyword followed by the name of the class. When naming classes, you should use the `PascalCase` naming convention instead of `camelCase`.

The content inside the curly braces is known as the class body. This is where the constructor and methods will go.

The constructor is a special method that gets called automatically when a new object is created from the class. It is typically used to initialize the properties of the object.

In this example, you can see a `Dog` class with a constructor.

```js
class Dog {
  constructor(name) {
    this.name = name;
  }
}
```

The `this` keyword is used here to refer to the current instance of the `Dog` class, allowing you to assign the `name` property to the object being created. You will learn more about the `this` keyword in a future lecture.

Below the constructor, you can have what are called methods. Methods are functions defined inside a class that perform actions or operations. They are used to define behaviors that instances of the class can perform.

Here is an example of adding a method called `bark` to the `Dog` class.

```js
class Dog {
  constructor(name) {
    this.name = name;
  }

  bark() {
    console.log(`${this.name} says woof!`);
  }
}
```

When the `bark` method gets called the message will be logged to the console with the actual name that was passed into it. If you create a `Dog` instance with the name `"Buddy"`, calling the `bark()` method on that instance will print `"Buddy says woof!"` to the console.

Once you have your class defined, you can create an instance of the class with the `new` keyword, the name of the class, and its arguments.

In this example, we create a new `Dog` instance with the name `Gino` and then we assign it to the variable `dog`.

```js
const dog = new Dog("Gino");
```

When you write `new Dog("Gino")` in your code, the new object is created and the constructor is called automatically with the given arguments.

You can then access this property using the dot notation, like you can see in the following line of code:

```js
console.log(dog.name);
```

This will log the value of the `name` property of this particular instance:

```js
Gino
```

You can also call methods. In this example, we are calling the `bark()` method on the `dog` instance.

```js
dog.bark();
```

This will log the following message to the console:

```js
Gino says woof!
```

As mentioned earlier, you can also define classes as a class expression. This is where the class is anonymous and assigned to a variable.

Here is what the earlier example looks like as a class expression:

```js
const Dog = class {
  constructor(name) {
    this.name = name;
  }

  bark() {
    console.log(`${this.name} says woof!`);
  }
};
```

Most of the time, you'll use class declarations, but understanding class expressions is also valuable, as they can offer more flexibility, especially in dynamic programming situations.

By using classes and understanding their basic syntax, you can create reusable code, organize it into logical units, and promote code modularity.


## How Does the This Keyword Work?

### Description

Let's learn about the `this` keyword. You learned that classes are like blueprints that you can use to create objects.

These blueprints need a general way to refer to the specific object that is being created, accessed, or modified within the code. That's exactly what the `this` keyword is used for. It refers to the context where the code is supposed to run. If you use it within a method, the value of `this` will be a reference to the object associated to that method. This way, you can access the properties and methods of the object within the class and reuse the method on different objects.

For example, here we have a `Dessert` class. This time, we're defining a `hasPeanuts` property.

```js
class Dessert {
  constructor(hasPeanuts) {
    this.hasPeanuts = hasPeanuts;
  }
}
```

Notice that we're using the `this` keyword within the constructor. Remember that the constructor is called automatically when a new object of the class is created.

The `this` keyword is telling the program that `hasPeanuts` should be a property of the object that is currently being created.

The right-hand side of the assignment statement is assigning the value of the `hasPeanuts` parameter to the `hasPeanuts` property of the new object.

```js
this.hasPeanuts = hasPeanuts;
```

That's in the context of the constructor but you can also use the `this` keyword within other methods.

This is our `Dessert` class with a few changes. Now we have two properties: `name` and `price`.

```js
class Dessert {
  constructor(name, price) {
    this.name = name;
    this.price = price;
  }

  showPrice() {
    console.log(`The price of ${this.name} is $${this.price}.`);
  }
}
```

We also have a new `showPrice` method. In this method, we print a descriptive message to the console with the name and the price of the dessert object.

Notice how we're using the `this` keyword to access the properties of the object within the `showPrice` method.

What value will the `this` keyword have in the context of this method? It will refer to the object on which the method is being called. In this case, we're creating a new Dessert instance with the name `“Brownie”` and the price `$5.99`:

```js
const brownie = new Dessert("Brownie", 5.99);
```

If we call the `.showPrice()` method on this object:

```js
brownie.showPrice();
```

Here is the output:

```js
The price of Brownie is $5.99.
```

The name and price of the current object (`brownie`) are replaced in the string.

This is all thanks to the `this` keyword, which gives you a general way to refer to the current object within the class. This allows you to reuse the method on different objects.

This is in the context of object methods but the `this` keyword will also have a value in standalone functions and arrow functions.

Its value within a standalone function typically refers to the global object (in non-strict mode) or `undefined` (in strict mode).

The value of the `this` keyword is a bit different in arrow functions. Arrow functions inherit the value of `this` from the enclosing scope where they are defined. They don't create their own `this` binding. That means that the value of `this` depends on the context where the arrow function is defined, not where or how the arrow function is called. This makes arrow functions helpful for callbacks or for preserving context.

However, because of this, the value of `this` will not refer to the current object in object methods, so this is something that you should keep in mind when working with arrow functions.

The same applies to arrow functions defined within other functions. They will inherit the value of `this` from their parent scope.

The `this` keyword is a powerful tool for accessing and manipulating objects. Understanding how it works is essential for mastering object-oriented programming in JavaScript.


## What Is Class Inheritance, and How Does It Work?

### Description

Let's learn about inheritance and how it works in JavaScript.

In programming, inheritance allows you to define classes that inherit properties and methods from other classes.

For example, a `Car` is a type of `Vehicle`, so you could define a `Vehicle` class with the most general properties and methods that are common to all types of vehicles and then define a `Car` class that inherits the properties and methods of the `Vehicle` class.

This "is a" relationship is characteristic of inheritance. In this example, `Car` is a more specialized form of `Vehicle`.

There are two main concepts that you should know about to start working with inheritance: parent class and child class.

A parent class is a class that acts like a blueprint for other classes. It defines properties and methods that are inherited by other classes.

A child class is a class that inherits the properties and methods of another class. Child classes can also extend the functionality of their parent classes by adding new properties and methods.

In our previous example, `Vehicle` would be the parent class of the `Car` class while the `Car` class would be the child class of `Vehicle`.

A parent class can have multiple child classes.

In JavaScript, we use the `extends` keyword to implement inheritance. This keyword indicates that a class is the child class of another class.

In this example, in which we only have the first lines of the class definitions, you can see that the `Car` class extends the `Vehicle` class, so `Car` inherits from `Vehicle`.

```js
class Vehicle {
  // Implementation of Vehicle...
}

class Car extends Vehicle {
  // Implementation of Car...
}
```

Let's say that the `Vehicle` class has two properties: `brand` and `year`. You can see this in the updated code.

`Car` has a method called `honk`. However, notice that the `Car` class doesn't have its own constructor. Let's see if it does inherit the properties.

```js
class Vehicle {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }
}

class Car extends Vehicle {
  honk() {
    console.log("Honk! Honk!");
  }
}
```

To define an instance of `Car`, you'll need to pass two arguments: `brand` and `year`. In this case, the brand is `freeCodeCamp Motors` and the year is `2019`.

```js
let myCar = new Car("freeCodeCamp Motors", 2019);
```

If you try to access these properties and call the method using dot notation:

```js
console.log(myCar.brand);
console.log(myCar.year);
myCar.honk();
```

Here is the output:

```js
freeCodeCamp Motors
2019
Honk! Honk!
```

Indeed, the output is correct, so these properties and method are defined in the `Car` instance and you just saved yourself a lot of code repetition by inheriting these properties from the `Vehicle` class.

In this example, the child class didn't have any additional properties. That's why the class didn't have a constructor, only a method.

If you do need to add additional properties, you'll need to define a constructor.

Let's see an example.


```js
class Vehicle {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }
}

class Car extends Vehicle {
  constructor(brand, year, numDoors) {
    super(brand, year);
    this.numDoors = numDoors;
  }
}
```

This time, we'll add a `numDoors` property to the `Car` subclass.

You can see that now this class has a constructor in the updated code. Within the constructor, there's a call to `super()`, passing the arguments `brand` and `year`.

`super()` invokes the constructor of the superclass, so by using `super(brand, year)` you will essentially be defining the properties of the superclass in the subclass. This is another terminology you can use- superclass is the parent class and the subclass is the child class.

Then, `this.numDoors = numDoors` line defines a new property that belongs exclusively to the `Car` class, the number of doors (`numDoors`).

This is a way to extend the `Vehicle` class, adding a property that is exclusive to `Car` instances.

That's is an example of extensibility, one of the fundamental advantages of inheritance.

Now, if you create an instance of the `Car` class, you'll see that it has the three properties: `brand`, `year`, and `numDoors`. You'll also need to pass the necessary arguments when you create the instance.

```js
let myCar = new Car("freeCodeCamp Motors", 2019, 4);
```

If you print the values of these properties with `console.log()`:

```js
console.log(myCar.brand);
console.log(myCar.year);
console.log(myCar.numDoors);
```

This is the output:

```js
freeCodeCamp Motors
2019
4
```

The main advantages of inheritance are code reusability, modularity, extensibility, and improved code structure.

By implementing a hierarchy, you can reuse code that you already wrote for a parent class in the child class, avoiding repetition.

Inheritance also promotes modularity by breaking down complex systems into simpler components in the hierarchy.

Also, being able to extend the functionality of the parent class makes it easier to adapt to changing requirements and add new features later on in the development process.

Finally, the hierarchical structure can make your code easier to understand and maintain.

Those are the fundamentals of inheritance. By understanding how inheritance works, you can design well-structured, maintainable, and extensible object-oriented programs.


## What Are Static Properties and Methods in Classes?

### Description

Let's learn about static properties and methods.

Static properties and methods belong to the class itself, not to the individual instances of the class. You can access them directly on the class name without creating an instance of the class. They are defined within classes to encapsulate related functionality.

You can define a static method by writing the `static` keyword before the name of the method.

```js
class MyClass {
  static staticMethod() { ... }
}
```

Then, you can call the static method on the class directly, using dot notation and passing any necessary arguments:

```js
MyClass.staticMethod();
```

Notice that you are able to call the method without creating an instance of the class. That's one of the key characteristics of static methods.

Here's an example. Let's say that we are creating a movies application and we want to be able to compare movies based on their rating.

We could consider this comparison method as a higher level method that is not specific to any movie:

```js
if (movieA.rating < movieB.rating) {
      console.log(`${movieB.title} has a higher rating.`);
    } 
```

It's like a more general method related to the `Movie` class.

For readability and maintainability purposes, it would be helpful to define it within the `Movie` class to keep all related methods relatively close to each other.

Therefore, this is a perfect candidate for a static method. You can see it here, just below the constructor:

```js
class Movie {

  constructor(title, rating) {
    this.title = title;
    this.rating = rating;
  }

  static compareMovies(movieA, movieB) {
    if (movieA.rating > movieB.rating) {
      console.log(`${movieA.title} has a higher rating.`);
    } else if (movieA.rating < movieB.rating) {
      console.log(`${movieB.title} has a higher rating.`);
    } else {
      console.log("These movies have the same rating.");
    }
  }

}
```

The static method is defined with the `static` keyword and it's called `compareMovies`. It has two parameters: `movieA` and `movieB`. These will be instances of the `Movie` class.

We will compare them based on their rating, on a range from `0` to `100`. This logic is implemented with a conditional and it will print an appropriate message based on which movie has a higher rating.

Once the method has been defined, you can call it on the class. But first, you need to have the arguments ready and defined in your program.

In this case, the method takes two movie instances as arguments, so we define these instances here:

```js
let movieA = new Movie("Movie A", 80);
let movieB = new Movie("Movie B", 45);
```

You can see that `movieA` has a higher rating than `movieB`. Let's see the output of this method.

To call the method, you just need to use dot notation on the class itself.
You write the name of the class (`Movie`), followed by a dot, and then the name of the static method (`compareMovies`).

Then, you pass the arguments within parentheses. In this case, they are the two movie instances that the method requires.

```js
Movie.compareMovies(movieA, movieB);
```

This is the output:

```js
Movie A has a higher rating.
```

Static methods are also helpful for implementing "factory" methods. A factory method is a method that you define in addition to the constructor to create objects based on specific criteria.

Here's an example with a `Pizza` class. The static method `createMargherita` is a factory method that you can call to create a Margherita pizza instance with its type and price already set.

```js
class Pizza {
  constructor(type, price) {
    this.type = type;
    this.price = price;
  }

  static createMargherita() {
    return new this("Margherita", 6.99);
  }
}
```

This also brings up something very important about static methods.

The value of the `this` keyword in static methods is the class itself, since the static method belongs to the class.

That's why we can use `this` to create a new instance of the `Pizza` class.

If you call this method on the `Pizza` class itself and assign the returned instance to a variable, like in this example:

```js
let myPizza = Pizza.createMargherita();
```

You can use it wherever you need to in your code. For example, you can print it to the console:

```js
console.log(myPizza);
```

This is the output:

```js
Pizza { type: 'Margherita', price: 6.99 }
```

You can also use dot notation to call its methods and access its properties, like this:

```js
console.log(myPizza.type);
```

This is the output:

```js
Margherita
```

In addition to methods, you can also define static properties with the `static` keyword.

In this example, we have a static `numberOfPizzasSold` property.

```js
class Pizza {
  static numberOfPizzasSold = 0;

  constructor(type) {
    this.type = type;
    Pizza.numberOfPizzasSold++;
  }
}
```

It's static because it doesn't belong to any particular pizza instance, it belongs to the class itself.

It has an initial value of `0` and it's updated every time a new instance is created.

If you create two pizza instances, the value will be updated twice:

```js
let pizza1 = new Pizza("Margherita");
let pizza2 = new Pizza("Neapolitan");
```

To access the value of a static property, you just need to use dot notation on the class itself, since the property belongs to the class.

```js
console.log(Pizza.numberOfPizzasSold);
```

In this case, the output is `2` because two pizzas were sold.

These are the fundamentals of static properties and methods in JavaScript. Understanding static members is essential for creating reusable and efficient classes.


## Module: Recursion


### Lecture Block: Lecture Understanding Recursion And The Call Stack


## What Is Recursion, and How Does It Work?

### Description

Let's learn how recursion works in JavaScript.

Recursion is a complicated feature that allows you to call a function repeatedly until a base-case is reached. Unlike a traditional loop, recursion allows you to handle something with an unknown depth, such as deeply nested objects/arrays, or a file tree. But you can also use it for more basic tasks, such as counting down from a given number.

Let's construct a function to do exactly that. We’ll call our function `recursiveCountdown`, and it needs to accept a number. We’ll have it print this number to the console:

```js
const recursiveCountdown = (number) => {
  console.log(number);
};
```

Now if we call this and pass the number 5, we’ll see the number print to our terminal. But nothing else happens – and the number 5 certainly isn’t a countdown.

Before we start building the recursive portion of our function, we need to establish our base case first. If you don’t have a base case established, your code will run until it exceeds your memory allocation and crashes.

```js
const recursiveCountdown = (number) => {
    if (number < 1) {
        return;
    }
    console.log(number);
  };

recursiveCountdown(5);
```

For our base case, we want the countdown to stop if the number is less than 1. When we hit that base-case, we can return to break out of the function execution.

Now that we’ve safely prepared a base-case, we can set up the recursion. The key point that makes a function recursive is that it calls itself in its execution. In this case, we want to call the function after we print the number. But in order to count down, our new number needs to be one less:

```js
const recursiveCountdown = (number) => {
    if (number < 1) {
        return;
    }
    console.log(number);
    recursiveCountdown(number - 1);
  };

recursiveCountdown(5); // 
```

This would log the numbers 5, 4, 3, 2, and 1 to the console.

We do get our five numbers! But what if we wanted to count up instead? Rather than writing an entirely new function, we can swap the order of our log and our recursive call:

```js
const recursiveCountdown = (number) => {
    if (number < 1) {
        return;
    }
    recursiveCountdown(number - 1);
    console.log(number);
  };

recursiveCountdown(5);
```

This would log the numbers 1, 2, 3, 4, and 5 to the console.

But why does that work? Well, to understand this you need to understand the call stack. The call stack is how JavaScript tracks and resolves function calls. The stack functions as a last-in-first-out queue of sorts. To understand this better, let’s add some logging to our function:

```js
const recursiveCountdown = (number) => {
    console.log(`Function execution started for number: ${number}`);
    if (number < 1) {
        console.log(`Base case reached, begin resolving stack`);
        return;
    }
    console.log(`Calling recursiveCountdown with number: ${number - 1}`);
    recursiveCountdown(number - 1);
    console.log(`Function execution completed for number: ${number}`);
  };

recursiveCountdown(5);
```

We’ve added four key statements here. The first log runs when a function call begins executing. The third log runs just before the recursive function is called. And the fourth log runs when the function execution has ended. The result is:

```md
Function execution started for number: 5
Calling recursiveCountdown with number: 4
Function execution started for number: 4
Calling recursiveCountdown with number: 3
Function execution started for number: 3
Calling recursiveCountdown with number: 2
Function execution started for number: 2
Calling recursiveCountdown with number: 1
Function execution started for number: 1
Calling recursiveCountdown with number: 0
Function execution started for number: 0
Base case reached, begin resolving stack
Function execution completed for number: 1
Function execution completed for number: 2
Function execution completed for number: 3
Function execution completed for number: 4
Function execution completed for number: 5
```

But how does this happen? Well, this is where the call stack comes in to play. When we call `recursiveCountdown(5)`, that function call is added to the call stack. 

When that function call reaches the point where it needs to call `recursiveCountdown(4)`, it has to stop and wait for that result. Meanwhile, our `recursiveCountdown(4)` gets added to the call stack, on top of the `recursiveCountdown(5)`.

When that function call reaches the point where it needs to call `recursiveCountdown(3)`, it has to stop and wait for that result. Meanwhile, our `recursiveCountdown(3)` gets added to the call stack, on top of the `recursiveCountdown(4)`.

When that function call reaches the point where it needs to call `recursiveCountdown(2)`, it has to stop and wait for that result. Meanwhile, our `recursiveCountdown(2)` gets added to the call stack, on top of the `recursiveCountdown(3)`.

When that function call reaches the point where it needs to call `recursiveCountdown(1)`, it has to stop and wait for that result. Meanwhile, our `recursiveCountdown(1)` gets added to the call stack, on top of the `recursiveCountdown(2)`.

And finally, when that function call reaches the point where it needs to call `recursiveCountdown(0)`, it has to stop and wait for that result. Meanwhile, our `recursiveCountdown(0)` gets added to the call stack, on top of the `recursiveCountdown(1)`.

But `recursiveCountdown(0)` doesn’t call another function – it hits our base case, where it returns early. Because the execution of that function has ended, the function call can be considered “resolved”. When the call is resolved, it’s removed from the stack.

Now our `recursiveCountdown(1)` is no longer waiting on that call – it’s at the top of the stack and can resume executing.

`recursiveCountdown(1)` resolves, is removed from the stack, and allows `recursiveCountdown(2)` to resume execution.

`recursiveCountdown(2)` resolves, is removed from the stack, and allows `recursiveCountdown(3)` to resume execution.

`recursiveCountdown(3)` resolves, is removed from the stack, and allows `recursiveCountdown(4)` to resume execution.

`recursiveCountdown(4)` resolves, is removed from the stack, and allows `recursiveCountdown(5)` to resume execution.

And `recursiveCountdown(5)` resolves and is removed from the stack. Our call stack is now empty, so the recursion is complete!

This is a basic overview of how recursion works in JavaScript. It’s a complicated concept, and you should play around with some code and log statements until you’re comfortable with the behavior of the call stack.

For a little fun fact, we talked about how a lack of a base-case can cause your code to crash when it runs out of memory. This is because the recursion keeps piling more and more function calls into the call stack until the stack overflows. Just like the name of the popular programming community.


## Module: Functional Programming


### Lecture Block: Lecture Understanding Functional Programming


## What Is Functional Programming?

### Description

Functional programming is about writing code that is clean, predictable, and easier to test and debug. Two key concepts we'll explore today are pure functions and avoiding side effects.

Let's start with pure functions. 

A pure function is a function that, given the same input, will always return the same output, and it doesn't modify anything outside of itself.

Here's an example of a pure function:

```js
function add(a, b) {
  return a + b;
}
```

This function is pure because it always returns the same result for the same inputs, and it doesn't change anything outside of itself. No matter how many times you call `add(2, 3)`, it will always return `5`, and it won't affect any other part of your program.

Now, let's contrast this with an impure function:

```js
let total = 0;
function addToTotal(value) {
  total += value;
  return total;
}
```

This function is impure because it modifies a variable outside of itself (`total`). The result of `addToTotal(5)` will be different depending on what `total` was before the function was called. This unpredictability can make our code harder to understand and debug.

This brings us to our next important concept and that is side effects.

A side effect is any change that occurs in the state of the program when a function is called. This could include modifying a global variable, writing to a file, or making an API call.

Pure functions have no side effects but impure functions have these.

Avoiding side effects is a key principle of functional programming. When we minimize side effects, our code becomes more predictable and easier to test. 

While writing code, our main goal should be to make functions do one thing and they should do it very well without changing other parts of our program.

Here's an example of a function with a side effect:

```js
function greet(name) {
  console.log(`Hello, ${name}!`);
}
```

This function has a side effect because it interacts with the outside world by logging to the console. 

In functional programming, we might rewrite this as:

```js
function greet(name) {
  return `Hello, ${name}!`;
}
console.log(greet("Alice"));
```

Now `greet` is a pure function that simply returns a string, and we handle the side effect (logging to the console) separately.

Functional programming encourages us to compose our programs using pure functions by breaking our code into small, predictable pieces. And thus, we can build programs that are easier to understand, test, and maintain.


## What Is Currying, and How Does It Work?

### Description

Currying is a technique where we transform a function that takes multiple arguments into a sequence of functions, each taking a single argument.

Let's start with a basic example. Imagine we have a function that adds two numbers:

```js
function add(a, b) {
  return a + b;
}

console.log(add(3, 4)); // Output: 7
```

This is a function that takes two arguments and returns their sum. Now, let's see how we can curry this function:

```js
function curriedAdd(a) {
  return function(b) {
    return a + b;
  }
}

console.log(curriedAdd(3)(4)); // Output: 7
```

In this curry converted code, instead of taking two arguments at once, we have a function that takes the first argument and returns another function. This returned function then takes the second argument and performs the addition. We call it like `curriedAdd(3)(4)`, where each pair of parentheses represents a function call.

But why would we want to do this? 

Currying allows us to create some special functions easily. For example, we could create a function that always adds five to any number:

```js
const addFive = curriedAdd(5);
console.log(addFive(10)); // Output: 15
console.log(addFive(20)); // Output: 25
```

Here, `addFive` is a function that's always ready to add five to whatever number we give it. This is a simple example of partial application, where we fix a certain number of arguments to a function, producing another function that takes fewer arguments.

While our examples have focused on functions with two arguments, currying can be applied to functions with any number of arguments.

As you continue your journey in JavaScript, you'll likely find many situations where currying can make your code cleaner and more expressive.


## Module: Asynchronous Javascript


### Lecture Block: Lecture Understanding Asynchronous Programming


## What Is Asynchronous JavaScript, and How Does It Differ from Synchronous JavaScript?

### Description

Let’s learn about asynchronous JavaScript. Asynchronous events occur at different times, independently from each other.

In the context of software development, "asynchronous" refers to tasks that run in the background, independently from the main flow of the program. The main advantage of asynchronous processes is that they don’t block the execution of the main program.

That’s particularly helpful for tasks that may take a long time to run, such as fetching data from a remote server, processing large files, handling user input, and performing complex calculations. This is what we know as asynchronous programming.

This approach contrasts with the traditional synchronous programming technique that you have been working with so far. When you write multiple lines of code, you can usually predict what will happen and when it will happen. The first line will be executed, then the second line, and so on in the order that you write them.

In this example, the first line where you define the variable will be executed first, then the second line, and finally the third line where the string is logged to the console:

```js
const topic = "JavaScript";
const learning = `I'm learning ${topic}!`;
console.log(learning);
```

Everything is sequential and predictable. Each line is completed before the next one starts. This type of JavaScript program is known as single-threaded.

The concept of threads is very important. A thread is a unit of execution within a process. It’s like a separate flow of control within the program.

In synchronous programming, threads execute sequentially, one after the other. If a thread is blocked, like waiting for user input, the entire process is blocked until the thread is completed.

In asynchronous programming, threads can be executed concurrently, running multiple threads at the same time. This way, the program can continue running multiple tasks simultaneously without making the main program unresponsive, even if one of the threads is blocked.

Asynchronous programming often involves callbacks, promises, or async/await to handle non-blocking operations.

As you learned in earlier lectures, a callback is a function that you pass to another function to be called later. Event handlers are a particular type of callback that you’ve worked with before. They used to be the most common way to implement asynchronous functions in JavaScript. However, if the callback function also takes other callback functions, the code and logic can get quite complicated very quickly. 

Currently, the most commonly used technique for implementing asynchronous programming in JavaScript is the promise. A `Promise` is an object that represents the eventual completion (or failure) of an asynchronous process and its value.

The value of a promise is not known when the promise is created. It’s only known when the asynchronous process is completed. For example, the process of fetching data from a remote API for your web application may take some time. Meanwhile, you want your users to have a nice user experience, right?

To implement this, you could create a promise to keep the user interface active and interactive while the asynchronous process is running. When the process is completed, the promise will contain the data that was sent back by the API, so the application can handle it or render it appropriately when it’s available.

Asynchronous programming is a powerful tool for building efficient JavaScript applications. By understanding the differences between synchronous and asynchronous programming, you can choose the right approach for your application and write more efficient code.


## How Does the Async Attribute Work Inside Script Elements, and How Does It Differ from the Defer Attribute?

### Description

The `async` and `defer` attributes in HTML `script` elements play a crucial role in how JavaScript files are loaded and executed in web pages. Understanding them can improve your website's performance and user experience. When you include a `script` in your HTML file, it looks like this:

```js
<script src="example.js"></script>
```

When the browser finds this `script` tag, it stops parsing the HTML, downloads the script, executes it, and then continues parsing the HTML. This can slow down the loading of your web page, especially if you have large scripts.

This is where the `async` and `defer` attributes come in. They provide ways to load scripts more efficiently.

Let's start with the `async` attribute:

```js
<script src="example.js" async></script>
```

By adding the `async` attribute to a `script` tag, the browser will continue parsing the HTML while the script is being downloaded. Once the script is fully downloaded, the browser will pause HTML parsing, execute the script, and then resume parsing the HTML. This can significantly speed up page loading.

It's important to note that async scripts are executed as soon as they're downloaded, which means they might not run in the correct order which we desire. This is where the `defer` attribute comes in for the rescue. Let's look at how the `defer` attribute looks like:

```js
<script src="example.js" defer></script>
```

The `defer` attribute is similar to `async` attribute. However, defer scripts are not executed immediately after they're downloaded. Instead, they wait until the HTML parsing is complete. Furthermore, defer scripts execute in the order they appear in the HTML code.

In short, use `async` for scripts where the order of execution doesn't matter, and use `defer` when you need to ensure that scripts run in the correct order. Both attributes can significantly improve page load times by allowing the browser to continue parsing HTML while scripts are being downloaded in the background.


## What Is the Fetch API, and What Are Common Types of Resources That Are Fetched from the Network?

### Description

The Fetch API allows web apps to make network requests, typically to retrieve or send data to the server. This API provides a `fetch()` method that you can use to make these requests. Let's look at a basic example of how to use `fetch`:

```js
fetch('https://api.example.com/data')
```

In this example, we're making a `GET` request to `https://api.example.com/data`. This will then return us some data that we need to convert to JSON format and can use anywhere we want to. 

By default, the Fetch API uses the `GET` method to retrieve data. This will be covered in the next lecture, along with other common HTTP request methods.

Now, let's discuss some common types of resources that are fetched from the network.

In our web apps, we need some common data like weather data, professions list data, country names list, country code or country flag icons/images. Using these data we can make our app more informative and interactive. Thanks to Fetch API, we can get these resources from the network.

Images are some frequently fetched resources. You might use fetch to load images statically or dynamically based on user actions, and display them on your web app.

Text files are another type of resource often fetched. This could include configuration files, log files, or even entire documents that you want to display on your webpage.

In some cases, you might fetch audio or video files. The Fetch API can handle these types of resources as well, allowing you to work with a wide variety of data types.


## How Does the Fetch API Work with Common HTTP Methods and res.json()?

### Description

In the previous lecture, we saw what the Fetch API is and how to use it. In this lecture, we will discuss about the `GET`, `POST`, `PUT` and `DELETE` HTTP methods of Fetch API.

Let's start with the most common HTTP method which is the `GET` method. This is used to retrieve data from a server. When you use `fetch()` without specifying a method, it defaults to `GET`.

```js
fetch('https://api.example.com/data')
```

In this code, we're making a `GET` request to `https://api.example.com/data`. Now, please note that you cannot use this data directly, you have to convert the response to a JSON format. Only then you can use it anywhere you want in your project. Here’s an example of how to do it:

```js
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
```

In this code, the response coming from the Fetch API is a promise, and we are using a `.then` handler to convert the response to a JSON format. In a prior lecture, you learned that a `Promise` is an object that represents the eventual completion (or failure) of an asynchronous process and its value.

The value of a promise is not known when the promise is created. It’s only known when the asynchronous process is completed. When we chain the two `.then` handlers to the fetch call, this is something called promise chaining which will be taught in the next lecture.

So far we have been retrieving resources from a server. But, did you know that we can also send data to the server? The `POST` method is used to send data to a server to create a resource. Here’s an example of a `POST` method which is used to create data into the server: 

```js
fetch('https://api.example.com/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    name: 'John Doe',
    email: 'john@example.com'
  })
})
```

In this example, we're sending a `POST` request to create a new user. We specify the method as `POST`, set the appropriate headers, and include a `body` with the data we want to send. The body needs to be a string, so we use `JSON.stringify()` to convert our object to a JSON string.

The `PUT` method is used to update existing resources of a server. Here’s an example: 

```js
fetch('https://api.example.com/users/45', {
  method: 'PUT',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    name: 'John Smith',
    email: 'john@example.com'
  })
})
```

In this example, look carefully at the URL, you can see a `45` at the end. This is typically used as a unique ID to identify the data we are trying to update. We used the `PUT` method on the code and also specified the data as the `body` which will be used to update the identified data. 

The `DELETE` method is used to delete a resource from the server. Here’s an example:

```js
fetch('https://api.example.com/users/45', {
  method: 'DELETE',
})
```

In this code, we are including the `DELETE` method and an ID at the end of the url to identify the data which needs to be deleted.


## What Are Promises, and How Does Promise Chaining Work?

### Description

A `Promise` is an object that represents the eventual completion or failure of an asynchronous operation. It's initially in a pending state. It can then transition to either a fulfilled state when the operation is successful, or a rejected state when the operation fails. Here's an example of creating a `Promise`:

```js
const aPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("Operation successful!");
  }, 1000);
});
```

In this example, we create a promise that simulates an asynchronous operation using `setTimeout`. After one second, the promise is resolved with the message `Operation successful!`.

Another way to work with promises is to use the `.then` and `.catch` methods.

The `.then()` method is used in a promise to specify what should happen when the promise is fulfilled, while `.catch()` is used to handle any errors that occur. Let's see how we can use `.then` and `.catch` with our promise:

```js
aPromise.then((result) => {
  console.log(result);  // Outputs: "Operation successful!"
}).catch((error) => {
  console.error(error);
});
```

In this code, or instructions of what to do when the promise is fulfilled, the function passed to `.then()` will be called with the resolved value of the promise. If an error occurs, the function passed to `.catch()` will be called instead.

Now, let's talk about promise chaining. One of the powerful features of promises is that we can chain multiple asynchronous operations together. Each `.then()` can return a new promise, allowing you to perform a sequence of asynchronous operations one after the other. Here’s an example: 

```js
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => {
    console.log(data);
    return fetch('https://api.example.com/data2');
  })
  .then(response => response.json())
  .then(data2 => console.log(data2))
  .catch(error => console.error('Error:', error));
```

In this example, we're making two API calls in sequence. The first `.then()` parses the response as JSON. The second `.then()` logs the data and makes another API call. The third `.then()` parses the response of the second API call, and the fourth `.then()` logs that data. If an error occurs at any point in this chain, it will be caught by the `.catch()` at the end.

It's important to note that `.catch()` will catch errors from any of the previous steps in the chain. This means you don't need to add error handling to each individual step, which can greatly simplify your code.


## What Is Async/Await, and How Does It Work?

### Description

In the previous lectures, you learned about asynchronous programming which allows other code to run while we wait for some time-consuming tasks to complete, like fetching data from a server, reading data from a file, and so on.

`async`/`await`, built on top of promises, makes writing and reading asynchronous code easier. When you put the `async` keyword before a function, it means that function will always return a `Promise`. Only inside an `async` function, you can use the `await` keyword, which allows you to wait for a `Promise` to resolve before moving on to the next line of code. Here's an example to illustrate how `async`/`await` works:

```js
async function delayedGreeting(name) {
  console.log("A Messenger entered the chat...");
  await new Promise(resolve => setTimeout(resolve, 2000));
  console.log(`Hello, ${name}!`);
}

delayedGreeting("Alice");
console.log("First Printed Message!");
```

In this code, we define an `async` function called `delayedGreeting`. Inside this function, we use `await` to pause the execution for 2 seconds. After the delay, it prints a greeting. 

When we call this function, you'll see `First Printed Message!` appear before the greeting. This is because the function is asynchronous - it doesn't block the rest of the code from running.

One of the biggest advantages of `async`/`await` is error handling. With promises, we often had to use `.catch()` method to handle errors. With `async`/`await`, we can use `try`/`catch` blocks. Here's an example:

```js
async function fetchUserData() {
  try {
    let response = await fetch(`https://api.example.com/users`);
    let userData = await response.json();
    console.log(userData);
  } catch (error) {
    console.log("Error fetching user data:", error);
  }
}

fetchUserData();
```

In this example, we're using `async`/`await` to fetch user data from an API. The `await` keyword is used twice: once to wait for the fetch operation to complete, and again to wait for the JSON parsing to finish. If any error occurs during this process, it will be caught in the `catch` block.


## How Does the JavaScript Engine Work, and What Is a JavaScript Runtime?

### Description

The JavaScript engine has the ability to read, understand, and execute your code. It works like a converter that takes your code, turns it into instructions that the computer can understand and work accordingly. 

One of the most well-known JavaScript engines is V8, developed by Google, used in Chrome and Node.js. The JavaScript engine works in a few steps. First, it parses your code, reading it line by line to make sure there’s no mistake in the JavaScript code. Then, it converts this code into bytecode, which is a simpler, intermediate version of your code that’s easier for the computer to understand and execute. Finally, it runs this bytecode to execute your program's instructions. Here's an example of JavaScript code:

```js
const greeting = "Hello, World!";
console.log(greeting);
```

When you run this code, the JavaScript engine first parses it to check for any syntax errors. Parsing means the engine reads the code and breaks it down into a structure it can understand, checking for mistakes along the way. 

Then, it compiles the code into an intermediate format (often bytecode or machine code, depending on the engine). Compiling is the process of converting the human-readable code into a more efficient format that the computer can execute faster. 

Finally, the engine executes the code, printing `Hello, World!` to the console.

Now, let's talk about the JavaScript runtime. The JavaScript runtime is the environment in which your JavaScript code is executed. It includes the JavaScript engine (like V8 in Chrome or SpiderMonkey in Firefox), which processes and executes the code, as well as additional features provided by the environment (such as a web browser or Node.js, which you will learn more about in future lectures).

While the core JavaScript language handles things like variables, loops, and functions, the runtime provides extra tools that allow JavaScript to interact with things outside of the language itself, like the DOM (for web pages) or the Fetch API (for making network requests).

In short, the runtime is what allows JavaScript to do more than just basic programming tasks – like interacting with web pages or handling time-based actions – by providing these extra features beyond the language itself.

While you don't need to know every detail of engines and runtimes to write JavaScript, having a basic understanding can help you write more efficient code and debug problems more effectively.


## What Is the Geolocation API, and How Does the getCurrentPosition Work?

### Description

The Geolocation API provides a way for websites to request the user's location. It's important to note that for privacy reasons, the user has to give permission before their location can be accessed via the website.

The main method we'll be focusing on today is `getCurrentPosition`. This method is used to collect the geographic location of the device. Here's an example of how you might use `getCurrentPosition`:

```js
navigator.geolocation.getCurrentPosition(
  (position) => {
    console.log("Latitude: " + position.coords.latitude);
    console.log("Longitude: " + position.coords.longitude);
  },
  (error) => {
    console.log("Error: " + error.message);
  }
);
```

In this code, we're calling `getCurrentPosition` and passing it a function which will be called when the position is successfully obtained. This position object contains various pieces of information, but we're focusing on `latitude` and `longitude` only.

If there is an issue with getting the position, then the error will be logged to the console. 

The `getCurrentPosition` method uses GPS, Wi-Fi networks, or IP address geolocation, depending on the device and its settings. Once the location is found, the success callback function is called with a position object.

The position object contains a various properties, where the most commonly used are `latitude` and `longitude`, but it can also include `altitude`, `accuracy`, `speed`, and `heading`, and so on.

One important consideration when using geolocation is user privacy. Explain to your users why you need their location data and how you'll use it.


## Module: Review Javascript


# Chapter: Frontend Libraries


## Module: React Fundamentals


### Lecture Block: Lecture Introduction To Javascript Libraries And Frameworks


## What Is the Role of JS Libraries and Frameworks, and Why Are They Used in the Industry?

### Description

JavaScript libraries and frameworks provide pre-built code that streamlines the development process.  While both libraries and frameworks serve to improve productivity and standardize coding practices, they differ in their approach and level of control they provide to developers.

Libraries are generally more focused on providing solutions to specific tasks, such as manipulating the DOM, handling events, or managing AJAX requests.

An example of a JavaScript library is jQuery.

jQuery became very popular in the early 2010s and was widely used to simplify DOM manipulation, event handling, animations, effects, and more. This library also offered a rich ecosystem of plugins, which made it easy to build common web components like date pickers, sliders, and modal dialogs.

Although jQuery is no longer as widely used as it once was, it significantly helped developers by making tasks that were complex in vanilla JavaScript much easier to implement.

Frameworks, on the other hand, provide a more defined structure for building applications. They often come with a set of rules and conventions that developers need to follow.

For example, Angular encourages a component-based architecture with a set of conventions and tools that provide a structured approach to organizing and building applications. Angular gives developers clear guidelines on how to structure components, manage state, handle routing, and interact with services, making it a more opinionated framework.

Other examples of frameworks include Remix and Next.js.

In contrast, React, a UI library, is more flexible and doesn't enforce any particular architectural pattern. React focuses primarily on the view layer and leaves a lot of the choices on application design up to the developers.

Although libraries and frameworks are used across projects of all sizes, the choice between using them often depends on the project's requirements. Libraries offer flexibility for specific functionalities, while frameworks provide a structured approach towards complex applications.

In the industry, libraries and frameworks are widely used for several reasons. They significantly speed up development by providing quick solutions for common problems.

One common problem in JavaScript is working with dates and timezones. But there are libraries out there with built-in solutions to help you with date manipulation, time zones, parsing and formatting of dates.

A lot of popular libraries and frameworks are well-tested and maintained by large communities. This means they're often more practical than building the same thing from scratch.

Libraries and frameworks follow best practices and patterns that have been proven effective in real life scenarios. This can lead to more robust and scalable applications.

In conclusion, libraries and frameworks offer quick solutions to common problems, speed up development, and promote best practices. Understanding the differences between libraries and frameworks, and knowing when to use them is a valuable skill for any JavaScript developer.


## What Are Single Page Applications, and What Are Some Issues Surrounding Them?

### Description

Unlike traditional multi-page websites, single page applications (SPAs) load only one HTML page and dynamically update the content as the user interacts with the app, without reloading the entire page. This approach can lead to faster, more responsive applications, but it also comes with a set of challenges and considerations.

SPAs heavily use JavaScript to manage the application's state and render content. Instead of requesting new HTML pages from the server, SPAs use JavaScript to manipulate the DOM and fetch data asynchronously. This is often done using libraries and frameworks like React, Vue, or Angular, which provide great tools for building complex user interfaces.

SPAs have some common issues. One significant issue is that screen readers may struggle with dynamically updated content. When content changes without a page reload/refresh, screen readers might not notify these changes, which makes our users unaware of updates on our web app.

Another challenge with SPAs is with navigation and browser history. Users expect the back and forward buttons to work as they do on traditional websites. This might not work properly in SPAs because technically, the URL of the web app doesn’t change. Since, the URL of the web app doesn’t change, they can’t bookmark any specific page. Refreshing the page might reset the application to its initial state, rather than maintaining the current view.

SPAs can pose challenges for SEO optimization. Search engines like Google can have difficulty indexing dynamically loaded content because they may not execute JavaScript properly or may miss content that isn’t included in the initial HTML page. This can lead to pages not being indexed correctly.

However, modern search engines have improved their ability to crawl SPAs, and there are techniques such as server-side rendering (SSR), pre-rendering, and the use of SEO-friendly URLs that can help mitigate these issues and improve SEO for SPAs.

Performance is another consideration. SPAs load the entire application in one go, which means that if the loading time increases, users will be seeing a blank screen for a longer period of time. Now consider the scenario of users with slower internet speeds. Overall, the user experience will not be very pleasant.

In conclusion, while Single Page Applications offer many benefits, they also present unique challenges. Developers need to be careful of accessibility, usability, SEO, and performance considerations when building SPAs. By addressing these issues, it's possible to create SPAs that are fast, responsive, and accessible to all users.


## What Is React, and What Is It Commonly Used For?

### Description

React is one of the most popular JavaScript libraries for building user interfaces and web applications. Originally developed and maintained by Facebook, React has gained huge popularity in web development due to its efficiency, flexibility, and features.

A fundamental concept in React is the creation of reusable UI components. These components, such as buttons, cards, and avatar components, can be easily reused throughout your application. You can nest these components inside each other to build more complex, dynamic interfaces.

One of the key advantages of React is that these custom components can update and render independently as data changes.

Unlike traditional JavaScript, which requires direct manipulation of the DOM (Document Object Model), React uses a virtual DOM, which improves performance and efficiency. You’ll learn more about the virtual DOM and how it works in upcoming lectures.

In addition to reusable components, React also provides a powerful way to manage the state of your application. State refers to the data that determines how a component renders and behaves.

With React, you can easily track and update the state of components, ensuring that the UI reflects the most current data. You will learn more about working with state in future lectures.

While there are many libraries within the JavaScript ecosystem, freeCodeCamp will mainly be focused on teaching React because of its widespread use and demand in the industry.

Our next few lectures will dive deeper into building custom components, managing state, and more.


## What Are Components in React, and How Do They Work?

### Description

Components are the building blocks of React applications that allow developers to break down complex user interfaces into smaller, manageable pieces, making it easier to develop and maintain large-scale applications.

The two types of components in React are functional and class-based components. In modern React, developers will use functional components and all of the examples we look at today will be functional components.

At a higher level, you can think of components like JavaScript functions that return elements describing the UI.

This UI is described using JSX, a syntax extension for JavaScript that looks similar to HTML but allows you to write UI elements in a more declarative way.

Let's look at an example of a React component:

```jsx
function Greeting() {
  const name = "John"
  {/* The result will be Hello John*/}
  return <h1 className="title">Hello {name}</h1>;
}
```

In this example, we've defined a component called `Greeting`. The curly braces `{}` inside the `h1` tags enable us to embed JavaScript expressions, allowing us to access the `name` variable within the `h1` element.

We are also applying a `className` called `title` to the `h1` element.

But why are we using `className` instead of `class` like with regular HTML elements?

Well, this is because in JavaScript, `class` is a reserved name. So, we need to use `className` instead.

We are also using a comment in JSX showing what the result will be. It is important to note that you can use regular comment syntax like this but it needs to be wrapped in curly braces in order for it to work:

```jsx
{/* Block Comments */}
```

Another thing you might have noticed is that we are using a capital letter at the beginning of the component name. But why can’t we use all lower case letters?

This is because React treats components with a capital letter as custom components, while elements with lowercase letters are considered built-in HTML elements.

When React encounters a lowercase tag, like `<div>` or `<span>`, it assumes it's a standard HTML element. However, if the component name starts with a capital letter, React will treat it as a user-defined component and render it accordingly. This distinction helps React differentiate between native HTML tags and components that you create.

To use this `Greeting` component in our application, we would write something like this:

```jsx
<Greeting />
```

This would render an `h1` element with the text `Hello John` to the page. But take a closer look at the syntax here. When we use the component, it ends with a forward slash and then the greater than symbol.

When working with JSX, all tags and uses of components need to be explicitly closed. So if the component or tag does not have any children, then you need to explicitly close it like shown here:

```jsx
<Greeting /> {/* /> is required */}
```

So far we have only been looking at how to render a single `h1` element. But you can actually render multiple elements.

Let’s take a look at the following example code here:

```jsx
function Greeting() {
  const name = "John";
  {/* This will throw an error */}
  return <h1>Hello {name}</h1> 
  <p>Nice to meet you.</p>
}
```

We are trying to add another sentence of `Nice to meet you` but it is not rendering on the page correctly.

There seems to be an error message instead. The error message says `Adjacent JSX elements must be wrapped in an enclosing tag.`

The reason why you are getting that error message is because multiple sibling elements need to be wrapped in a parent element. While you could wrap the `h1` and `p` elements in a simple `div`, there is another way to silence the error.

React fragments are used to group elements together. Here is what the revised example will look like:

```jsx
function Greeting() {
  const name = "John";
  return (
    <Fragment>
      <h1>Hello {name}</h1>
      <p>Nice to meet you.</p>
    </Fragment>
  );
}
```

You can also choose to use empty JSX tags which can serve as shorthand for fragments:

```jsx
function Greeting() {
  const name = "John";
  return (
    <>
      <h1>Hello {name}</h1>
      <p>Nice to meet you.</p>
    </>
  );
}
```

In future lectures, we will continue to learn more about how to work with components and JSX. But for now, you've gained a solid introduction to building user interfaces with components, setting a strong foundation for what's to come.


## How Can You Import and Export Components in React?

### Description

In earlier lectures, you learned how to work with imports and exports in JavaScript. In this lecture, we will take a look at how to import and export components in React.

In this example, we have a `Cat` component that belongs in a file called `Cat.jsx`. For the file extension, we are using the `.jsx` file extension because this file is mainly working with JSX.

This `Cat` component returns a JSX markup with a title and image for a cat called Mr. Whiskers:

```jsx
function Cat() {
  return (
    <div className="card">
      <h2>Mr. Whiskers</h2>
      <img
        src="https://cdn.freecodecamp.org/curriculum/cat-photo-app/running-cats.jpg"
        alt="Cute cats running in the grass."
      />
    </div>
  );
}
```

If we want to use our `Cat` component in another file, we need to first export it like this:

```jsx
function Cat() {
  return (
    <div className="card">
      <h2>Mr. Whiskers</h2>
      <img
        src="https://cdn.freecodecamp.org/curriculum/cat-photo-app/running-cats.jpg"
        alt="Cute cats running in the grass."
      />
    </div>
  );
}

export default Cat;
```

We are using the `default` keyword because this will be the default export from the module. You can also choose to export the component on the same line as the component definition like this:

```jsx
export default function Cat() {
  return (
    <div className="card">
      <h2>Mr. Whiskers</h2>
      <img
        src="https://cdn.freecodecamp.org/curriculum/cat-photo-app/running-cats.jpg"
        alt="Cute cats running in the grass."
      />
    </div>
  );
}
```

You can choose to import child components in other parent component files, or import them in the root component file. For this example, we will import the `Cat` component inside the root component file.

Every React project will have a top-level component, typically called `App.jsx`:

```jsx
export default function App() {
  return (
    // return component here
  );
}
```

This file is usually located in the `src` directory of your project. You’ll learn more about common project layouts in a future lecture.

To use the `Cat` component inside the root `App` component, you will need to import it like this:

```jsx
import Cat from "./Cat";

export default function App() {
  return (
    // return component here
  );
}
```

Now, you can return the `Cat` component inside the `App` component like this:

```jsx
import Cat from "./Cat";

export default function App() {
  return (
    <Cat />
  );
}
```

As you continue building your own React projects, you’ll become more comfortable organizing components, importing them where needed, and creating sophisticated UIs by composing these modular components.


## What is Vite, and How Can It Be Used to Set Up a New React Project?

### Description

Unlike working with smaller vanilla HTML, CSS, and JavaScript projects, starting a new React project includes a few more steps to ensure that everything runs correctly. Instead of trying to set up of all of the necessary configurations by yourself, there are tools that will do that for you. 

One of the most popular tools for setting up projects is Vite. Vite, which means "fast" in French, is a build tool that aims to provide a faster development experience for modern web projects. Vite can be used with React, as well as with other libraries and frameworks like Vue or Svelte. You can even use it with vanilla JavaScript projects.

To create a new project with Vite, you will need to use the command line. If you are using Windows machine, then you can use the Command Prompt or Windows PowerShell. If you are using a Mac, then you can use the Terminal app.

Once you have the command line open, you can use the following command:

```bash
npm create vite@latest my-react-app -- --template react
```

This command creates a new React project named `my-react-app` using Vite's React template.

You can then open up the new project and see the React boilerplate code that Vite has provided for you.

[Image showing the boilerplate Vite files and folders in a code editor, including the `public` and `src` folders, and the `.gitignore`, `eslint.config.js`, `index.html`, `package.json`, `README.md`, and `vite.config.js` files.]

The great thing about Vite is that it will only provide the files that are absolutely necessary to get started with your React project.

To actually run the project as-is, you will need to install the dependencies using the following commands in the command line:

```bash
cd my-react-app
npm install
```

The `cd my-react-app` command ensures that you change to the correct directory where your project is located.

The `npm install` command is used to install the dependencies needed to properly run your React project. Dependencies are libraries or packages that your React project requires in order to function correctly, such as React itself, ReactDOM, or other third-party packages that provide additional functionality.

Running `npm install` will read the `package.json` file in your project directory and install all the dependencies listed there, allowing you to build and run your React app without missing any necessary components.

The `package.json` file is a key configuration file in projects that contains metadata about your project, including its name, version, and dependencies. It also defines scripts, licensing information, and other settings that help manage the project and its dependencies.

Once the dependencies are installed, you should notice a new folder in your project called `node_modules`.

The `node_modules` folder is where all the packages and libraries required by your project are stored. This folder contains the actual code for the dependencies listed in your `package.json` file, including both your project's direct dependencies and any dependencies of those dependencies.

To run your project, run the `npm run dev` command and open up a new browser tab at `http://localhost:5173/`.

You should see the starter template that Vite has provided for you.

If you need to stop the local server, press `CTRL + C` in the command line.

To actually see the code for this starter template, you can go into your project inside the `src` folder and you should see the `App.jsx` file.

From there you can start to modify the file, save your changes and see the new changes display in the browser.

And with that, you're ready to begin building your React application!


### Lecture Block: Lecture Working With Data In React


## How Do You Pass Props from a Parent Component to a Child Component in React?

### Description

In the previous lectures, we learned how to build small components in React like this:

```jsx
function Greeting() {
  const developerName = "Jessica";
  return <h1>Hi {developerName}!</h1>;
}
```

We can choose to nest this component inside another parent component or the root component like this:

```jsx
function App() {
  return <Greeting />;
}

function Greeting() {
  const developerName = "Jessica";
  return <h1>Hi {developerName}!</h1>;
}
```

While this code will run fine and display the result of `Hi Jessica!` on the screen, it is not that flexible of a component. 

What if we wanted to display a different name like Naomi, Tom, or Oliver? This is where React props comes in. Props, which is short for properties, is the way for parent components to pass data down to the child component. Props can be of any type: strings, numbers, booleans, objects, or arrays.

Let's update our example from earlier to now accept a `name` prop:

```jsx
function App() {
  return <Greeting name="Jessica" />;
}

export default App;

function Greeting(props) {
  console.log(props);
  return <h1>Hi {props.name}!</h1>;
}
```

For the child component called `Greeting` we are now using `props.name` instead of hardcoding the name `"Jessica"`. We are also logging `props` to the console which is showing as an object.

Then, inside of the parent `App` component, we are passing the value to the `name` prop so it can be passed down to the child. The result will be the same on the screen like earlier, but now we have created a more flexible component.

Now we have the ability to reuse the child component several times and pass in different names each time:

```jsx
function App() {
  return (
    <>
      <Greeting name="Naomi" />
      <Greeting name="Tom" />
      <Greeting name="Jessica" />
      <Greeting name="Oliver" />
    </>
  );
}
```

You can also choose to use object destructuring in the props to make it more readable. Here's how you could rewrite the `Greeting` component:

```jsx
function Greeting({ name }) {
  return <h1>Hi {name}!</h1>;
}
```

This code achieves the same result but makes it clearer which props the component is expecting to receive.

Sometimes, you can have a lot of properties that you have to pass as props. Instead of passing them one by one, you can use the spread operator (`...`), after converting them to an object. 

Here is an example of a new child component called `DeveloperCard`:

```jsx
function DeveloperCard({ name, age, country }) {
  return (
    <div className="developer-card">
      <h1>Developer: {name}</h1>
      <p>Age: {age}</p>
      <p>Country: {country}</p>
    </div>
  );
}
```

This `DeveloperCard` component accepts three props: `name`, `age`, and `country`. 

In the parent `App` component, we can use the spread syntax to pass all the properties from an object as individual props to the child component:

```jsx
function App() {
  const developerObj = {
    name: "Alice",
    age: 30,
    country: "USA",
  };

  return (
    <div className="App">
      <DeveloperCard {...developerObj} />
    </div>
  );
}
```

This is particularly useful when working with arrays of objects and passing multiple sets of properties to child components. For example, you might have a list of developers where each object in the array has the same structure but represents a different person.

You will learn more about how to render lists in arrays in future lectures.

Using props in React makes your components more flexible and reusable, allowing you to build more complex UIs. However, it's important to note that props are immutable, meaning they cannot be changed once passed to a component. If you need to handle user input and modify data, you should use state instead. You'll learn more about managing state in future lectures.


## How Does Conditional Rendering Work in React Components?

### Description

Conditional rendering in React allows you to create dynamic user interfaces. It is used to show different content based on certain conditions or states within your application.

The most common approaches of using conditional rendering includes using `if` statements, the ternary (`?:`) operator, and logical AND (`&&`) operator.

The simplest form of conditional rendering uses an `if` statement. Here's an example:

```jsx
function Greeting({ isLoggedIn }) {
  if (isLoggedIn) {
    return <h1>Welcome back!</h1>;
  }
  return <h1>Please sign in</h1>;
}
```

In this example, the `Greeting` component checks the `isLoggedIn` prop. If it's `true`, it returns a welcome message, otherwise, it prompts the user to sign in.

Here is an example using the `Greeting` component inside of the parent `App` component:

```jsx
function App() {
  return (
    <div className="App">
      <Greeting isLoggedIn={false} />
    </div>
  );
}
```

For simpler conditions, the ternary operator (`?:`) is often used directly within JSX. It allows for inline conditional rendering, which can make your code more concise:

```jsx
function Greeting({ isLoggedIn }) {
  return <h1>{isLoggedIn ? "Welcome back!" : "Please sign in."}</h1>;
}
```

This code achieves the same result as the previous example but in a more compact form. The ternary operator checks `isLoggedIn` and renders the appropriate message.

Another common pattern for conditional rendering is using the logical AND (`&&`) operator. This is particularly useful when you want to render something, or nothing, based on a condition:

```jsx
function Notification({ message }) {
  return (
    <div>
      {message && <p>{message}</p>}
    </div>
  );
}
```

In this example, the paragraph element with the message is only rendered if the `message` prop is truthy. If `message` is falsy - meaning it is an empty string, `null`, or `undefined`, nothing is rendered to the screen.

By mastering these techniques of conditional rendering, you can build more interactive and user-friendly applications that adapt to changing data and user interactions.


## How Do You Render Lists in React?

### Description

Rendering lists is a fundamental task in React web apps, and is used for displaying data to users. In React, the `map` method is used to transform an array of data into an array of JSX elements that can be rendered in the UI.

Here is an example of a component called `FruitList` that displays a list of fruits:

```jsx
function FruitList() {
  const fruits = ['Apple', 'Banana', 'Cherry', 'Date'];
  return (
    <ul>
      {fruits.map(fruit => <li>{fruit}</li>)}
    </ul>
  );
}
```

In this example, the `map` function iterates over each item in the `fruits` array. For each fruit, it creates a new `li` element containing the fruit's name. The newly created array of `li` elements is then displayed inside the `ul` parent tags.

However, when rendering lists in React, it is important not to forget the `key` prop for each element in the list. The key must always be unique and it helps React identify which items have changed, been added, or been removed, which is essential for efficient rendering and updating the list. 

Let's modify our example to include keys:

```jsx
function FruitList() {
  const fruits = ["Apple", "Banana", "Cherry", "Date"];
  return (
    <ul>
      {fruits.map((fruit, index) => (
        <li key={`${fruit}-${index}`}>{fruit}</li>
      ))}
    </ul>
  );
}
```

In this refactored example, we are creating a unique key for each list item by concatenating the fruit name with its index. This ensures that each list item has a distinct key, which helps React efficiently manage and update the list when items are added, removed, or reordered.

React also allows you to render more complex structures. For instance, you might have an array of objects representing users, each with multiple properties that you want to display:

```jsx
function UserList() {
  const users = [
    { id: "user-001-employee", name: "Alice", email: "alice@example.com" },
    { id: "user-002-employee", name: "Bob", email: "bob@example.com" },
    { id: "user-003-employee", name: "John", email: "john@example.com" },
  ];
  return (
    <div>
      {users.map((user) => (
        <div key={user.id}>
          <h3>{user.name}</h3>
          <p>{user.email}</p>
        </div>
      ))}
    </div>
  );
}
```

In this example, we're creating a more complex JSX structure for each user, displaying both their name and email address. We're using the user's `id` as the `key`, which is a good practice.

In conclusion, rendering lists in React involves converting arrays of data into JSX elements, typically using the `map` function.


## How Do Inline Styles Work in React?

### Description

In React, inline styles are used to apply CSS styles directly to React elements within your JSX code instead of defining them in separate CSS files.

React's approach to inline styles involves using JavaScript objects to define styles, rather than traditional CSS strings. This means that instead of writing styles as you would in a CSS file, you create a JavaScript object where the keys are camel cased versions of CSS property names, and the values are the strings of CSS values.

Here is an example of how you can use inline styles for a `Button` component:

```jsx
function Button({ buttonText }) {
  const defaultStyles = {
    backgroundColor: "#007BFF",
    color: "white",
    border: "none",
    borderRadius: "4px",
    padding: "10px 20px",
    fontSize: "16px",
    fontWeight: "bold",
    cursor: "pointer",
    transition: "background-color 0.3s ease",
  };

  return <button style={defaultStyles}>{buttonText}</button>;
}
```

In this example, we define a style object called `defaultStyles`. We then apply these styles to a button element using the `style` attribute. React takes care of applying these styles to the element when it renders.

You can also choose to pass in an object directly to the `style` attribute. Here is what a revised example would look like:

```jsx
function Button({ buttonText }) {
  return (
    <button
      style={{
        backgroundColor: "#007BFF",
        color: "white",
      }}
    >
      {buttonText}
    </button>
  );
}
```

Sometimes you might want to pass in an object directly if there are only a few properties like shown here. Otherwise, passing in a name to an object would be better like in the first example.

It's important to note that while CSS property names are typically written in kebab case, like `font-size`, in React's inline styles, we use camel case, like `fontSize`. This is because the style object is a JavaScript object, and kebab case names are not valid as object keys in JavaScript without using quotes.

A great advantage of inline styles in React is that they support dynamic styling based on a component state or props. For example:

```jsx
function DynamicButton({ isActive }) {
  const buttonStyles = {
    backgroundColor: isActive ? "green" : "red",
    color: "white",
    padding: "10px 15px",
    border: "none",
    cursor: "pointer",
  };

  return <button style={buttonStyles}>Login</button>;
}
```

In this example, the button's background color changes based on the `isActive` prop. This kind of dynamic styling can be powerful for creating interactive and responsive user interfaces.

In summary, inline styles in React provide a powerful way to apply and manipulate styles directly within your components. They use JavaScript objects instead of CSS strings, require camel cased property names, and can easily incorporate dynamic values. They're an essential tool in a React developer's toolkit, especially for creating highly customized and interactive user interfaces.


## Module: React State Hooks And Routing


### Lecture Block: Lecture Working With State And Responding To Events In React


## How Do Events Work in React?

### Description

Event handling is an essential part of every interactive website.

React provides a powerful and consistent way to handle events through its Synthetic Event System, which is a wrapper around native events like `click`, `keydown`, and `submit` you learned about in earlier lectures.

This cross-browser wrapper ensures that events work the same across all browsers so there are no inconsistencies.

Let's see how events work in React so you can start using them in your projects.

In React, event handlers work in a similar way to native browser events, but with a few tweaks.

Instead of using lowercase event attribute names like `onclick` and `onsubmit`, React uses camelCase, like `onClick` and `onSubmit`.

In addition, instead of using strings to specify the kind of event, React expects a function for the event handler.

The event handler function is passed to the element as a prop, and the event type like `onClick` or `onSubmit` is used as an attribute in JSX.

Here is a reminder of how to work with a click event in regular HTML:

```html
<button onclick="alert('Button clicked!')">Click Me</button>
```

And here is how you do the same in React:

```jsx
function handleClick() {
  console.log("Button clicked!");
}

<button onClick={handleClick}>Click Me</button>;
```

In this example, `handleClick` logs a message to the console when the user clicks the button.

Note that you don't need parentheses after `handleClick` in the `onClick` attribute, as you're passing a reference to the function, not calling it.

In React, event handler functions usually start with the prefix `handle` to indicate they are responsible for handling events, like `handleClick` or `handleSubmit`.

When a user action triggers an event, React passes a Synthetic Event object to your handler. This object behaves much like the native event object in vanilla JavaScript, providing properties like `type`, `target`, and `currentTarget`.

You can pass `event` as a parameter to the handler function and log it to the console to take a look at its structure:

```js
function handleClick(event) {
  console.log(event);
}
```

To prevent default behaviors like browser refresh during an `onSubmit` event, for example, you can call the `preventDefault()` method:

```jsx
function handleSubmit(event) {
  event.preventDefault();
  console.log("Form submitted!");
}

<form onSubmit={handleSubmit}>
  <input type="text" />
  <button>Submit</button>
</form>;
```

You can also stop an event from bubbling up to parent elements by calling `event.stopPropagation()`.

Sometimes, while handling special cases like delete and edit features, you might want to pass extra data to an event handler. You can do this by wrapping the handler in an inline arrow function:

```jsx
function handleDelete(id) {
  console.log("Deleting item:", id);
}

<button onClick={() => handleDelete(1)}>Delete Item</button>;
```

It's fine to use inline event handlers in React because React efficiently manages re-renders and avoids performance issues. 

In vanilla JavaScript, inline event handlers can lead to performance issues by creating new functions on every render, as there is no virtual DOM to optimize the process.


## What is State, and How Does the useState Hook Work?

### Description

State is one of the most important fundamentals of React and other frontend frameworks. It's like the brain of a component, meaning it holds information that can change over time and controls how the components behave and look.

Let's look into what state is and how the `useState` hook lets you work with it.

State represents the dynamic data in your React component, like the value from a user input, data fetched from an API, or an item in a to-do list.

Whenever the state changes, React re-renders the component without reloading the page to reflect those changes in the user interface. This reactivity makes your app interactive.

The `useState` hook is a function that lets you declare state variables in functional components. 

Before hooks, you could only use state in class components. But with the introduction of hooks since React 16.8, you can use state in functional components by using the `useState` hook.

To use the `useState` hook, you need to import it from React:

```js
import { useState } from "react";
```

You can also import React itself and get access to the `useState` hook as a property:

```js
import React from "react";
```

Here's how you can declare a state variable when you import `useState`:

```js
const [stateVariable, setStateFunction] = useState(initialValue);
```

And here's how you can declare a state variable when you import React:

```js
const [stateVariable, setStateFunction] = React.useState(initialValue);
```

In the state variable you have the following:

- `stateVariable` holds the current state value
- `setStateFunction` (the setter function) updates the state variable
- `initialValue` sets the initial state

Note that the state in a React component is private, and is isolated to each component instance. This means that, if you render the same component twice, the state component of one does not affect the other. This also means that, if you'd like to share state between components, then you'd need to lift the state up to a common parent and pass it down as props.

Another thing is that hooks must be called at the top level of a component, just before the `return` keyword, to keep the state and effects consistent across renders. This means you can't use state inside loops, conditions, or nested functions.

Here's an example of managing state with the `useState` hook in a `Counter` component:

```jsx
// Importing the useState hook
import { useState } from "react";

function Counter() {
  const initialValue = 0;

  // The state variable and setter function
  const [count, setCount] = useState(initialValue);

  return (
    <div>
      {/* Display current state value */}
      <h2>{count}</h2>

      <button onClick={() => setCount(count - 1)}>Decrement</button>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

export default Counter;
```

In the code above, we have the `useState` hook imported from React. In the `Counter` component, the `count` represents the current state while `setCount` is the set function responsible for updating state. The current state value is `0`. The `return` statement contains the count and two buttons to decrement and increment the count by `1`.

You can manage multiple pieces of state by calling the `useState` hook multiple times. This is especially important when you have unrelated state variables:

```jsx
function UserProfile() {
  const [isOnline, setIsOnline] = useState(false);
  const [notifications, setNotifications] = useState(0);

  // The rest of the component logic
}
```

You can also call the `useState` hook multiple times when managing multiple states that update separately, like form fields:

```jsx
function SignUpForm() {
  const [name, setName] = useState("");
  const [username, setUsername] = useState("");
  const [email, setEmail] = useState("");

  // The rest of the component logic
}
```

But in this case, it's best to combine the states since they're all part of the same form:

```jsx
function SignUpForm() {
  const [formData, setFormData] = useState({
    name: "",
    username: "",
    email: "",
  });

  // The rest of the component logic
}
```

That's what state is and how you can use the `useState` hook.


## What Is Rendering in React, and How Are Components Displayed on the Screen?

### Description

In React, rendering is the process by which components appear in the user interface (UI), usually the browser.

React takes all your JavaScript, JSX, and CSS code, figures out how it should look, and then displays it in the user interface.

The rendering process consists of three stages: trigger, render, and commit. Let's take a look at these in more detail.

The trigger stage occurs when React detects that something has changed and that the user interface might need to be updated. This change is often due to an update in the state or props.

For instance, noticing that it's time for dinner can trigger you to go into the kitchen to start cooking.

In the `Counter` example below, clicking the increment or decrement button triggers React to show the new `count` value:

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h1>{count}</h1>
      <button onClick={() => setCount(count - 1)}>Decrement</button>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

export default Counter;
```

Once the trigger happens, React enters the render stage. Here, React re-evaluates your components and figures out what to display.

To do this, React uses a lightweight copy of the "real" DOM. This is called the virtual DOM. With the virtual DOM, React can quickly check what needs to change in the component.

Think of this stage as the point where you're in the kitchen, you've gathered your ingredients, and you cook your dinner.

For the `Counter` component, the render stage is the point where React runs the functions again with the new `count` value. React recalculates what the `<h1>{count}</h1>` part of the component should look like based on the updated `count` value, but you won't see any changes on the screen until the next stage – commit.

The commit stage is where React takes the prepared changes from the virtual DOM and applies them to the real DOM. In other words, this is the stage where you see the final result on the screen.

To make this happen, React compares the virtual DOM to the actual DOM, identifies only the parts that need updates, and applies those changes to the real DOM to update the user interface.

You can think of this stage as the point where you serve the food you cooked, making it visible just like React does when it commits updates to the actual DOM.

As for the `Counter` component, the commit stage is the point in which the new `count` value is applied to the `h1` element, and you can see the change on the page.

These three processes are extremely fast because React minimizes direct DOM manipulation by calculating changes in the virtual DOM first, then it updates only the parts that need to change in the real DOM.


## How Do You Update Objects in State?

### Description

Updating objects in state in React can be tricky if you're used to changing object property values directly.

React treats state as immutable, meaning you should not modify it directly.

Let's look at what happens if you try to change objects in React state directly, and then dive into the correct way to do it.

Let's say you have an object in your component state that represents a user's profile, and you want the user to update their age: 

```jsx
import { useState } from "react";

function Profile() {
  const [user, setUser] = useState({
    name: "John Doe",
    age: 31,
    city: "LA",
  });

  // Change user age directly
  const handleAgeChange = (e) => {
    user.age = e.target.value;
    console.log(user);
  };

  return (
    <div>
      <h1>User Profile</h1>
      <p>Name: {user.name}</p>
      <p>Age: {user.age}</p>
      <p>City: {user.city}</p>

      <h2>Update User Age </h2>
      <input type="number" value={user.age} onChange={handleAgeChange} />
    </div>
  );
}

export default Profile;
```

This code will not work because you're directly modifying the `user.age` property.

Even though `console.log(user)` will show the new age in the console, React won't re-render the component to show it in the user interface because you didn't use the setter function, `setUser`.

To update an object directly in the state, you need to use the setter function to create a new object with the updated value. For example:

```js
const handleAgeChange = (e) => {
  setUser({
    age: e.target.value,
  });
};
```

That works. But if you look at the page now, the user's age gets updated, but the values for the name and city are lost.

This is because the new object you passed to the setter function only contained a key/value pair for `age`.

To prevent this from happening, you can copy the existing object first, then update only the property you want to update, in this case, `age`.

To do this, you can pass a special function called an updater function to your setter function, `setUser`. The updater function takes the pending state as an argument, here, called `prevUser`, and should return the next state:

```js
const handleAgeChange = (e) => {
  setUser((prevUser) => {
    const updatedUser = { ...prevUser, age: e.target.value };
    console.log('Previous State:', prevUser);
    console.log('Updated State:', updatedUser);
    return updatedUser;
  });
};
```

As you can see, we create a new user object called `updatedUser` by using the spread syntax to copy the pending user object, `...prevUser`. We then update the age based on the form input and return `updatedUser` at the bottom of the function as the next state.

Now your project works as expected, and updates to the age input don't affect the user's name or city name. You can also see the previous and updated states in the console.

This is the ideal way to update an object in state, especially when you're not updating all the properties.

To update the remaining `name` and `city` properties, you can write them as separate setting functions and connect them to their respective inputs:

```js
const handleNameChange = (e) => {
  setUser((prevUser) => ({
    ...prevUser,
    name: e.target.value,
  }));
};

const handleCityChange = (e) => {
  setUser((prevUser) => ({
    ...prevUser,
    city: e.target.value,
  }));
};
```

Or you can combine them into a single setter function like this:

```js
const handleChange = (e) => {
  const { name, value } = e.target;
  setUser((prevUser) => ({
    ...prevUser,
    [name]: value,
  }));
};
```

To make this work, each input field has to have a `name` attribute.

Here's the full code now:

```jsx
import { useState } from "react";

function Profile() {
  const [user, setUser] = useState({ name: "John Doe", age: 31, city: "LA" });

  const handleChange = (e) => {
    const { name, value } = e.target;

    setUser((prevUser) => ({...prevUser, [name]: value}));
  };

  return (
    <div>
      <h1>User Profile</h1>
      <p>Name: {user.name}</p>
      <p>Age: {user.age}</p>
      <p>City: {user.city}</p>

      <h2>Update User Age </h2>
      <input type="number" name="age" value={user.age} onChange={handleChange} />

      <h2>Update User Name </h2>
      <input type="text" name="name" value={user.name} onChange={handleChange} />

      <h2>Update User City </h2>
      <input type="text" name="city" value={user.city} onChange={handleChange} />
    </div>
  );
}

export default Profile;
```


## How Do You Update Arrays in State?

### Description

In React, updating arrays in state is quite straightforward, but it can be easy to make a mistake, especially if you're coming from vanilla JavaScript where you can modify arrays directly.

In React, state is treated as immutable so it can recognize changes and make the proper updates to the user interface.

Let's look at how you can update arrays held in state in React.

One of the most common mistakes when updating arrays in a React state is to directly modify the array using methods like `push()`, `pop()`, or `splice()`. These methods mutate the original array, and React does not allow that.

React relies on a new array reference to detect changes, so directly modifying the array can prevent the component from re-rendering as expected.

Here's an example of using the `push()` method to add to an array in state, which won't work:

```jsx
import { useState } from "react";

function ItemsList() {
  const [items, setItems] = useState([
    { id: 0, name: "Item 1" },
    { id: 1, name: "Item 2" },
    { id: 2, name: "Item 3" },
  ]);

  const addItem = () => {
    const newItem = { id: items.length + 1, name: `Item ${items.length + 1}` };
    items.push(newItem); // This modifies the original array
    setItems(items); // React will not detect this change
  };

  return (
    <div>
      <button onClick={addItem}>Add Item</button>
      <ul>
        {items.map((item) => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
    </div>
  );
}

export default ItemsList;
```

If you click the `Add Item` button, nothing happens in the user interface.

It might also be tempting to remove items from the array with the `pop()` method:

```js
const removeItem = () => {
  items.pop(); // Modifies the original array
  setItems(items); // React will not detect this change, either
};
```

To update an array in state, the key is to create a new array, do your operations, and pass that to React, rather than mutate the existing array.

Because it's a new array, React will know that the state has been changed, and trigger a re-render.

Here's how you can add to the `items` array using the spread operator:

```js
const addItem = () => {
  const newItem = {
    id: items.length + 1,
    name: `Item ${items.length + 1}`,
  };

  // Creates a new array
  setItems((prevItems) => [...prevItems, newItem]);
};
```

`[...prevItems, newItem]` creates a new array by copying all items in the existing `items` array held in state, then adds `newItem` at the end, which increments the `id` and the item number.

If you want to remove something from the array, you can use the `filter()` method, which returns a new array after filtering out whatever you want to remove:

```js
const removeItem = (id) => {
  setItems((prevItems) => prevItems.filter((item) => item.id !== id));
};
```

Here's the full code:

```jsx
import { useState } from "react";

function ItemsList() {
  const [items, setItems] = useState([
    { id: 0, name: "Item 1" },
    { id: 1, name: "Item 2" },
    { id: 2, name: "Item 3" },
  ]);

  const addItem = () => {
    const newItem = { id: items.length + 1, name: `Item ${items.length + 1}` };
    setItems((prevItems) => [...prevItems, newItem]); // Creates a new array
  };

  const removeItem = (id) => {
    setItems((prevItems) => prevItems.filter((item) => item.id !== id)); // Creates a new array
  };

  return (
    <div>
      <button onClick={addItem}>Add Item</button>
      <ul>
        {items.map((item) => (
          <li key={item.id}>
            {item.name}{" "}
            <button onClick={() => removeItem(item.id)}>Remove</button>
          </li>
        ))}
      </ul>
    </div>
  );
}

export default ItemsList;
```

Those are some common ways you can update an array in state.


### Lecture Block: Lecture Understanding Effects And Referencing Values In React


## How Do You Reference Values Using Refs?

### Description

In React, there may be situations where you need direct access to a DOM element. That's where "refs" come in handy. Refs can also store mutable values, but state is a better choice for that. 

In vanilla JavaScript, you used the `getElementById()` and `querySelector()` methods to access DOM elements. But in React, you use refs to access elements in the DOM.

One of the main differences is that, with refs, you don't need identifiers like IDs and classes to reference elements.

So, how can you create and use refs? React provides a `useRef()` hook that lets you do just that. 

The first step is to import the hook from React:

```js
import { useRef } from "react";
```

Next, you need to create a variable that holds the ref with the initial value of the ref inside the `useRef` hook, say a `sectionRef` initialized to `null`:

```js
const sectionRef = useRef(null);
```

The final thing to do is to attach the ref variable to the element in your JSX by using the `ref` attribute:

```jsx
<section ref={sectionRef}>
  {/* Section content */}
</section>
```

If you log the ref to the console, you'll see it's an object with the current value, in this case, `null`:

```js
console.log(sectionRef); // { current: null }
```

You can also log the current value to the console with the `current` property so you can see the value directly:

```js
console.log(sectionRef.current); // null
```

The subsequent values of the ref depend on the component lifecycle. 

For example, the initial value of `sectionRef` will always be `null` because that's what it was initialized to. After the component is mounted, the value of the ref will be the `section` element the ref is attached to.

If the component is unmounted, the ref's value goes back to the initial value of `null`.

A typical example to showcase a ref is to focus an input element on render, or by clicking a button.

Here's how to do that when you click a button:

```jsx
import { useRef } from "react";

const Focus = () => {
  const inputRef = useRef(null);

  const handleFocus = () => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };

  return (
    <div>
      <input ref={inputRef} type="text" placeholder="Enter text" />
      <button onClick={handleFocus}>Focus Input</button>
    </div>
  );
};

export default Focus;
```

In the code above, the `inputRef` is created and attached to the `input` element. There's also a button with an `onClick` event that calls a `handleFocus` function.

All the `handleFocus` function does is call the `focus()` method on the `input` element. Note that, because `input` is a built-in component that comes with React, the actual `input` DOM element is set to the `current` property of the ref. So you call the `focus()` method with `input.current.focus()`.

Here are some best practices you should be aware of while working with refs:

- Use refs mainly to interact with the DOM. You can also use them for mutable data, but state is a better choice for that.

- Don't use refs for basic state management – that is what `useState` is for.

- Make sure you check that `ref.current` exists before accessing its properties. Here's how to do that again:

```js
const handleFocus = () => {
  if (inputRef.current) {
    inputRef.current.focus();
  }
};
```

This prevents errors in case the ref is accessed before it is attached to the DOM or after it is removed.


## What Are Effects in React, and How Does the useEffect Hook Work?

### Description

In React, an effect is anything that happens outside the component rendering process. That is, anything React does not handle directly as part of rendering the UI.

Common examples include fetching data, updating the browser tab's title, reading from or writing to the browser's local storage, getting the user's location, and much more. These operations interact with the outside world and are known as side effects.

React provides the `useEffect` hook to let you handle those side effects. `useEffect` lets you run a function after the component renders or updates.

Let's see how the `useEffect` hook works and why it's essential for modern React development.

To use the `useEffect` hook, you first need to import it:

```js
import { useEffect } from "react";
```

Then you use it as a function, like this:

```js
useEffect(() => {
  // Your side effect logic (usually a function) here
}, [dependencies]);
```

The effect function runs after the component renders, while the optional `dependencies` argument controls when the effect runs.

Note that `dependencies` can be an array of "reactive values" (state, props, functions, variables, and so on), an empty array, or omitted entirely. Here's how all of those options control how `useEffect` works:

- If `dependencies` is an array that includes one or more reactive values, the effect will run whenever they change.

- If `dependencies` is an empty array, `useEffect` runs only once when the component first renders.

- If you omit `dependencies`, the effect runs every time the component renders or updates.

For example, in this `Counter` application, we don't pass in a `dependencies` argument, so the effect runs when the component renders and every time it updates:

```jsx
import { useState, useEffect } from "react";

const Counter = () => {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log("Component renders");
  });

  return (
    <div
      style={{
        display: "flex",
        alignItems: "center",
        flexDirection: "column",
      }}
    >
      <h2>{count}</h2>
      <div>
        <button onClick={() => setCount(count + 1)}>Increase</button>
        <button onClick={() => setCount(count - 1)}>Decrease</button>
      </div>
    </div>
  );
};

export default Counter;
```

But if we pass in an empty array as a dependency, the effect only runs on the first render:

```js
useEffect(() => {
  console.log('Component renders');
}, []);
```

If you pass in the `count` state as a dependency, the effect runs when the component first render, and when `count` changes:

```js
useEffect(() => {
  document.title = `The current count is ${count}`;
  console.log('component renders');
}, [count]);
```

Note that, if the effect you set up persists beyond the component's rendering lifecycle, you might need another function to "clean up" that function after the component renders or updates.

For example, if your effect function uses `setInterval()`, sets an event listener like `window.addEventListener()`, or connects to a server, you'll need a cleanup function to run `clearInterval()`, `window.removeEventListener()`, and disconnect from the server, respectively.

Here's the syntax for returning a cleanup function from the `useEffect` hook:

```js
useEffect(() => {
  // Your side effect logic here
  return () => {
    // Cleanup logic here (optional)
  };
}, [dependencies]);
```

For instance, if you add a scroll event listener, you can clean it up by removing it in your cleanup function:

```js
useEffect(() => {
  const handleScroll = () => {
    // Handle scroll logic
  };
  window.addEventListener("scroll", handleScroll);

  return () => {
    window.removeEventListener("scroll", handleScroll);
  };
}, []);
```


## How Can You Create Custom Hooks in React?

### Description

React provides many built-in hooks that let you implement different features in your projects. These include `useState`, `useEffect`, `useContext`, and others.

But sometimes, you'll need to add a feature that none of the built-in hooks can help with. Fortunately, you can create your own custom hooks in React.

Custom hooks are not as complicated as they might seem. They're just reusable functions that let you share logic across multiple components. That means reusability is another reason why you would want to build your own hook.

With a custom hook, you can extract logic away from any components that use them, like data fetching, state management, toggling, side effects like checking for the online or offline status of users, and so on. 

You can then import the hook to use in any component, so you can focus on rendering and presentation within those components. That means fewer repetitions and less duplication, which means fewer places to make changes when you want to make any updates.

Now, let's take a look at how you can make your own custom hook.

In React, all built-in hooks start with the word `use`, so your custom hook should follow the same convention. Your custom hook's name should also clearly communicate what it does.

So, if your custom hook…

- fetches data, you can call it `useFetch`

- toggles something on and off, you can call it `useToggle`

- or if it implements debouncing, `useDebounce` is a good name

Let's say you want to build a custom hook to add debouncing to your app.

Debouncing is a programming technique that limits how often a function runs. It works by waiting until a user stops performing an action for a specified period of time before executing the function. For example, in a search box, instead of making an API call for every keystroke, debouncing waits until the user pauses typing for, say, 500 milliseconds.

To create a debouncing custom hook, you first need to create a `useDebounce.jsx` or `useDebounce.js` file. Conventionally, files for any custom hooks you create are saved to a `hooks` folder.

You can use some built-in hooks within your own custom hook. For debouncing, you need the `useState` and `useEffect` hooks, so import them at the top of your file:

```js
import { useState, useEffect } from "react";
```

Next, create a `useDebounce` function that takes `value` and `delay` as parameters. `value` is the resource you want to wait for, and `delay` is the period of time you want to wait for. Since you want to wait for some period of time, the `setTimeout` and `clearTimeout` functions would be useful:

```js
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

export { useDebounce };
```

The `debouncedValue` state holds and returns the delayed value, which only updates after the specified timeout period.

`useEffect` is where the magic really happens. If you recall from the previous lecture, anything that exists outside the React rendering cycle, like setting and clearing a timer, is a side effect, and you should use the `useEffect` hook to handle them.

Within the `useEffect` hook here, you use `setTimeout` to set the `debouncedValue`. You then return a cleanup function that uses `clearTimeout` to clear the previous timeout whenever `value` or `delay` changes, or the component unmounts.

To use this hook, we've prepared a `footballers` array to filter through with a simple search bar:

```js
const footballers = [
  'Lionel Messi', 'Cristiano Ronaldo', 'Neymar Jr',
  'Kylian Mbappe', 'Mohamed Salah', 'Sadio Mane',
  'Kevin De Bruyne', 'Robert Lewandowski', 'Harry Kane',
  'Sergio Ramos', 'Virgil van Dijk', 'Alisson Becker', 
  'Joshua Kimmich', 'Manuel Neuer', 'Karim Benzema', 
  'Thibaut Courtois', 'Eden Hazard', 'Raheem Sterling',
  'Bruno Fernandes', 'Trent Alexander-Arnold', 'Son Heung-min',
  'Pierre-Emerick Aubameyang','Sergio Aguero', 'Luis Suarez', 
  'Luka Modric', 'Casemiro', 'Frenkie de Jong', 'Gerard Pique',
  'Marc-Andre ter Stegen', 'Keylor Navas', 'Angel Di Maria', 
  "N'Golo Kante", 'Kai Havertz', 'Timo Werner', 'Hakim Ziyech', 
  'Christian Pulisic', 'Mason Mount', 'Olivier Giroud', 'Tammy Abraham', 
  'Kepa Arrizabalaga', 'Ben Chilwell', 'Thiago Silva', 'Kurt Zouma', 
  'John Terry', 'Didier Drogba', 'Frank Lampard', 'Ashley Cole', 'Petr Cech',
];

export default footballers;
```

And here's a `FootballerSearch` component that uses the `useDebounce` hook to delay searching for 1 second after the user stops typing:

```jsx
import { useState, useEffect } from "react";
import { useDebounce } from "./hooks/useDebounce";
import footballers from "./footballers";

const FootballerSearch = () => {
  const [query, setQuery] = useState("");
  const debouncedQuery = useDebounce(query, 1000); // Start searching 1 second after the user stops typing

  useEffect(() => {
    if (debouncedQuery) {
      const results = footballers.filter((footballer) =>
        footballer.toLowerCase().includes(debouncedQuery.toLowerCase()),
      );
      console.log("Search results:", results);
    } else {
      console.log("Search results: []");
    }
  }, [debouncedQuery]);

  return (
    <>
      <h1 style={{ textAlign: "center" }}>Footballer Search App</h1>
      <div style={{ textAlign: "center" }}>
        <input
          style={{ padding: "0.5rem", width: "30%" }}
          type="text"
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          placeholder="Search for a footballer..."
        />
      </div>
    </>
  );
};

export default FootballerSearch;
```

As you can see, the `debouncedQuery` variable is what initializes the `useDebounce` hook with the query state (what the user types), and the delay for 1,000 milliseconds, or 1 second. The search itself is handled inside the `useEffect` hook, and search results are logged to the console.


### Lecture Block: Lecture Working With Forms In React


## How Do Forms Work in React?

### Description

Forms are fundamental to every web application because they let you handle user input, collect data, and trigger actions.

In React, forms are managed using state or refs, giving you full control over their behavior and validation. These two ways to manage forms are called "controlled"  and "uncontrolled" input.

Let's look at what controlled and uncontrolled inputs are.

Controlled input is the most "React-like" way to handle form inputs. With controlled inputs, you store the input field value in state and update it through `onChange` events. This gives you complete control over the form data and allows instant validation and conditional rendering.

The process works like this: React maintains the form state with the `useState` hook, and you update it on every change. When a user types in an input field, the `onChange` event fires, updates the state, and React re-renders the component with the new value.

```jsx
import { useState } from "react";

function App() {
  const [name, setName] = useState("");

  const handleChange = (e) => {
    setName(e.target.value);
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log(name);
  };

  return (
    <>
      <form onSubmit={handleSubmit}>
        <label htmlFor="name">Your name</label> <br />
        <input value={name} id="name" onChange={handleChange} type="text" />
        <button type="submit">Submit</button>
      </form> 
    </>
  );
}

export default App;
```

The benefits of controlled inputs include the following:

- Immediate access to the form data.

- You can implement instant validation.

- You can conditionally disable the submit button.

- You can control the input value programmatically.

Uncontrolled inputs on the other hand are seen more in traditional HTML forms. So, instead of handling the inputs through the `useState` hook, uncontrolled inputs in HTML maintain their own internal state with the help of the DOM.

Since the DOM controls the input values, what you need is to pull in the values of the input fields with ref. This approach requires less code and performs better because refs do not make React re-render.

Here's an example of uncontrolled inputs:

```jsx
import { useRef } from "react";

function App() {
  const nameRef = useRef();

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log(nameRef.current.value);
  };

  return (
    <form onSubmit={handleSubmit}>
      <label htmlFor="name">Your</label>{" "}
      <input type="text" ref={nameRef} id="name" />
      <button type="submit">Submit</button>
    </form>
  );
}

export default App;
```

One very noticeable advantage of uncontrolled inputs is that they require less code. They also perform better and feel more natural to React beginners who are familiar with HTML.

So, which should you use between controlled and uncontrolled inputs? 

Use controlled inputs when you need dynamic form updates, real-time validation, or when you want to sync input values with state. They provide better control but require more re-renders.

Use uncontrolled inputs when you need simpler forms, want to access values only on submission, or when you're working with non-React code.

Regardless of which you use between controlled and uncontrolled inputs, here are some best practices you should adhere to while making forms in React:

- Always prevent the default form submission.

- Ensure you validate inputs before submission.

- Always provide clear feedback to users with loading, validation errors or other related states.


## What Is the useActionState Hook, and How Does It Work?

### Description

React 19 came with two notable new features called server components and server actions. 

From that version onwards, server components became the default in frameworks like Next.js that readily support them.

Server actions on the other hand, are functions that run on the server to allow form handling right on the server without the need for API endpoints.

A server action looks like this: 

```js
"use server";

async function submitForm(formData) {
  const name = formData.get("name");
  return { message: `Hello, ${name}!` };
}
```

This server action extracts a `name` field from a form and returns a string greeting that name.

To simplify state management for server actions and remove the need for client-side JavaScript for simple forms, the React team introduced the `useActionState` hook in version 19.

Let's take a closer look at this hook and see how it works.

The React documentation describes the `useActionState` hook as a hook that "allows you to update state based on the result of a form action."

But this doesn't mean that you can only use the `useActionState` hook with forms. You can also use it to manage button clicks and other events, as long as you have an action in place.

And keep in mind that, since `useActionState` is a hook, you cannot use it inside a server component.

Here's the basic syntax of the `useActionState` hook:

```js
const [state, action, isPending] = useActionState(actionFunction, initialState, permalink);
```

- `state` is the current state the action returns.

- `action` is the function that triggers the server action.

- `isPending` is a boolean that indicates whether the action is currently running or not.

- The `actionFunction` parameter is the server action itself.

- `initialState` is the parameter that represents the starting point for the state before the action runs.

- `permalink` is an optional string that contains the unique page URL the form modifies.

To use the `useActionState` hook, make sure you have an action in place first. Let's use the action from the previous example for this, with a bit of a twist:

```js
"use server";

export async function submitForm(_, formData) {
  const name = formData.get("name");

  const hour = new Date().getHours();
  let greeting;

  if (hour < 12) {
    greeting = "Good morning";
  } else if (hour < 18) {
    greeting = "Good afternoon";
  } else {
    greeting = "Good evening";
  }

  return { message: `${greeting}, ${name}` };
}
```

In your component, you then need to import the `useActionState` hook and call it at the top level of the component body (before the return statement) just like other hooks. You should also import the action:

```jsx
"use client";

// Import the useActionState hook
import { useActionState } from "react";

// Import the submitForm action
import { submitForm } from "./actions/submitForm";

const Greeter = () => {

 // Initialize the hook
 const [state, submit, isPending] = useActionState(submitForm, {
   message: "",
 });

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gray-100 p-6">
      {/* Rest of component */}
    </div>
  );
};

export default Greeter;
```

Here's what the full code looks like with a bit of styling:

```jsx
"use client";

import { useActionState } from "react";
import { submitForm } from "./actions/submitForm";

const Greeter = () => {
  const [state, submit, isPending] = useActionState(submitForm, {
    message: "",
  });

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gray-100 p-6">
      <form
        action={submit}
        className="bg-white p-6 rounded-2xl shadow-md w-full max-w-md"
      >
        <h2 className="text-2xl text-center font-semibold text-gray-700 mb-4">
          Greet Someone
        </h2>

        <input
          type="text"
          name="name"
          placeholder="Enter your name"
          required
          className="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-400"
        />

        <button
          type="submit"
          disabled={isPending}
          className="w-full mt-4 p-3 bg-green-500 text-white font-semibold rounded-lg hover:bg-green-600 disabled:bg-gray-400 transition-all"
        >
          {isPending ? "Greeting..." : "Greet"}
        </button>

        {state.message && (
          <p className="mt-4 text-green-600 text-center font-medium">
            {state.message}
          </p>
        )}
      </form>
    </div>
  );
};

export default Greeter;
```

In the browser, you would see your form button change from `Greet` to `Greeting...` while the action `isPending` - and the greeting would show `Good morning, {name}`, `Good afternoon, {name}`, or `Good evening, {name}`, depending on what time of day the form was submitted.

Remember how we mentioned that you can also use the `useActionState` hook outside of a form?

In this example, we'll fetch five users from JSONPlaceholder with a button click:

```js
"use server";

export async function getUsers() {
  const res = await fetch(
    "https://jsonplaceholder.typicode.com/users?_start=0&_limit=5/"
  );
  return await res.json();
}
```

Here's the styled UI:

```jsx
"use client";

import { useActionState } from "react";
import { getUsers } from "./actions/getUsers";

export default function FetchUsers() {
  const [users, fetchAction, isPending] = useActionState(getUsers, []);

  return (
    <div className="p-6 max-w-lg mx-auto">
      <button
        onClick={fetchAction}
        disabled={isPending}
        className="px-4 py-2 cursor-pointer bg-green-500 text-white rounded-lg hover:bg-green-600 disabled:bg-gray-400 font-bold"
      >
        {isPending ? "Fetching Users..." : "Fetch Users"}
      </button>

      <ul className="mt-4 space-y-2">
        {users.map((user) => (
          <li key={user.id} className="p-3 bg-gray-100 rounded-lg">
            <p className="font-semibold">{user.name}</p>
            <p className="text-sm text-gray-600">{user.email}</p>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

In the browser, you would see that the button text is never updated to `Fetching Users...` after it's clicked.

This happens because React treats data fetching and rendering as a higher priority than the `isPending` state, which blocks `isPending` in the process and throws an error.

To fix this issue, you need to wrap the action in `startTransition`:

```jsx
"use client";

// import startTransition from React
import { useActionState, startTransition } from "react";
import { getUsers } from "./actions/getUsers";

export default function FetchUsers() {
  const [users, fetchAction, isPending] = useActionState(getUsers, []);

  return (
    <div className="p-6 max-w-lg mx-auto">
      <button
        {/* wrap fetchAction in startTransition */}
        onClick={() => startTransition(() => fetchAction())}
        disabled={isPending}
        className="px-4 py-2 bg-green-500 font-bold cursor-pointer text-white rounded-lg hover:bg-green-600 disabled:bg-gray-400"
      >
        {isPending ? 'Fetching Users...' : 'Fetch Users'}
      </button>

      <ul className="mt-4 space-y-2">
        {users.map((user) => (
          <li key={user.id} className="p-3 bg-gray-100 rounded-lg">
            <p className="font-semibold">{user.name}</p>
            <p className="text-sm text-gray-600">{user.email}</p>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

If you're wondering what `startTransition` is, it's a function that tells React that a state update is of low-priority and can be interrupted. This keeps the UI responsive while handling asynchronous updates like server actions.

That's how to use the `useActionState` hook inside and outside a form.


### Lecture Block: Lecture Working With Data Fetching And Memoization In React


## How Does Data Fetching Work in React?

### Description

React apps often rely on external APIs and databases for dynamic content. To access the data from those APIs and databases, you need to use some data fetching techniques.

Let's take a look at how data fetching works in React and the different options available to you for fetching data.

React is not opinionated about how you fetch your data, this means on a basic level, you can use the built-in Fetch API, which all modern browsers support.

You can also use Axios and SWR. Axios is promise-based HTTP request library built on top of the XMLHttpRequest object, and SWR is a React hook for data fetching created by the Vercel team.

Let's start with an example. You first need to import the `useState` and `useEffect` hooks:

```js
import { useState, useEffect } from "react";
```

Then you will need to create three state variables called `loading`, `data`, and `error`:

```js
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);
```

The `loading` variable will track whether the data is still being fetched. The `data` variable represents the data itself, and the `error` variable will capture any errors that might occur during the data fetching process.

Since data fetching is a side effect, it's best to use the Fetch API inside of a `useEffect` hook.

Here's an example of that:

```js
useEffect(() => {
  fetch("https://jsonplaceholder.typicode.com/posts")
    .then((res) => res.json())
    .then((data) => {
      setData(data);
      setLoading(false);
    })
    .catch((err) => {
      setError(err);
      setLoading(false);
    });
}, []);
```

This `useEffect` fetches the data with the Fetch API and sets all the states. 

You can make things better by using `async`/`await` instead of the `.then()` syntax. That means you have to have a separate function inside the `useEffect` because you cannot prefix `useEffect` with the `async` keyword:

```js
useEffect(() => {
  const fetchData = async () => {
    try {
      const res = await fetch("https://jsonplaceholder.typicode.com/posts");
       
      if (!res.ok) {
        throw new Error("Network response was not ok");
      }

      const data = await res.json();
      setData(data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, []);
```

You can then go ahead and use all of those states to render the data from the API.

Here's the full code:

```jsx
import { useState, useEffect } from "react";

const FetchPosts = () => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const res = await fetch("https://jsonplaceholder.typicode.com/posts");
       
        if (!res.ok) {
          throw new Error("Network response was not ok");
        }

        const data = await res.json();
        setData(data);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, []);

  if (loading) {
    return <p>Loading...</p>;
  }

  if (error) {
    return <p>{error.message}</p>;
  }

  return (
    <ul>
      {data.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
};

export default FetchPosts;
```

In the UI, you would see `Loading...` on the screen when the data is being fetched, and then the data or error would show depending on if the data fetch was successful.

Remember we talked about data fetching with Axios and SWR too. Let's take a look at an example using Axios.

You will first need to install Axios from the command line like this:

```sh
npm i axios
```

Then you will need to import Axios like this:

```js
import axios from "axios";
```

Then you can use the same state variables from earlier and fetch data from the API using `axios.get`:

```js
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);

useEffect(() => {
  const fetchData = async () => {
    try {
      const res = await axios.get(
        "https://jsonplaceholder.typicode.com/users"
      );
      setData(res.data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, []);
```

You might have noticed that there is no `await res.json()` line in this example. That's because Axios automatically parses JSON, so there's no need for that.

The last example we will look at is to use the `useSWR` hook to fetch data.

Just like with Axios, you will need to install SWR like this:

```sh
npm install swr
```

Then you will need to import the `useSWR` hook into the file like this:

```js
import useSWR from "swr";
```

In comparison to the previous examples, the SWR syntax is way shorter. What you need to do is to create a fetcher function and pass it into the `useSWR` hook as its second parameter (the endpoint is the first parameter).

You also get to destructure both the data and error states from the `useSWR` hook, so you don't need the `useState` hook.

Here is the syntax:

```js
const fetcher = (url) => fetch(url).then((res) => res.json());
const { data, error } = useSWR(endpoint, fetcher);
```

Note that the "fetcher" name here is only a convention, so you're free to name the variable whatever you want.

Here's a component fetching todos from the JSON Placeholder API:

```jsx
import useSWR from "swr";

const fetcher = (url) => fetch(url).then((res) => res.json());

const FetchTodos = () => {
  const { data, error } = useSWR(
    "https://jsonplaceholder.typicode.com/todos",
    fetcher
  );

  if (!data) {
    return <h2>Loading...</h2>;
  }
  if (error) {
    return <h2>Error: {error.message}</h2>;
  }

  return (
    <>
      <h2>Todos</h2>
      <div>
        {data.map((todo) => (
          <h3 key={todo.id}>{todo.title}</h3>
        ))}
      </div>
    </>
  );
};

export default FetchTodos;
```

As you learned in a previous lecture on custom hooks, data fetching is a logic you can extract into a custom hook. So, if you're fetching data in multiple components and pages, it is best to create a `useFetch` hook.

Here's a `useFetch` hook that uses SWR for data fetching:

```jsx
import useSWR from "swr";

const fetcher = (url) => fetch(url).then((res) => res.json());

const useFetch = (url) => {
  const { data, error } = useSWR(url, fetcher);

  return {
    data,
    loading: !data && !error,
    error,
  };
};

export default useFetch;
```

And here's how to use the `useFetch` hook to rewrite the first example that fetches posts from the JSON Placeholder API:

```jsx
import useFetch from "./useFetch";

const FetchPosts = () => {
  const { data, loading, error } = useFetch(
    "https://jsonplaceholder.typicode.com/posts"
  );

  if (loading) {
    return <h2>Loading...</h2>;
  }

  if (error) {
    return <h2>{error.message}</h2>;
  }

  return (
    <>
      <h2>Posts</h2>
      <ul>
        {data.map((post) => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </>
  );
};

export default FetchPosts;
```


## What Is the useOptimistic Hook, and How Does It Work?

### Description

Recent versions of React introduced server components and server actions to shift some of the rendering and logic responsibilities to the server.

Along with those updates, React added a new hook called `useOptimistic` to keep UIs responsive while waiting for an async action to complete in the background.

While this is often used for fetching data from a server, it's not limited to that. The hook is generally useful for handling async operations, ensuring the UI remains smooth and interactive while the action runs.

Let's take a look at what the `useOptimistic` hook is and how it contributes to making snappy and responsive UIs. 

The `useOptimistic` hook helps manage "optimistic updates" in the UI, a strategy in which you provide immediate updates to the UI based on the expected outcome of an action, like waiting for a server response.

Here's the basic syntax of the `useOptimistic` hook:

```js
const [optimisticState, addOptimistic] = useOptimistic(actualState, updateFunction);
```

- `optimisticState` is the temporary state that updates right away for a better user experience.

- `addOptimistic` is the function that applies the optimistic update before the actual state changes.

- `actualState` is the real state value that comes from the result of an action, like fetching data from a server.

- `updateFunction` is the function that determines how the optimistic state should update when called.

At first glance, it might seem like the `useOptimistic` hook is just another way to handle loading states in React. But it's more than that.

A loading state controls whether you see a spinner, message, or some other indicator in the UI while something happens in the background. 

However, the `useOptimistic` hook updates the UI instantaneously based on an expected outcome, even before you, say, make a call to an API. This hook gives you a chance to show a loading indicator or message, handle potential errors gracefully, and show instant feedback to make the UI feel snappy.

This will become clearer as we go through some examples showing how the `useOptimistic` hook works.

Here's an action that simulates saving a task to a server. It returns the task after a 1 second delay, as it could happen with a real-world API request:

```js
export async function saveTask(task) {
  await new Promise((res) => setTimeout(res, 1000));

  return task;
}
```

Here's the code that sets up the `useOptimistic` hook by importing and initializing it, with an `handleSubmit` function that sends an input to the action:

```jsx
"use client";

import { useOptimistic } from "react";

export default function TaskList({ tasks, addTask }) {
  const [optimisticTasks, addOptimisticTask] = useOptimistic(
    tasks,
    (state, newTask) => [...state, { text: newTask, pending: true }]
  );

  async function handleSubmit(e) {
    e.preventDefault();
    const formData = new FormData(e.target);

    addOptimisticTask(formData.get("task"));

    addTask(formData);
    e.target.reset();
  }

  return <>{/* UI */}</>;
}
```

In the code, the `useOptimistic` hook keeps a temporary list of tasks that updates immediately when you add a new task.

The line, `(state, newTask) => [...state, { text: newTask, pending: true }]` ensures that a new task appears with a pending status even before the server confirms something is coming from the form.

When the form is submitted, the `handleSubmit` function extracts the task and adds it "optimistically" with the `addOptimisticTask` parameter. Then `addTask` is passed as a prop which sends the task to the server. Finally, the form is reset by calling `e.target.reset()`.

Here's the `TaskList` component:

```jsx
"use client";
import { useOptimistic, startTransition } from "react";

export default function TaskList({ tasks, addTask }) {
  const [optimisticTasks, addOptimisticTask] = useOptimistic(
    tasks,
    (state, newTask) => [...state, { text: newTask, pending: true }]
  );

  async function handleSubmit(e) {
    e.preventDefault();
    const formData = new FormData(e.target);

    startTransition(() => {
      addOptimisticTask(formData.get("task"));
    });

    addTask(formData);
    e.target.reset();
  }

  return (
    <div className="max-w-md mx-auto p-4">
      <h3 className="text-xl font-medium mb-3">Tasks</h3>

      <ul className="space-y-2 mb-4">
        {optimisticTasks.map((task, index) => (
          <li key={index} className="p-2 border-b">
            {task.text}
            {task.pending && (
              <small className="ml-2 text-gray-500 text-sm">
                Adding Task...
              </small>
            )}
          </li>
        ))}
      </ul>

      <form onSubmit={handleSubmit} className="flex gap-2">
        <input
          type="text"
          name="task"
          placeholder="Type in a task..."
          className="flex-1 p-2 border"
        />
        <button type="submit" className="bg-gray-200 px-3 py-2 cursor-pointer">
          Submit
        </button>
      </form>
    </div>
  );
}
```

Here, we are looping through the `optimisticTask` parameter to display the task. When `task.pending` is `true`, the text `Adding Task...` is displayed next to the task, confirming that the task has been added optimistically before the server confirms it.

Here's the `Task` component that manages the state for the form. It calls the `saveTask` function from the action so it can add the task, and appends the new task once it is received by the server:

```jsx
"use client";

import { useState } from "react";
import TaskList from "./TaskList";
import { saveTask } from "./actions";

export default function Tasks() {
  const [tasks, setTasks] = useState([]);

  async function addTask(formData) {
    const newTaskText = formData.get("task");

    const savedTask = await saveTask(newTaskText);
    setTasks((prev) => [...prev, { text: savedTask, pending: false }]);
  }

  return <TaskList tasks={tasks} addTask={addTask} />;
}
```

This ensures snappy UI updates by showing instant feedback instead of waiting for a response. Once the task is saved, the `pending` property is removed, and the final task list updates accordingly.

In the UI, there are two things happening that are not supposed to happen. First, you can't see the `Adding Task...` text since it appears and disappears too quickly. Next, there's an error occurring after adding the task.

There are two things we need to do to address those issues.

First, we need to import `startTransition` from React and use it to wrap the line `addOptimisticTask(formData.get('task'))`:

```js
startTransition(() => {
  addOptimisticTask(formData.get("task"));
});
```

Second, we need to make the `Adding Task...` text visible for some time before it goes away.

To do this, we can modify the `addTask` function with a pending state and simulate a delay of a few seconds before marking the task as completed. `setTimeout()` is ideal for this:

```js
async function addTask(formData) {
  const newTaskText = formData.get("task");

  // Add an optimistic task with a pending state
  const tempTask = { id: Date.now(), text: newTaskText, pending: true };
  setTasks((prev) => [...prev, tempTask]);

  // Simulate a 3 seconds delay before marking the task as completed
  setTimeout(async () => {
    const savedTask = await saveTask(newTaskText);

    setTasks((prev) =>
      prev.map((task) =>
        task.id === tempTask.id
          ? { ...task, text: savedTask, pending: false }
          : task
      )
    );
  }, 3000);
}
```

And once you do that, everything works fine.


## What Is Memoization, and How Does the useMemo Hook Work?

### Description

As your React app gets larger, unnecessary re-renders and expensive calculations can slow down performance, leading to slow UI updates and increased resource usage.

This can be especially problematic in apps with complex state management, large lists, functions that require heavy computations, and many components with a single parent.

This gives rise to the need to optimize your React app for better performance by minimizing redundant computations and ensuring smoother interactions.

React solves this problem with a process called memoization, a technique which caches values and functions to prevent unnecessary recalculations, so your app can be faster and more responsive.

By definition, memoization is an optimization technique in which the result of expensive function calls are cached (remembered) based on specific arguments. When the same arguments are provided again, the cached result is returned instead of re-computing the function.

The memoization process happens this way:

- Store the results of function calls along with their input arguments.

- Before executing the function, check if the result for the current arguments already exists in the cache.

- If it exists, return the cached result instead of running the computation again.

- If it doesn't exist, compute the result, store it in the cache, and then return it.

To improve developer experience with memoization, React provides three tools – `React.memo` (or `memo`), `useMemo` and `useCallback`. 

As you might guess, both `useMemo` and `useCallback` are hooks, but `React.memo` is a component wrapper, a higher-order component (HOC).

In the next lecture, we will take a look at how the `useCallback` hook and `React.memo` work.

`useMemo` lets you memoize computed values while `useCallback` does the same for function references.

If you're wondering what computed values and function references are, computed values refer to the result of executing a function, while function references are the pointers to functions – the function object in memory.

Let's see how to use the `useMemo` hook first. Here's the basic syntax of the `useMemo` hook:

```js
const memoizedValue = useMemo(
  function () {
    return computeExpensiveValue(a, b);
  },
  [a, b]
);
```

You can see all that's needed is to wrap the `useMemo` hook around the function.

This `ExpensiveSquare` component will receive a `num` prop which it will use to calculate the square:

```jsx
function ExpensiveSquare({ num }) {
  function calculateSquare(n) {
    console.log("Calculating square...");
    return n * n;
  }

  const squared = calculateSquare(num);
  return (
    <p>
      Square of {num}: {squared}
    </p>
  );
}
export default ExpensiveSquare;
```

Here's the `App` component where the `ExpensiveSquare` is being used:

```jsx
import { useState, useEffect } from "react";
import ExpensiveSquare from "./components/ExpensiveSquare";

function App() {
 const [timer, setTimer] = useState(0);
 const [num, setNum] = useState(0);

 useEffect(() => {
   const interval = setInterval(() => setTimer((c) => c + 1), 1000);
   return () => clearInterval(interval);
 }, []);

 return (
   <div>
     <h1>Timer: {timer} seconds gone</h1>
     <ExpensiveSquare num={num} />
     <button onClick={() => setNum((n) => n + 1)}>Increase Number</button>
   </div>
 );
}

export default App;
```

The `timer` in the `useEffect`, running every second, will make the `calculateSquare` function runs any time it runs, even when you don't increase the `num` state variable.

To solve this problem, we can use the `useMemo` hook by wrapping the function call in it and specifying the `num` variable as the dependency:

```jsx
// import the useMemo hook
import { useMemo } from "react";

function ExpensiveSquare({ num }) {
  function calculateSquare(n) {
    console.log("Calculating square...");
    return n * n;
  }

  // const squared = calculateSquare(num);
  // Wrap the function call in useMemo instead
  const squared = useMemo(() => calculateSquare(num), [num]);

  return (
    <p>
      Square of {num}: {squared}
    </p>
  );
}

export default ExpensiveSquare;
```

This will make sure the function is memoized by caching the result, so calculation happens only when the `num` variable changes, not when anything changes in the component it's being used in.

The `calculateSquare` function call is not running any time `timer` changes anymore but on the initial render and when `num` changes.


## How Do the useCallback Hook and React.memo Work?

### Description

In the last lecture, you learned about memoization and how the `useMemo` hook works.

In this lecture, you'll learn how the `useCallback` hook and `React.memo` work.

In the last lecture, we also mentioned that `useCallback` is for memoizing function references.

For `React.memo`, it lets you memoize a component to prevent it from unnecessary re-renders when its prop has not changed.

Here's the basic syntax of the `useCallback` hook:

```js
const handleClick = useCallback(() => {
  // code goes here
}, [dependency]);
```

And here's the basic syntax of `React.memo`:

```jsx
const MemoizedComponent = React.memo(({ prop }) => {
  return (
    <>
      {/* Presentation */}
    </>
  )
});
```

Let's look at an example of the `useCallback` hook:

```jsx
import { useState, useEffect } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount((prevCount) => prevCount + 1);
  };

  useEffect(() => {
    console.log("useEffect runs");
  }, [handleClick]);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Increment</button>
    </div>
  );
}

export default Counter;
```

In the component, the effect runs any time `handleClick` changes because the `handleClick` function is being recreated on every render.

To fix this, you need to tell React to treat the `handleClick` function as the same thing across renders by memoizing it with the `useCallback` hook, so it doesn't get recreated:

```jsx
import { useState, useEffect, useCallback } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  // Memoize the handleClick function with useCallback
  const handleClick = useCallback(() => {
    setCount((prevCount) => prevCount + 1);
  }, []);

  useEffect(() => {
    console.log("useEffect runs");
  }, [handleClick]);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Increment</button>
    </div>
  );
}

export default Counter;
```

Now the `handleClick` function is not being recreated on every render.

To show you how the `React.memo` (or `memo`) higher-order function works and the `useCallback` hook work in tandem, here's a `Counter` component with a `handleClick` function that needs `useCallback` but is currently not using it:

```jsx
import { useState, useEffect, useCallback } from "react";
import CounterChild from "./CounterChild";

function Counter() {
  const [count, setCount] = useState(0);
  const [timer, setTimer] = useState(new Date().toLocaleTimeString());

  const handleClick = () => {
    setCount(count + 1);
  };

  useEffect(() => {
    const interval = setInterval(() => {
      setTimer(new Date().toLocaleTimeString());
    }, 1000);

    return () => clearInterval(interval);
  }, []);

  return (
    <div>
      <h1>Time: {timer}</h1>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Increment</button>
      <CounterChild onClick={handleClick} />
    </div>
  );
}

export default Counter;
```

This function also has a timer in state that updates every second. This makes the component re-render every time the `timer` changes, making the `handleClick` function get recreated on every render.

That's why the `handleClick` needs to be memoized with `useCallback`.

Here's the `CounterChild` component:

```jsx
const CounterChild = ({ onClick }) => {
  console.log("CounterChild component rendered");
  return <button onClick={onClick}>Increment from Child</button>;
};

export default CounterChild;
```

This `CounterChild` component takes an `onClick` prop, giving you the ability to also increment the counter from it.

Since the `CounterChild` component is a child of the `Counter` component, it will also render any time the `Counter` re-renders due to the changing timer. So, the `CounterChild` also needs to be memoized.

Without memoization, because as the component re-renders due to the timer updating every second, the `CounterChild` component is also re-rendered.

To prevent this, you need to memoize the `CounterChild` component with `React.memo`:

```jsx
import React from "react";

const CounterChild = React.memo(({ onClick }) => {
  console.log("CounterChild component rendered");
  return <button onClick={onClick}>Increment from Child</button>;
});

export default CounterChild;
```

Things do not work optimally yet even after memoizing the `CounterChild` with `React.memo`.

This happens because the `handleClick` function is being recreated on every render, so it also needs to be memoized with `useCallback`, in order to tell React that you need the function to stay the same across renders:

```js
const handleClick = useCallback(() => {
  setCount((prevCount) => prevCount + 1);
}, [count]);
```

Now, the component only re-renders when the `count` state changes.


### Lecture Block: Lecture Routing React Frameworks And Dependency Management Tools


## What Is Dependency Management, and How Does It Work with Libraries Like React?

### Description

In software, a dependency is where one component or module in an application relies on another to function properly. Dependencies are common in software applications because it allows developers to use pre-built functions or tools created by others.

If you want to build out a React application, you will need to install the React dependencies. Without these dependencies, none of your code will work correctly and the application will display a list of errors.

When you are working with more complex projects, you will often need to rely on many dependencies. If a set of dependencies is not well managed or defined in a project, then that will lead to what is known as dependency hell.

To manage software dependencies in a project, you will need to use a package manager. A package manager is a tool used for installation, updates, and removal of dependencies. Many popular programming languages like JavaScript, Python, Ruby and Java, all use package managers.

In an earlier lecture, you were briefly introduced to one popular package manager called npm.

To create a new React project using Vite and npm you can run the following command:

```sh
npm create vite@latest my-react-app -- --template react
```

As you recall from the prior lectures, this will create all of the necessary boilerplate code needed to launch a new React application. Before you can launch the application, you will need to install the dependencies by running `npm install` or `npm i` for short.

You can view all of the dependencies in the `package.json` file which is located in the root directory of your project.

The `package.json` file is a key configuration file in projects that contains metadata about your project, including its name, version, and dependencies. It also defines scripts, licensing information, and other settings that help manage the project and its dependencies.

When you install dependencies, a `node_modules` folder will be added to your project.

The `node_modules` folder is where all the packages and libraries required by your project are stored. This folder contains the actual code for the dependencies listed in the `package.json` file, including both your project's direct dependencies and any dependencies of those dependencies.

The two core dependencies needed for a React project will be the `react` and `react-dom` packages:

```json
"dependencies": {
  "react": "^18.3.1",
  "react-dom": "^18.3.1"
}
```

The `package.json` will list the current versions you are using for those packages. If you need to update any packages locally, you can run the `npm update` command. Or you can update all packages globally by running the `npm update -g` command.

In addition to the `package.json` file, you will also have a `package-lock.json` file. This file will lock down the exact versions of all packages that your project is using. When you update a package, then the new versions will be updated in the lock file as well.

Another important aspect of the `package.json` file are the dev dependencies:

```json
"devDependencies": {
  "@eslint/js": "^9.17.0",
  "@types/react": "^18.3.18",
  "@types/react-dom": "^18.3.5",
  "@vitejs/plugin-react": "^4.3.4",
  "eslint": "^9.17.0",
  "eslint-plugin-react": "^7.37.2",
  "eslint-plugin-react-hooks": "^5.0.0",
  "eslint-plugin-react-refresh": "^0.4.16",
  "globals": "^15.14.0",
  "vite": "^6.0.5"
}
```

Dev dependencies are packages that are only used for development and not in production. An example of this would be a testing library like Jest. You would install Jest as a dev dependency because you only use it to test your project locally, and isn't needed for the application to run in production.

For the majority of this lecture, we have been focusing on npm. But there are other package mangers like yarn and pnpm. So which package manager should you use for your project?

Well, the short answer is it depends.

If you are joining an existing project with a team, then all of those decisions will be made for you and you will use the existing package manager. If you are building out a project from scratch, then you will need to research the pros and cons of each manager and decide which one will better suit your needs.


## How Does Routing Work in React?

### Description

In earlier lectures, you learned that React is a single page application. Single page applications are applications that contain one HTML file and use JavaScript to dynamically update any content on the page.

So what happens when you need to add multiple "pages" to your React application? How would you go about navigating to those different views?

Well, that is where React Router comes in.

React Router is a third party library that allows you to add routing to your React applications. To begin, you will need to install React Router in an existing React project like this:

```sh
npm i react-router
```

If you check the `package.json` file, you will see that `react-router` was added to the list of dependencies:

```json
"dependencies": {
  "react": "^18.3.1",
  "react-dom": "^18.3.1",
  "react-router": "^7.2.0"
}
```

Then inside of your `main.jsx` or `index.jsx` file, you will need to import `BrowserRouter` and render `BrowserRouter` around your `App` component:

```jsx
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import { BrowserRouter } from "react-router";
import App from "./App.jsx";

import "./index.css";

createRoot(document.getElementById("root")).render(
  <StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </StrictMode>
);
```

To enable routes in your application, you will need to update your `import` statement to include the `Routes` and `Route` components like this:

```js
import { BrowserRouter, Routes, Route } from "react-router";
```

Then inside of the `BrowserRouter`, add the `Routes` and `Route` components:

```jsx
createRoot(document.getElementById("root")).render(
  <StrictMode>
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<App />} />
      </Routes>
    </BrowserRouter>
  </StrictMode>
);
```

The `path` and `element` are used to couple the URL and UI components together. In this case, we are setting up a route for the homepage that points to the `App` component.

It is common in larger applications to have multiple views and routes setup like this:

```jsx
<Routes>
  <Route index element={<Home />} />
  <Route path="about" element={<About />} />

  <Route path="products">
    <Route index element={<ProductsHome />} />
    <Route path=":category" element={<Category />} />
    <Route path=":category/:productId" element={<ProductDetail />} />
    <Route path="trending" element={<Trending />} />
  </Route>
</Routes>
```

The `index` prop in these examples is meant to represent the default route for a given path segment. So the `Home` component will be shown at the root path (`/`) while the `ProductsHome` component will be shown at the `products` path.

You may have also noticed that we are nesting a few routes inside another route like this:

```jsx
<Route path="products">
  <Route path="trending" element={<Trending />} />
</Route>
```

This means that the path of the child route will be appended to the parent route's path. So in this example, the `path` for the trending products will be `products/trending`.

If the `path` begins with a colon (`:`) then that represents a dynamic segment in the route:

```jsx
<Route path=":category" element={<Category />} />
```

In this example we have a dynamic segment called `category`. When a user navigates to a URL like `products/brass-instruments`, then the view will change to the `Category` component and you can dynamically fetch the appropriate data based on the segment.

You can access the value of the dynamic segment by using the `useParams` hook inside the child component like this:

```jsx
import { useParams } from "react-router";

export default function Category() {
  let params = useParams();
   {/* Accessing the category param: params.category */}
   {/* rest of code goes here */}
}
```

Dynamic routes are helpful because they allow you to create flexible and reusable components that can render different content based on the parameters in the URL. Instead of defining a fixed list of paths for every possible route, you can use dynamic segments to render various content based on what the user has requested.


## What Are React Frameworks, and Why Are They Commonly Used in the Industry?

### Description

Up until this point, you have been using React to build out user interfaces. If you needed additional features like routing, then you had to import a third party library like React Router to be able to switch between the different views.

But what happens when you need to build out a full stack web application? Well you could use React for the frontend and use Node and Express for the backend logic if you just want to stick with JavaScript. Or you could use other languages like Go, Python, or Java for your backend.

While all of these are viable options, there are times where you might want to use a React framework instead. React frameworks provide features like routing, image optimizations, data fetching, authentication and more. This means that you might not need to set up separate frontend and backend applications for certain use cases.

Let's take a closer look at Next.js which is a popular React framework. One of the main features for Next.js is the file-system based router. This routing system includes support for dynamic routes, parallel routes, route handlers, redirects, internalization and more.

Here is an example of creating a custom request handler:

```js
export async function GET() {
  const res = await fetch("https://example-api.com");
  const data = await res.json();

  return Response.json({ data });
}
```

You can define route handlers like GET or POST requests in a file called `route.js` inside the `app/api` directory.

Another feature of Next.js are the automatic image and font optimizations.

Here is an example of working with the `Image` component inside a `page.js` file:

```jsx
import Image from "next/image";

export default function Page() {
  return (
    <Image src="link-to-image-goes-here" alt="descriptive-title-goes-here" />
  );
}
```

The `Image` component extends the native HTML `img` element and allows for faster page loads and size optimizations. This means that images will only load when they enter the viewport and the `Image` component will automatically serve correctly sized images for each device.

While those are just a few features of Next.js, there are many more features that you can use to build robust full stack web applications. There are also other React frameworks like Remix that will provide the same ability to build out modern full stack web applications.

Even though the JavaScript library and framework landscape is constantly changing, it is important to be aware of the available options to you and learn about each framework's pros and cons.


### Lecture Block: Lecture React Strategies And Debugging


## What Is Prop Drilling?

### Description

Prop drilling is the most basic approach to state management in React applications. It looks simple, but can get messy quickly, and is very hard to scale.

Let's look at what prop drilling is, why it's a problem, and a good replacement for it as an application grows.

Prop drilling is the process of passing props from a parent component to deeply nested child components, even when some of the child components don't need the props.

For example, say you have three components named `Parent`, `Child`, and `Grandchild`. If you want to use some data in the `Grandchild` component, but it's in the `Parent` component, you'd need to pass it from the `Parent` to the `Child` component, then from the `Child` to the `Grandchild` component.

Or if the data is even further up the chain, the data might have to be passed to the `Parent` component, too.

Here, the data I want to display is the string `Hello, Prop Drilling!`. It's assigned to the `greeting` variable in the root `App` component:

```jsx
import "./App.css";
import Parent from "./Parent";

function App() {
  const greeting = "Hello, Prop Drilling!";

  return <Parent greeting={greeting} />;
}

export default App;
```

You can see the `Parent` component is also receiving the `greeting` variable as the value of a `greeting` prop. Here's the `Parent` component passing it into the `Child` component as the value of another `greeting` prop in the `Child`:

```jsx
import Child from "./Child";

const Parent = ({ greeting }) => {
  return <Child greeting={greeting} />;
};

export default Parent;
```

And here's the `Child` component that passes it to the `Grandchild` component:

```jsx
import Grandchild from "./Grandchild";

const Child = ({ greeting }) => {
  return <Grandchild greeting={greeting} />;
};

export default Child;
```

And finally the `Grandchild` component receives the greeting and uses it as the content of an `h1` element:

```jsx
const Grandchild = ({ greeting }) => {
  return <h1>{greeting}</h1>;
};

export default Grandchild;
```

In the browser, you'll see a page with a single `h1` element that has the text `Hello, Prop Drilling!`.

At first, prop drilling might not seem like such a big deal. But as your app grows, it gets harder to understand, debug, and maintain.

If you need to pass props around, try to keep them all in a single parent component. This approach of centralizing all necessary data is called the "single source of truth".

For instance, say you want to add a new `response` to go with your `greeting`, and that you want to use both of them in the `Grandchild` component. Since `greeting` is already in the `App` component, it makes sense to put `response` there, too, and pass both of them down the chain:

```jsx
function App() {
  const greeting = "Hello, Prop Drilling!";
  const response = "I'm not here to play!";

  return <Parent greeting={greeting} response={response} />;
}

const Parent = ({ greeting, response }) => {
  return <Child greeting={greeting} response={response} />;
};

const Child = ({ greeting, response }) => {
  return <Grandchild greeting={greeting} response={response} />;
};

const Grandchild = ({ greeting, response }) => {
  return (
    <>
      <h1>{greeting}</h1>
      <h2>{response}</h2>
    </>
  );
};

export default App;
```

In the browser, you'll see a page with an `h1` element that has the text `Hello, Prop Drilling!` and an `h2` element that has the text `I'm not here to play!`.

To avoid prop drilling, especially in large, complex applications, consider using the Context API or state management libraries like Redux and Redux Toolkit, Zustand, Recoil, and others.

You'll learn more about these in the coming lectures.


## What Are State Management Libraries, and When Should You Use Them?

### Description

As your app grows, managing how data flows between components can become complex.

When starting out, React's `useState` hook might be sufficient, but as you add features, you might encounter issues with:

- Passing props through components that don't need them, also known as prop drilling
- Keeping data in sync across different parts of your app
- Handling complex updates that affect multiple components simultaneously

These and other challenges may arise, which can lead to a codebase that's harder to maintain, debug, and test. That's where state management libraries come in – they provide a centralized place where components can get or update the data they need.

Let's take a look at a few different state management options you have, and when to use them.

The Context API is a state manager built into React that lets you share state across components without using a third-party library. It's a well-established upgrade over the `useState` hook, so it is perfect for cases like theme toggling or user authentication status.

However, the Context API does not handle frequent updates well, and can cause unnecessary re-renders, making it less suitable for complex state needs in applications like eCommerce and social media platforms. 

Here's a counter component that demonstrates the basic usage of the Context API:

```jsx
import { useState, createContext } from 'react';

const CounterContext = createContext();

const CounterProvider = ({ children }) => {
  const [count, setCount] = useState(0);

  return (
    <CounterContext.Provider value={{ count, setCount }}>
      {children}
    </CounterContext.Provider>
  );
};

export { CounterContext, CounterProvider };
```

This code creates a context and a provider to share a `count` state across the application.

`CounterProvider` uses the `useState` hook to initialize and manage the `count` state and its setter. Both are then passed into child components through the `Provider`.

So, when you wrap your whole app with the `CounterProvider`, the `count` state is available everywhere in your application.

Here's how you can wrap `CounterProvider` around your application:

```jsx
import { CounterProvider } from './context/CounterContext';

function App() {
  return (
    <CounterProvider>
        {/* App components */}
    </CounterProvider>
  );
}

export default App;
```

And here's how you can use the `count` state:

```jsx
import React, { useContext } from 'react';
import { CounterContext } from '../context/CounterContext';

const Counter = () => {
  const { count, setCount } = useContext(CounterContext);

  return (
    <>
      <div style={{ textAlign: 'center' }}>
        <h1>Context API Counter</h1>
        <button style={{ marginRight: '5px' }} onClick={() => setCount(count - 1)}>
          Decrease
        </button>
        <span>{count}</span>
        <button style={{ marginLeft: '5px' }} onClick={() => setCount(count + 1)}>
          Increase
        </button>
      </div>
    </>
  );
};

export default Counter;
```

As you can see, the `count` and its setter function, `setCount`, are initialized through the `useContext` function. 

The current `count` state is then displayed, and `setCount` is used to increase and decrease the `count` state when the user clicks the decrement and increment buttons respectively.

Another popular state management library is Redux, which is one of the most popular state management libraries to use with React. It's been around for a long time, and is ideal for larger applications like eCommerce and social media platforms, forums, and so on.

Redux handles state management by providing a central store and strict control over state updates. It uses a predictable pattern with actions, reducers, and middleware.

Actions are payloads of information that send data from your application to the Redux store, often triggered by user interactions.

Reducers are functions that specify how the state should change in response to those actions, ensuring the state is updated in an immutable way.

Middleware, on the other hand, acts as a bridge between the action dispatching and the reducer, allowing you to extend Redux's functionality (for example, logging, handling async operations) without modifying the core flow.

The most common complaint about Redux is with all the boilerplate code you need to get started. In response, the Redux team introduced "Redux Toolkit" and "RTK Query", which simplify the setup process quite a bit.

You typically define both actions and reducers in a single file using the `createSlice()` function. It's common to name the file so it ends with the word `Slice`, for example, `productSlice`, `userSlice`, `counterSlice`, and so on.

Here's a `counterSlice` file to show you the basics:

```jsx
import { createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',

  initialState: { count: 0 },

  reducers: {
    increment: (state) => {
      state.count += 1;
    },
    decrement: (state) => {
      state.count -= 1;
    },
  },
});

export const { increment, decrement } = counterSlice.actions;

export default counterSlice.reducer;
```

From here, you then need to wrap the entire app with the `Provider`, select a piece of state from the slice with `useSelector()`, then use `useDispatch()` to make the state active.

Another option to consider is Zustand.

Zustand is a lightweight state management library with a simple API. It is based on hooks, so there's less boilerplate compared to Redux, making it easier and quicker to set up.

Zustand is ideal for small to medium-scale applications. It works by using a `useStore` hook to access access state directly in components and pages. This lets you modify and access data without needing actions, reducers, or a provider.

Here's a `useCounterStore` that implements another counter functionality:

```jsx
import { create } from 'zustand';

const useCounterStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
}));

export default useCounterStore;
```

And here's how to initialize and use the states in your app:

```jsx
// Import the useCounterStore (it's just a hook)
import useCounterStore from '../useCounterStore';

const Counter = () => {
  // Initialize the states with the useCounterStore hook
  const { count, increment, decrement } = useCounterStore();

  return (
    <>
      <div style={{ textAlign: 'center' }}>
        <h1>Zustand Counter</h1>
        <button style={{ marginRight: '5px' }} onClick={() => decrement()}>
          Decrease
        </button>
        <span>{count}</span>
        <button style={{ marginLeft: '5px' }} onClick={() => increment()}>
          Increase
        </button>
      </div>
    </>
  );
};

export default Counter;
```

Even though the frontend ecosystem is constantly evolving and new state management libraries regularly emerge, the ones we've discussed are widely used in the industry.


## How Can You Debug Your React Components Using the React DevTools?

### Description

The browser has built-in developer tools you can use to debug HTML, CSS, and JavaScript.

However, they're not great for finding and fixing bugs in React apps. So the React team developed a tool called "React Developer Tools" (AKA React DevTools) so you can inspect, debug, and profile React apps.

React DevTools is available as a browser extension for Chrome, Edge, and Firefox. If you're on Chrome or Edge, head over to the Chrome web store, search for "React Developer Tools”, and add it to your browser.

And if you use Firefox, head over to the Firefox Add-ons page, search for the tool, and add it to your browser.

If you use Safari, you can install React DevTools from npm by running `npm install -g react-devtools` or `yarn global add react-devtools`.

After installing and enabling React DevTools, if you open a React app in your browser, then open your browser's developer tools, you should see two extra tabs: Components and Profiler.

The Components tab displays each component for you in a tree view format. With it, you can: 

- View the app's component hierarchy.
- Check and modify props, states, and context values in real time.
- Check the source code for each selected component.
- Log the component data to the console.
- Inspect the DOM elements for the component.

On the other hand, the Profiler tab helps you record and analyze component performance so you can identify unnecessary re-renders, view commit durations, and things you can optimize.

Here's a simple app to show you how you can inspect components and any props and state they have. This is similar to the code we used in a previous lecture on prop drilling:

```jsx
import { useState } from "react";

export default function App() {
  const greeting = "Hello, Prop Drilling!";
  const response = "I'm not here to play!";

  return <Parent greeting={greeting} response={response} />;
}

const Parent = ({ greeting, response }) => {
  return <Child greeting={greeting} response={response} />;
};

const Child = ({ greeting, response }) => {
  return <Grandchild greeting={greeting} response={response} />;
};

const Grandchild = ({ greeting, response }) => {
  const [count, setCount] = useState(0);

  return (
    <>
      <h1>{greeting}</h1>
      <h2>{response}</h2>

      <button onClick={() => setCount(count + 1)}>Increase Count</button>
      <h2>Count: {count}</h2>
      <button onClick={() => setCount(count - 1)}>Decrease Count</button>
    </>
  );
};
```

If you look in the Components tab in React DevTools, you can see the tree view of the components. The `App` component is at the top, followed by the `Parent`, `Child`, and `Grandchild` components.

If you select any of these components, you can see the props and state in them. If you select the `Parent` component, you can see the `greeting` and `response` props, which are `Hello, Prop Drilling!` and `I'm not here to play!`, respectively.

You can see the props and update state in real-time, and change them if necessary. For instance, you can select the `Grandchild` component and change the `greeting` prop from `Hello, Prop Drilling!` to `Hello, Welcome to Prop Drilling!`, and see it reflected on the page immediately.

To log data in a component to the console, inspect the matching DOM elements and view the source code of the component. The icons in the top right corner let you do that. If you select the `Grandchild` component and click the `Log the component data to the console` button, it will log the props, state, hooks, nodes, and other data in the console.

A common bug you might encounter in React is called props mismatch.

For example, say that for the `Child` component, you mistakenly pass in `reply` as the prop instead of `response`:

```jsx
const Child = ({ greeting, response }) => {
  return <Grandchild greeting={greeting} reply={response} />;
};
```

Remember that `Grandchild` expects a `response` prop. Because the component receives a different prop, it can't display that text on the page, and just adds and empty `h2` to the DOM. Instead, you'll just see the `h1` element with the text `Hello, Prop Drilling!`, along with the other buttons and text already on the page. The empty `h2` element is still there, but because it's empty, you can't see it without inspecting the DOM.

To fix this, you can inspect the prop progression from the `Parent` component down to the `Child` and edit the prop name directly. If you go to the Components tab, select the `Child` component, and change the `reply` prop to `response`, you'll see the `h2` element on the page with the text `I'm not here to play!`.


## What Are React Server Components, and How Do They Work?

### Description

React Server Components (RSCs) is a new trend that has changed the way React developers approach things. With RSCs, more work shifts to the server, which has a lot of benefits.

Let's take a look at what server components are, how they work, and what led to the introduction of server components.

React Server Components are React components that render exclusively on the server, which sends only the final HTML to the client. This means those components can directly access server-side resources and dramatically reduce the amount of JavaScript sent to the browser.

React apps have traditionally used a "client component" system that handles everything in a typical React app, such as rendering, interactivity, and side effects. The term "client component" was rarely used until the introduction of React server components recently.

But the client component system comes with some drawbacks like large JavaScript bundles and slower initial load times.

React frameworks like Next.js and Gatsby found workarounds to offload some processes to the server in order to fix those problems, but none of them were standardized. If you've used either framework, you've probably heard about `getServerSideProps` and `getServerData`.

Then came React Server Components, which let you run some components entirely on the server so you can do things like data fetching and computation before any code runs in the user's browser.

Server components were first popularized and are readily available in Next.js. Other frameworks like Remix and Gatsby are catching up, and there's an experimental plugin for Vite called `vite-plugin-react-server` which lets you build server components.

So how do server components work?

One of the best ways to demonstrate React Server Components is with data fetching.

In traditional React client components, you let the browser handle API requests. Since data fetching is a side effect, you make that API call in a `useEffect` hook.

It's also good practice to set state variables like loading, data, and error so you can indicate that the data is loading, display the data when it's ready, or display an error in your app.

With React Server Components, you can move the entire component to the server and fetch data there without having to use `useState` or `useEffect`:

```jsx
const Users = async () => {
  const res = await fetch("https://jsonplaceholder.typicode.com/users");
  const users = await res.json();

  return (
    <>
      <h1 className="text-4xl text-center mt-6">Users</h1>
      <ul className="text-center mt-3">
        {users.map((user) => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </>
  );
};

export default Users;
```

Because React Server Components only run on the server, you can just fetch data from an API and render just once. Also, since data fetching happens on the server, closer to the source, your app may perform better, especially for people with slow network connections.

Once major gotcha is that all the code for server components remain on the server, and doesn't get shipped to the browser. That means you can't use React hooks with them, and they don't have access to Web APIs or browser event listeners. So how can you add interactivity?

In the Next.js app router, all components are server components by default. If you want to add interactivity, you need to mark the component as a client component with the `"use client"` directive.

Let's say you want to make the previous example a client component. Here's how you can do that:

```jsx
"use client";

import { useState, useEffect } from "react";

const Users2 = () => {
  const [status, setStatus] = useState({
    users: [],
    loading: true,
    error: null,
  });

  async function fetchUsers() {
    try {
      const res = await fetch("https://jsonplaceholder.typicode.com/users");
      const data = await res.json();
      setStatus((prevStatus) => ({
        ...prevStatus,
        users: data,
        loading: false,
      }));
    } catch (err) {
      setStatus((prevStatus) => ({
        ...prevStatus,
        error: err.message,
        loading: false,
      }));
    }
  }

  useEffect(() => {
    fetchUsers();
  }, []);

  if (status.loading) {
    return <p>Loading Users...</p>;
  }
  if (status.error) {
    return <p>Error getting users: {status.error}</p>;
  }

  return (
    <>
      <h1 className="text-4xl text-center mt-6">Users</h1>
      <ul className="text-center mt-3">
        {status.users.map((user) => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </>
  );
};

export default Users2;
```

If you want to add interactivity like click events, the component also has to be marked as a client component:

```jsx
"use client";

import { useState } from "react";

const Counter = () => {
  const [count, setCount] = useState(0);

  return (
    <>
      <h1>Counter</h1>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <h2>{count}</h2>
      <button onClick={() => setCount(count - 1)}>Decrement</button>
    </>
  );
};

export default Counter;
```

If you don't add the use client directive to the component, you get an error with a message that says "You're importing a server component that needs `useState`. This React hook only works in a client component. To fix, mark the file (or its parent) with the `"use client"` directive."

The main benefits that come with React Server Components are that data fetching becomes simpler, the code is easier to read, and client complexity is reduced.


## Module: Performance


### Lecture Block: Lecture Understanding Performance In Web Applications


## What Is the Difference Between Real Performance and Perceived Performance?

### Description

When we talk about performance, the term itself can feel a bit subjective, right? What is good performance? What is bad performance?

Is there a standard way to measure performance or is it completely dependent on the user's personal preferences and perception? Let's see. 

We can classify a website's performance into two different categories: perceived performance and real performance.

The perceived performance is how users perceive the performance of a website. It's how they evaluate it in terms of responsiveness and reliability. This is a subjective measurement, so it's hard to quantify it, but it's very important, since the user experience determines the success or failure of a website.

In contrast, real performance is the objective and measurable performance of the website. It's measured using metrics like page load time, server response time, and rendering time. These measurements are influenced by multiple factors related to the network and to the code itself.

Even a website with excellent perceived performance can be further optimized for an even better user experience.

There are several techniques for improving perceived performance.

Reducing the initial load time as much as possible by loading non-essential resources in the background is essential. This technique is known as "lazy loading." That first impression can determine what users will think about your website.

Lazy loading will also impact the real performance of your website. By using this technique, you can reduce the amount of content that has to be loaded upfront, so the page will load faster, which is a real performance metric.

It's also very important to provide quick response and feedback to user interactions. 

For example, showing a loading indicator for a long-running process as soon as the user clicks on an element can help the user feel connected and engaged with the process, making the wait time feel shorter - or at least they'll feel more involved.

Keeping users actively engaged with your website is very important for improving their time perception. Displaying text as soon as it arrives is helpful for keeping users engaged from the start, even if other resources, like images, have not been loaded yet.

If a user is waiting for a long-running task to be completed, keep them informed on the progress and update it regularly.

Another tip is to avoid content reflow and jumping content. For example, when ads or images are being loaded, the website might jump or readjust to make room for these new resources if they don't already have a space in the layout. 

These sudden changes can result in a bad user experience because users may feel like the website is still loading. To avoid this, plan ahead and assign space for these elements from the start.

If your website has custom fonts, you should also try to minimize font loading delays, since this may result in flickering - or showing the fallback font while the custom font is being loaded. A suggestion for this is using a fallback font that is similar to the custom font, so in case this happens, the change will be much more subtle.

Also, be sure that the interface elements are active. The user should be able to interact with them with minimal lag.

We will go into these techniques in more detail in the next few lectures.

While real performance is important, perceived performance can have a tremendous impact on user experience. By optimizing for both, you can create websites that are and feel faster, creating a smooth and engaging user experience.


## What Are the Key Performance Concepts?

### Description

Why do some websites feel snappy and responsive, while others feel sluggish? The answer lies in key performance concepts that affect how a page loads and renders. Understanding key web performance concepts is essential for building fast, smooth, and user-friendly websites. 

Let's break down source order, the critical rendering path, latency, and more.

Let's look at source order first.

Source order refers to the way HTML elements are structured in the document. This determines what loads first and can significantly impact performance and accessibility.

Some best practices for this include:

- Placing critical content such as headings, navigation or main text higher in the HTML structure.

- Deferring non-essential scripts such as ones for analytics, or third-party widgets, so they don't block rendering.

- Using progressive enhancement, to ensure the core experience works even before styles and scripts load. Progressive enhancement is a way of building websites and applications based on the idea that you should make your page work with HTML first.

Here is an example of good source order, using the best practices we just went through.

```html
<!-- Good source order: Essential content first -->
<h1>Welcome to FastSite!</h1>
<p>Critical information loads first.</p>
<script src="slow-script.js" defer></script>
```

By optimizing source order, we make sure users see important content as soon as possible.

Now let's look at critical rendering path.

The critical rendering path is the sequence of steps the browser follows to convert code into pixels on the screen.

Here are the key steps that we will go into later:

1. Parsing HTML: Builds the DOM (Document Object Model)

2. Parsing CSS: Builds the CSSOM (CSS Object Model)

3. JavaScript Execution: Can modify the DOM & CSSOM

4. Render Tree Construction: Combines the DOM & CSSOM

5. Layout & Painting: Determines element sizes & draws pixels

6. Optimizations:

    - Minimize render-blocking resources (e.g., large CSS files, unused JS).

    - Use async and defer attributes for scripts:

    - Load only essential styles first; defer non-critical CSS.

Overall, a shorter critical rendering path equals a faster perceived performance. We will go into this in more detail later on.

And finally, let's look at latency.

Latency is the time it takes for a request to travel between the browser and the server. So in other words, high latency equals slow pages.

Some ways of reducing latency include:

- Using CDNs, or in other words, Content Delivery Networks, to serve files from closer locations.

- Enabling compression using things such as Gzip to reduce file sizes.

- Optimizing images and using lazy loading - which we will also go into later.

By reducing latency, we make interactions feel instant.

So in conclusion, by optimizing source order, reducing the critical path, and cutting down latency, you can make your website feel fast.


## What Is INP?

### Description

Have you ever clicked on a webpage and felt like nothing happened? This delay impacts user experience and is measured by a metric called Interaction to Next Paint, or INP.

INP assesses a page's overall responsiveness by measuring the time from when a user interacts — like a click or key press — to the next time the browser updates the display. A lower INP indicates a more responsive page.

But why is INP important? A high INP can make users feel that a page is unresponsive, leading to frustration. Optimizing INP ensures that users receive timely feedback, enhancing their experience.

Tools like Chrome's DevTools and web performance APIs can help measure INP by tracking interaction delays.

To improve INP, minimize main thread work, optimize event handlers, and ensure that user interactions trigger timely visual updates.

By understanding and optimizing INP, you can create web experiences that feel fast and responsive, keeping your users satisfied.


## How to Measure and Improve INP?

### Description

Let's walk through a practical way to measure Interaction to Next Paint, or INP, using Chrome DevTools.

First of all, let's open DevTools by pressing "F12" or Right-click and click on "Inspect".

Now, let's say you have a search bar on your webpage.

Imagine a user types a query, but it takes 600ms before the suggestion dropdown appears. Chrome DevTools would mark this high INP value.

You can optimize by deferring heavy JavaScript, reducing long tasks, and improving event handling. The INP would then drop to 150ms, making interactions feel instant.

Cool, right?

Now, let's look at a practical measurement technique that helps identify interaction delays so you can create a faster and smoother user experience!

First, we would open Chrome DevTools. We would do so, once again, by opening Google Chrome, navigating to a webpage that we want to analyze, and pressing "F12" or right-clicking the page and clicking "Inspect". Now, let's head to the "Performance" tab - and there is everything that you need.

Now we are ready to identify the Interaction to Next Paint, or INP. We are going to look for the longest interaction delay recorded. A good INP is generally below 200ms, and a poor INP is above 500ms. And that's it!


## How Does a Browser Render a Page?

### Description

Have you ever wondered what happens behind the scenes when you enter a URL and press enter? How does the browser transform code into the interactive pages we see?

Understanding how a browser renders a web page is essential for developers aiming to optimize performance and enhance user experience.

In this lecture, we'll demystify the rendering process, breaking it down into clear, digestible steps.

First the browser parses the HTML and builds the DOM.

The process begins with the browser fetching the HTML content of the page. It parses this HTML to construct the Document Object Model, or DOM — a tree-like structure representing the page's content.

Consider this simple HTML snippet:

```html
<html>
  <body>
    <h1>Hello, World!</h1>
    <p>Welcome to our website.</p>
  </body>
</html>
```

The browser parses this to create a DOM tree with `html` as the root, containing `body`, which in turn contains `h1` and `p` elements.

Next, the browser processes the CSS, constructing the CSS Object Model, or CSSOM. This is another tree structure that dictates how elements should be styled.

Given this CSS:

```css
h1 {
  color: blue;
}
p {
  font-size: 16px;
}
```

The CSS Object Model specifies that `h1` elements are blue and `p` elements have a font size of 16 pixels.

The browser then combines the DOM and CSS Object Model to form the render tree. This tree includes only the nodes needed to render the page, each paired with its corresponding styles.

For our example, the render tree consists of the `h1` and `p` elements, styled appropriately.

With the render tree in hand, the browser calculates the exact position and size of each element in a process called layout or reflow. This ensures that elements appear in the correct location and dimensions on the screen.

Finally, the browser paints the pixels to the screen, rendering each element based on the calculated styles and layout. In complex pages, this might involve multiple layers that are composited together to form the final visual output.

In conclusion, from parsing HTML and CSS to painting pixels on the screen, the browser's rendering process is a sophisticated sequence of steps.


## How Does Performance Impact Sustainability?

### Description

Improving web performance is crucial for delivering a fast and efficient user experience. But did you know that optimizing your website's performance doesn't just improve speed — it also helps the environment?

Every time a page loads, energy is consumed. And when sites are inefficient, they use more resources, leading to higher carbon emissions.

Let's break down how performance impacts sustainability and show you practical ways to optimize your code for a greener web.

The internet accounts for around 2% of global carbon emissions — that's the same as the airline industry! Every byte transferred requires electricity, from data centers to user devices. Larger files and inefficient scripts mean more power consumption. A high-performance website isn't just faster, it also reduces unnecessary processing and energy use.

Here's an example of inefficient JavaScript:

```js
// Inefficient JavaScript
function fetchData() {
    for (let i = 0; i < 1000000; i++) {
        console.log("Processing...");
    }
    fetch("https://api.example.com/data")
        .then(response => response.json())
        .then(data => console.log(data));
}
fetchData();
```

This script runs excessive console logs, wasting CPU cycles and energy.

Now, let's optimize it:

```js
// Optimized JavaScript
async function fetchDataOptimized() {
    const response = await fetch("https://api.example.com/data");
    const data = await response.json();
    console.log(data);
}
fetchDataOptimized();
```

By removing unnecessary loops and using `async`/`await`, we lower processing time and energy consumption.

Here are some practical optimization tips you can use in your future projects.

1. Minify Your Assets: Use tools like Terser or UglifyJS to shrink JavaScript and CSS files. Smaller files load faster and require less energy.

2. Optimize Images: Use next-gen formats like WebP instead of PNGs or JPEGs to reduce file size without quality loss.

3. Reduce Network Requests: Each request adds overhead. Combine CSS and JavaScript files and use lazy loading to reduce load times.

4. Use Efficient Algorithms: A poorly optimized loop can increase CPU usage. This is the same as writing inefficient JavaScript that we saw in the example previously.

5. Leverage Caching & CDNs: Caching prevents repeated downloads, and CDNs deliver content closer to users, reducing transmission energy.

And now, what if you want to measure your impact and just how green your site is?

Use tools like Google Lighthouse to analyze performance and estimate energy savings. Or, for a deeper sustainability check, try the Website Carbon Calculator — as it estimates your page's environmental impact.

In conclusion, by understanding and implementing these performance fundamentals, developers can create web applications that are not only faster and more responsive but also more sustainable.


## What Are Some Ways to Reduce Page Loading Times?

### Description

Have you ever left a website because it took too long to load? Slow page loading can frustrate users and increase bounce rates. Today, we'll explore practical ways to reduce page loading times, ensuring your audience stays engaged.

Number 1: optimize media assets. Large images and videos are common culprits for slow load times. By optimizing these assets, you can significantly speed up your site:

- Compress Images: Use tools like TinyPNG to reduce image file sizes without compromising quality.

- Use Modern Formats: Implement formats like WebP for images and AV1 for videos to achieve better compression rates.

- Lazy Loading: Defer loading off-screen images and videos until they're needed. In HTML, add the `loading="lazy"` attribute to your media tags.

Next, we have minimize HTTP requests. Each file your website requests adds to the load time. Reducing the number of HTTP requests can lead to faster page loads. You can:

- Combine Files: Merge CSS and JavaScript files to reduce the number of requests.

- Use Inline Critical CSS: Place essential CSS directly in the HTML to speed up initial rendering.

- Use CSS Sprites: Combine multiple images into a single sprite sheet to minimize requests.

And, of course, you can Leverage Browser Caching. Caching allows browsers to store parts of your website locally, reducing load times for returning visitors:

- Set Expiry Headers: Use the `Cache-Control` header to specify how long browsers should keep files.

- Version Assets: When updating files, change their names or use query strings to ensure browsers fetch the latest versions.

You can do this along with minifying and Compressing files, which will reduce the size of your files can lead to quicker downloads:

- Minify CSS and JavaScript: Remove unnecessary whitespace and comments using tools like UglifyJS for JavaScript and cssnano for CSS.

- Enable Compression: Configure your server to use Gzip to reduce the size of transmitted files.

You can also optimize web fonts. Web fonts can enhance design but may also slow down your site if not handled properly:

- Limit Font Variants: Only include the character sets and styles you need.

- Use `font-display`: Control how fonts are displayed during loading by setting the `font-display` property in your CSS.

So in conclusion, by implementing all these strategies, you can significantly reduce your page loading times, leading to a better user experience and improved site performance.


## How Do You Improve "Time to Usable"?

### Description

Improving the "time to usable", or in other words the interval from when a user requests a page to when they can meaningfully interact with it, is crucial for enhancing user experience.

Let's explore effective strategies to achieve a faster time to usable.

Begin by focusing on the content that the user sees first. This means loading essential elements immediately and deferring non-critical components.

For example, you could try to implement lazy loading.

We have already covered lazy loading, but here is an example of lazy load images as a refresher:

```html
<img src="image.jpg" loading="lazy" alt="Description">
```

All you need to do is add the `loading="lazy"` attribute to image tags. This defers the loading of images until they are needed, typically when they enter the user's viewport. By loading images and videos only when they enter the viewport, we are conserving bandwidth as well as causing the speed up of initial rendering.

Normally, a webpage loads all images at once, even those not visible on the screen. With lazy loading, images below the fold, or in other words off-screen, they are only loaded when the user scrolls down to them.

And here is an example of lazy load iframes:

```html
<iframe src="video.html" loading="lazy"></iframe>
```

You can apply the same attribute that you did before, but this time to iframes, and the same concept will apply.

You can also use the `defer` attribute to delay non-critical JavaScript until after the initial page load. Here is an example of us doing just that:

```html
<script src="non-critical.js" defer></script>
```

You could also consider minimizing render-blocking resources.

Render-blocking resources delay the page from becoming interactive.

To avoid this, you could try loading CSS asynchronously. For non-critical CSS, use the `media` attribute to load stylesheets conditionally. Here is an example of us doing just that:

```html
<link rel="stylesheet" href="print.css" media="print">
```

By specifying media value as `print`, the `print.css` will only be loaded when the page is printed or previewed on screen. In this next example, by passing `min-width: 800px` as the value to the `media` attribute, we are saying we only want `desktop.css` to load for screens wider than 800px:

```html
<!-- This stylesheet is only loaded on screens wider than 800px -->
<link rel="stylesheet" href="desktop.css" media="(min-width: 800px)">
```

This saves bandwidth by skipping unnecessary styles.

So, in conclusion, by implementing these strategies, you can significantly reduce the "time to usable" for your website, ensuring users can interact with your content promptly.


## How to Improve the Perceived Performance of Features?

### Description

As we know, perceived performance isn't just about how fast a site actually is — it's about how fast it feels to users. So, for example, if you have ever used a website that felt slow, even though it wasn't? That's perceived performance — how fast a site feels to the user.

Small tweaks can make a huge difference in the user experience. Let's explore some practical ways to improve perceived performance!

Spinners can make users feel like they're waiting longer than they actually are. Instead, try skeleton screens — gray placeholders that mimic real content and gradually load in:

```html
<div class="skeleton"></div>
<script>
  setTimeout(() => {
    document.querySelector(".skeleton").innerHTML = "✅ Content Loaded!";
  }, 2000);
</script>
```

Users feel like the page is loading progressively, rather than waiting in the dark.

In addition to this, users shouldn't have to wait for everything to load before they can start interacting. Load important content first, then load the rest in the background. We looked at this previously with lazy loading:

```html
<img src="placeholder.jpg" data-src="real-image.jpg" class="lazy">
<script>
  document.addEventListener("DOMContentLoaded", function () {
    const lazyImages = document.querySelectorAll("img.lazy");
    lazyImages.forEach(img => {
      img.src = img.dataset.src;
    });
  });
</script>
```

This makes the page feel responsive, even if not everything has loaded yet.

Now - what if your site could predict what the user will click next? With preloading, you can fetch the next page before they request it:

```html
<link rel="preload" href="next-page.html" as="document">
```

This reduces perceived loading time to near zero when users navigate.

And finally, users don't like uncertainty. When they click a button, acknowledge their action instantly:

```html
<button onclick="this.innerText='⏳ Processing...'; setTimeout(() => this.innerText='✅ Done!', 2000);">
  Click Me
</button>
```

This means that, even if there's a delay, the user feels like something is happening.

So, in conclusion, improving perceived performance isn't just about raw speed, it's about how speed feels to the user. Use skeleton screens, prioritize important content, preload smartly, and give instant feedback to make your site feel faster.


## What Are Some Key Metrics for Measuring Performance?

### Description

To measure and improve web performance, we use key performance metrics like First Contentful Paint (or FCP), Speed Index, Total Blocking Time (or TBT), Bounce Rate, and Unique Users. Let's look at all of these metrics individually.

First Contentful Paint, or FCP. This measures how quickly the first piece of content, like a text or image, appears on the screen. A good FCP is regarded as a time below 1.8 seconds, and a poor FCP is usually above 3 seconds. You can check your FCP using Chrome DevTools like this:

Step 1: Open Chrome DevTools

- Open Google Chrome.

- Go to the webpage you want to test.

- Press "F12" or Right-click and "Inspect".

Step 2: Find and click the "Lighthouse" tab in the DevTools.

Step 3: Click the "Analyze page load" button and wait for the analyzation to finish.

Now we can analyze the results. We do this by scrolling down to the "Metrics" section and looking for the "First Contentful Paint" marker. We can see the exact time in milliseconds or seconds.

FCP and Interaction to Next Paint (or INP), that we looked at previously, are both performance metrics, but they measure different aspects of user experience. It's important not to get them mixed up.

As a reminder, FCP is about how fast users see content after loading, and INP is about how fast users see feedback after clicking or typing.

Next we have the Speed Index.

Speed Index measures how quickly visible parts of the page are painted. Lower scores mean better performance! You can check your Speed Index in the Lighthouse Reports.

We also have Total Blocking Time or TBT. This shows how long the main thread is blocked by heavy JavaScript tasks. If TBT is high, users experience laggy interactions. To improve TBT, break up long tasks and defer non-essential scripts.

Next we have the Bounce Rate. This is the percentage of visitors who leave without interacting. If your site has high bounce rates, it might be because your page is too slow.

And finally we have unique users. This metric tracks how many individual visitors come to your site. To view the bounce rate and unique users, you can use Google Analytics. It will allow you to monitor these metrics and improve engagement.


## What Are Some Common Performance Measurement Tools?

### Description

If you want to make your website faster and more responsive, you need the right tools to measure and optimize performance. Let's explore some common performance measurement tools and how they help.

First up, we have Chrome DevTools.

Chrome DevTools is a built-in tool inside Google Chrome that lets you analyze and debug performance in real-time. DevTools will show loading times, CPU usage, and render delays. It's especially useful for measuring First Contentful Paint, or FCP, which we know by now, is how fast a user sees the first visible content. If your website feels slow, DevTools will help you spot the bottlenecks.

Next up, Lighthouse.

Lighthouse is an automated tool that checks performance, SEO, and accessibility. To use it, simply open Chrome DevTools and go to the "Lighthouse" tab. Next, click "Analyze page load" and it will give you a score on how fast and optimized your site is, as well as provide recommendations to improve it. If you want a quick performance audit, Lighthouse is your go-to tool.

Now, let's talk about WebPageTest.

WebPageTest lets you test how your site loads from different locations and devices. All you have to do is visit WebPageTest.org, enter your website URL, choose a test location and browser and click "Start Test". It gives a detailed breakdown of your site's Speed Index, Total Blocking Time, and other key performance metrics. If you want to know how real users experience your site globally, WebPageTest is the tool for that.

Another great tool is Google PageSpeed Insights.

This tool analyzes your website and suggests quick improvements for both mobile and desktop. Just go to PageSpeed Insights, enter your URL, and click "Analyze". It will tell you what's slowing your site down and give specific recommendations — like optimizing images, removing render-blocking scripts, and reducing server response times. PageSpeed Insights is a fast and easy way to check how Google sees your site's performance.

Lastly, let's talk about Real User Monitoring, or RUM tools. Unlike lab tests, RUM tools track actual user behavior, showing how real visitors experience your site. Popular RUM tools include Google Analytics, which tracks page load times and bounce rates. And New Relic or Datadog, which Monitors real-time performance issues. If you want data from actual users, RUM tools are essential.

Each tool has different strengths, so use a combination to get the best insights. Start by testing with Chrome DevTools or Lighthouse, then dive deeper with WebPageTest and RUM tools.


## How Can You Use Performance Web APIs to Create Your Own Performance Measurement Tools?

### Description

While tools like Lighthouse and Chrome DevTools are great, sometimes you need custom insights tailored to your site.

That's where Performance Web APIs come in!

In this lecture, we'll break down how to use three key Web APIs to measure and analyze your website's speed.

But first, what are Performance Web APIs? 

Performance Web APIs let developers track how efficiently a webpage loads and responds, directly from code. These APIs allow you to measure page load times, track rendering and interaction delays and analyze JavaScript execution time.

With these APIs, you can build your own performance monitoring tools without relying on third-party software!

Let's explore three powerful Web APIs you can use today.

First up, `performance.now()`.

This API gives you high-precision timestamps (in milliseconds) to measure how long different parts of your site take to load.

Let's say you want to measure how fast a function runs:

```js
const start = performance.now();  
// Run some code here  
const end = performance.now();  

console.log(`Execution time: ${end - start}ms`);
```

This is more accurate than using `Date.now()` because it measures time in microseconds, avoiding clock drift issues. You can use it to track script execution time, event response delays and animation performance.

Next, the Performance Timing API.

This API gives you a breakdown on every single stage of page loading, from DNS lookup to `DOMContentLoaded`.

Want to measure how long your page takes to fully load?

```js
let [navigationTiming] = performance.getEntriesByType("navigation");

if (navigationTiming instanceof PerformanceNavigationTiming) {
  // Calculate time from navigation start to DOM content loaded
  const pageLoadTime =
    navigationTiming.domContentLoadedEventEnd - navigationTiming.startTime;

  console.log("DOM Content Loaded Time:", pageLoadTime, "ms");
}
```

Key metrics you can track with this API are DNS lookup time - or in other words the connection speed, Time to First Byte (TTFB) - or server response speed, and  `DOMContentLoaded` - or in other words, when the page is ready for interaction.

If your page load times are slow, this API pinpoints exactly where the delay happens!

And finally, let's talk about `PerformanceObserver`.

This API listens for performance events such as layout shifts, long tasks, and user interactions.

Want to monitor long-running JavaScript tasks?

```js
const observer = new PerformanceObserver((list) => {  
  list.getEntries().forEach((entry) => {  
    console.log(`Long task detected: ${entry.duration}ms`);  
  });  
});  

observer.observe({ type: "longtask", buffered: true });
```

And what can this API track? Well, it can track long tasks - or in other words, JavaScript that blocks rendering, layout shifts to detect UI jank, and First Input Delay (FID) - or how fast a page responds to user input.

If you want real-time performance tracking, this API is a game-changer.

So, which API should you use? Here's a quick comparison:

| Performance API        | Best For                                           |
| :--------------------- | :------------------------------------------------- |
| `performance.now()`    | Precise timing of functions and scripts            |
| Performance Timing API | Measuring full page load performance               |
| Performance Observer   | Real-time monitoring of interactions and rendering |

By combining these APIs, you can build your own performance measurement tools and track exactly what matters for your site most.


## What Are Some Techniques for Improving CSS Performance?

### Description

Every project is unique and you should carefully consider which ones of these techniques will be most helpful for your web application.

First, since all styles are parsed, you should remove any unnecessary styles from your CSS stylesheets.

You should also split your CSS styles into multiple files. This way, if a file is not required to render a specific web page, it will not be loaded and it won't block the rendering process.

By default, the browser assumes that all stylesheets should block the rendering process. But you can tell the browser when a stylesheet should be loaded by using the `media` attribute and a media query. 

In this example, the `print.css` stylesheet will only be applied when the document is being printed because it has the `media` attribute with the value `print`:

```html
<link rel="stylesheet" href="print.css" media="print" />
```

You can also minify your CSS files automatically to reduce their size during the build process and compress these files in the server where you host your web application.

Try to keep your CSS selectors as simple as possible and don't try to select more elements than necessary.

Take advantage of the cascading nature of CSS whenever possible. Some styles will be inherited.

Preloading resources with `rel="preload"` is another important technique. Critical assets should be loaded first.

Remember that CSS animations can have an impact on performance.

Animating certain CSS properties, such as dimensions, position, and layout, triggers a process called "reflow," during which the browser recalculates the position and geometry of certain elements on the page. This requires a repaint, which is computationally expensive.

Therefore, it's recommended to reduce the number of CSS animations as much as possible or at least give the user an option to toggle them on or off.

And even though fonts can enhance the visual presentation of your web application, they can have an impact on performance. Some fonts have large files, up to multiple megabytes. Try to use two or three fonts at most and use web-safe fonts whenever possible.

You may also consider preloading the most important fonts to have them ready for quick use.

These are some of the most important and commonly used techniques for optimizing CSS in web development. By incorporating them, you can optimize your website's performance to create a smooth user experience.


## What Are Some Techniques for Improving JavaScript Performance?

### Description

Let's review some of the most important techniques for improving JavaScript performance specifically.

You may find this surprising, but the first technique is using less JavaScript whenever possible.

If you're developing a simple static website, you may be able to do exactly the same without frameworks that rely on JavaScript.

You should also try to remove any unused JavaScript code and use simpler solutions, if possible.

For example, you may consider using built-in browser features instead of custom ones. These built-in browser features include form validation, the browser's built-in video player, and CSS animations instead of custom JavaScript animations.

Use as few animations as possible.

Reduce the amount of DOM manipulation on your JavaScript code, since this is computationally expensive.

Splitting your JavaScript code into modules that perform critical and non-critical tasks is also helpful. This way, you'll be able to preload the critical ones as soon as possible and defer the non-critical ones to render the page as fast as possible.

Pre-loading files does not guarantee that they will be available when you use them, but the download will start sooner, so the overall waiting time should be shorter.

Once your code is split into multiple files, you can minify them automatically during the build process to reduce their size and optimize their load time.

If an event listener is no longer necessary, you should remove it:

```js
element.removeEventListener("mousemove", handleMouseMove);
```

In this example, we remove the event listener for the `mousemove` event, so the `handleMouseMove` function is no longer called when the event is triggered. If you keep the event listener, the program will continue performing calculations that are no longer necessary, affecting the overall performance. This effect will be even more noticeable if you have multiple active event listeners simultaneously.

And since we're on the topic of events, it's recommended to use event delegation whenever possible.

This means that you don't need to set the event listeners on individual child elements. You can set it directly on the parent and the event will bubble up until it finds a parent that can handle it.

Optimizing JavaScript is crucial for developing fast and responsive web applications. In a real-world project, you'll constantly analyze the performance of your website to find areas for improvement.


## Module: Testing


### Lecture Block: Lecture Understanding The Different Types Of Testing


## What Is the Overall Purpose of Testing Your Applications?

### Description

Up until this point, you have been building tons of small projects in languages like HTML, CSS, JavaScript, and more. But how do you know if your projects are working correctly?

One option is to do what is called manual testing. This is where a tester will go through each part of the application and test out all of the different features to make sure it works correctly. If any bugs are uncovered in the testing process, the tester will report those bugs back to the software team so they can be fixed.

While it is important to manually test out your applications, often times it will not be enough. Real-world applications involve many components and services and can often be complex in nature. So only relying on manual testing will result in many bugs lying beneath the surface that can hurt the usability and maintainability of an application.

This is where automated testing comes in. You can write separate test code to check whether your application behaves as expected, without needing to manually click through it. Both manual and automated tests can be grouped into different types, depending on what they are testing.

Over the next few lectures, we are going to cover the different types of testing used in the industry like unit testing, end-to-end testing, functional testing and more.

Writing tests for your applications will help ensure that your code is doing what it is supposed to be doing. It is important that you start to familiarize yourself with the basics of testing because it will be something that you will need in a developer job.


## What Is the Software Development Life Cycle, and How Does It Relate to Testing?

### Description

When working on software teams, it is important to have a process for designing and building out new products and services. The Software Development Life Cycle is commonly used by software teams to build and deploy applications.

In this lecture, we will break down the different stages of the Software Development Life Cycle (SDLC) and the role that testing plays in it.

Here are the standard stages used in the Software Development Life Cycle:

- Planning stage

- Design stage

- Implementation stage

- Testing stage

- Deployment stage and

- Maintenance stage

Let's take a closer look at all of those stages in more detail.

In the planning stage, the development team collects requirements for the proposed work from the stakeholders. A stakeholder is someone with a vested interest in the success of the product or service. Examples of stakeholders could be investors, owners, or even other employees. The planning phase also includes estimating costs for the work and creating a schedule for when the work will be completed.

The next stage is the Design stage. In this phase, the software team breaks down the requirements and decide on the best approaches for solutions. This includes deciding on which external tools can be used to help things along and what internal tooling needs to be built to get the job done.

After the design stage, you have the implementation stage. This involves the software team breaking down the requirements into manageable tasks that they divide up amongst themselves and build out.

Once the implementation stage is complete, the software team moves into the testing stage. This involves manual and automated testing for the new work. Sometimes the team tests out the application throughout the entire development stage to catch and fix any issues that come up.

The next stage is the deployment stage. This is where the team deploys the new changes to a build or testing environment. This allows the team to test out the application some more and fix any issues before the changes go to production. The production application is the app that end users will use.

The last stage is the maintenance stage. This involves fixing any issues that arise from customers in the production application. This also involves monitoring the system for any possible improvements on the software.

Finally, there are different models of the Software Development Life Cycle used in the industry, such as Waterfall and Agile. The Waterfall model is where each phase of the life cycle needs to be completed before the next phase can begin. In contrast, the Agile model focuses on iterative development by breaking down work into sprints so teams can quickly make changes and deliver work over time.

By going through the Software Development Life Cycle, the development team and stakeholders can be on the same page when it comes to requirements, cost estimates, and schedules. This makes for more efficient collaboration and communication across the board.


## What Is Unit Testing?

### Description

As you design your applications, you will often have a series of small functions responsible for one thing. This is known as the "single responsibility principle." When you have a series of small functions, it is best to test these functions to ensure that everything works as expected. In this lecture, we will take a look at how to create a unit test using the popular Jest testing framework.

In this example, we are going to create a function that is responsible for returning a newly formatted string:

```js
export function getFormattedWord(str) {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1);
}
```

This `getFormattedWord` function has a parameter called `str` and will first check if the `str` is empty. If so, then an empty string is returned. Otherwise, a new string is returned where the first letter is capitalized. We are exporting this function so we can use it in a test file.

In a separate `getFormattedWord.test.js` file, we can write some tests to verify that the function is doing what it is supposed to be doing.

At the top of the `getFormattedWord.test.js` file, we need to first import the function like this:

```js
import { getFormattedWord } from "./getFormattedWord.js";
```

Then we need to install the Jest package by using `npm i jest`. Then we can add a test to check that a word made up of lowercase characters, `hello`, is properly formatted to `Hello`, which starts with a capital `H`:

```js
test('capitalizes the first letter of a word', () => {
  expect(getFormattedWord('hello')).toBe('Hello');
});
```

The `expect` function is used to test a value. It's combined with a matcher, which is a function that checks whether the value behaves as expected. In this case the matcher is `toBe()`. Jest has a variety of matchers to help you test for truthiness, strings, numbers, and more.

One way to run your tests is by adding an npm script to your `package.json` file. Here's an example script for the Jest framework:

```js
"scripts": {
  "test": "jest"
},
```

Then just run `npm run test` in your terminal to run your tests. If your tests pass, you should see something in the terminal like this:

```sh
PASS ./getFormattedWord.test.js
  ✓ capitalizes the first letter of a word (1 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        0.103 s, estimated 1 s
Ran all test suites.
```

To see what a failing test looks like, we can intentionally break the test by updating the function to the following:

```js
export function getFormattedWord(str) {
  if (!str) return '';
  return "This is incorrect";
}
```

Now when you run the `npm run test` command, there will be an error message because the test was expecting a different result:

```sh
FAIL ./getFormattedWord.test.js
  ✕ capitalizes the first letter of a word (1 ms)

  ● capitalizes the first letter of a word

  expect(received).toBe(expected) // Object.is equality

  Expected: "Hello"
  Received: "This is incorrect"

    2 |
    3 | test('capitalizes the first letter of a word', () => {
    4 |   expect(getFormattedWord('hello')).toBe('Hello');
                                            ^
    5 | });
    6 |

    at Object.toBe (getFormattedWord.test.js:4:37)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 total
Snapshots:   0 total
Time:        0.121 s, estimated 1 s
Ran all test suites.
```

Now we can update our function back to the original here:

```js
export function getFormattedWord(str) {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1);
}
```

Add another test to check for cases where no argument is provided to `getFormattedWord`:

```js
test("returns an empty string when no argument is provided", () => {
  expect(getFormattedWord()).toBe("");
});
```

There are other tests you can add to make things more robust, but these first couple of tests are a good introduction to unit testing.

When it comes to testing JavaScript applications some common testing frameworks include Jest, Mocha, and Vitest.

Unit testing is important because it will help you catch more bugs in your programs, and ensure that everything works as expected. It also can serve as a form of documentation for your application because it is meant to represent the expected behavior for your code.


## What Are BDD and TDD?

### Description

There are two types of testing approaches that you should be aware of in software development. Those approaches are TDD (Test-Driven Development) and BDD (Behavior-Driven Development).

Let's first take a look at TDD. Test-Driven Development is a methodology that emphasizes writing tests first before building out the features for an application.

Here is the typical process for TDD:

1. Write a test

2. Ensure that it fails

3. Write the code for that test

4. Ensure that the test passes this time

5. Make any necessary refactors to the code

Repeat steps 1-5.

Writing tests before building out features provides real-time feedback to developers during the development process. It also helps with catching bugs earlier on in the development stage.

While some software teams will choose to follow the TDD approach, TDD is a polarizing topic in the industry. You will find tons of articles and videos out there both advocating for or bashing TDD. Regardless of how you feel about this approach, it is important to be aware of it because you might come across it in real-world scenarios.

The second testing approach we will take a look at is Behavior-Driven Development (BDD). Behavior-Driven Development is the approach of aligning a series of tests with business goals. These tests should be written in a language that can be understood by both technical and non-technical individuals.

When testing for specific behaviors in a software application, BDD commonly uses the Gherkin language, which is used in businesses to describe behaviors and scenarios. The Gherkin language uses Given, When, and Then statements when describing scenarios.

Here is an example:

**Scenario:** Creating a New Blog Post

**Given** the user is logged into their account and is on the "Create New Post" page,

**When** the user enters a title and content for the post and clicks the "Publish" button,

**Then** the blog post should be saved and displayed on the homepage with the correct title, content, and timestamp.

You first want to define a scenario. Example scenarios include when a user logs into an application or places an order on a website. In this example, the scenario is for a user creating a new blog post on a site.

After the scenario is defined, you should start with a Given statement. This provides context for where the user is starting before performing an action. The When statement is used to represent the action taken by the user.

Finally, the Then statement is used to represent the desired outcome from the previous action taken by the user. Once you define all of your scenarios, you can write tests for each scenario.

Examples of BDD testing frameworks include Cucumber, JBehave, and SpecFlow.


## How Do Assertions Work in Unit Testing?

### Description

You were first introduced to assertions and unit testing in a previous lecture. But as a review, unit testing is when you check the output of individual functions or components independently, in contrast with testing the final output of the entire program. Assertions are used to test that the code is behaving as expected.

In this lecture, we are going to take a closer look at assertions in unit tests and explore some best practices.

A commonly used assertion library is Chai. This is the same library used inside of the freeCodeCamp codebase. Whenever you go through a workshop or lab, there is an automated test suite that runs against your code to ensure that your code is behaving the way it is supposed to.

Let's take a look at a few examples that are from the Full Stack Developer Curriculum.

In Build a Calculator workshop, Step 1 is testing for a function called `addTwoAndSeven`:

```js
assert.isFunction(addTwoAndSeven);
```

That assertion checks that the provided code contains a function named `addTwoAndSeven`. If the user creates an array, string, or anything else that's not a function and assigns it to `addTwoAndSeven`, then the test will fail.

Let's take a look at another assertion from later in the workshop:

```js
assert.equal(addThreeAndFour(), 7);
```

This assertion checks that the return value from the `addThreeAndFour` function is equal to the number `7`. If the return value does not equal `7`, then the test will fail.

There are many more asserts built into Chai, like ones that check if a value is a boolean, if an object has a certain property name, or if a value is `null`. Other common JavaScript assertion libraries are should.js and expect.js.

Regardless of which assertion library you are working with, there are a few best practices to be aware of. The first is to write clear assert messages. Clear and meaningful assert messages should describe the intent behind it. Otherwise, it will be difficult to locate which tests are failing.

Another best practice is to write descriptive failure messages. A descriptive failure message should state which condition is true. This will help you figure out why a particular assert is failing.

As you continue learning to code, it's important to familiarize yourself with testing and start writing tests for your personal projects. Doing this will go a long way in helping you prepare for your first developer job.


## What Are the Differences Between Mocking, Faking, and Stubbing? 

### Description

Mocking is the process of replacing real data with false data that simulates the behavior of real components. This allows testers and developers to test for specific components in the application without having to rely on external dependencies.

A common use case for mocking data would be when dealing with API calls. Imagine you have a fetch call like this in your application:

```js
export const postService = {
  async getPosts() {
    const response = await fetch("https://api.example.com/posts");
    return response.json();
  },
};
```

If you need to test the `postService` function, you could mock the API response instead of making continuous API calls to fetch the data. Fetching from an API takes time and depends on external factors like network availability and server responses. Mocking the API response removes those external factors and allows testers to work with a predictable, controlled data set.

Here is an example mock API response:

```json
[
  {
    "id": 1,
    "title": "Understanding Async/Await in JavaScript",
    "content": "Async/Await makes asynchronous code look and behave like synchronous code...",
    "author": "Jane Doe",
    "created_at": "2025-04-10T14:32:00Z"
  },
  {
    "id": 2,
    "title": "10 Tips for Writing Clean Code",
    "content": "Clean code is not just about code formatting. It involves naming, architecture...",
    "author": "John Smith",
    "created_at": "2025-04-08T09:21:00Z"
  },
  {
    "id": 3,
    "title": "Exploring React 19 Features",
    "content": "React 19 comes with exciting features like new hooks and better performance...",
    "author": "Alex Lee",
    "created_at": "2025-04-07T18:47:00Z"
  }
]
```

Now that we understand what mocking is, let's compare it with stubbing. Stubs are objects that return pre-defined responses or dummy data for an expected behavior in an application. For example, you can stub the behavior for a database connection in your tests without having to rely on an actual database connection.

Here is an example of a stub in Jest:

```js
import { postService } from "./postService";
import { db } from "./db";

jest.mock("./db", () => ({
  db: {
    fetchPosts: jest.fn(),
  },
}));

test("should return stubbed posts", async () => {
  const fakePosts = [
    { id: 1, title: "Stubbed Post", content: "This is a stubbed post." },
  ];

  db.fetchPosts.mockResolvedValue(fakePosts);

  const posts = await postService.getPosts();

  expect(posts).toEqual(fakePosts);
});
```

`db.fetchPosts.mockResolvedValue(fakePosts);` is the stub in this example.

The last component to discuss are fakes. Fakes are simplified versions of real components without the complexity or side effects of the real thing. For example, you can fake a database by storing the data in memory instead of interacting with the real database. This will allow you to mimic database operations in memory, which will be much faster than dealing with the real database. Another common example would be to use fakes when working with file systems. You can create a fake file system in place of the real one when it comes to testing.

As you continue to build out more complex software applications, consider using mocks, stubs, or fakes where appropriate in your testing.


## What Is Functional Testing, and How Does It Differ from Unit Testing?

### Description

In prior lectures, you learned how to test small units of code through unit testing. Well, unit testing is part of functional testing. Functional testing checks if the features and functions of the application work as expected.

In this lecture, we will take a look at the differences between functional and non-functional testing.

The goal of functional testing is to test the system as a whole against multiple scenarios to ensure that the system works as expected. An example of functional testing would be smoke testing. Smoke testing is where you perform a preliminary check on the system for basic or critical issues before more extensive testing is done.

In contrast, non-functional testing focuses on things like performance and reliability.

A real test scenario for functional testing would be a user login. A user should be able to log in to the application with their username and password. If successful, they should be able to access their account information. If there is an issue, then that error needs to be handled properly. When you are writing tests, you need to account for all types of success and failure scenarios.

An example of non-functional testing would be to test the performance of your application under different network conditions. In a future lecture, you will learn more about performance testing.

The reasons why functional testing is so important is because you want to identify bugs early on in your application. You also want to make sure that your application meets the requirements that were laid out at the beginning of the planning phase. Lastly, you want to ensure that your users have a good user experience. Users should not struggle to use your application or be blocked by broken features and system failures.


## What Is End-to-End Testing?

### Description

End-to-end testing, or E2E for short, tests real-world scenarios from the user's perspective. Examples of E2E testing scenarios include testing the registration and login process or testing the checkout for an e-commerce site.

To better understand how end-to-end testing works, let's take a look at a real-world example from the freeCodeCamp codebase. This example uses Playwright, a popular end-to-end testing framework developed by Microsoft.

Inside the freeCodeCamp codebase, there is a directory called `e2e` which holds tests for donations, certifications, exams and more. Inside the directory, there is a `donate-page-donor.spec.ts` file which has tests for the authenticated donor supporter page.

The first step is to navigate to the donation page as a demo user who is already a supporter:

```js
test.beforeEach(async ({ page }) => {
  execSync("node ./tools/scripts/seed/seed-demo-user --set-true isDonating");
  await page.goto("/donate");
});
```

Since there are multiple tests in this file, the `beforeEach` hook will run before each of the tests.

Once the user is on the donation page, they will see a thank you message with suggestions on how to support freeCodeCamp further. Here are just a few of the tests to check for some of the text found on the donation page:

```js
test("should render the donate page correctly", async ({ page }) => {
  await expect(
    page.getByText("Thank you for your continued support")
  ).toBeVisible();

  await expect(
    page.getByText(
      "Your contributions are crucial in creating resources that empower millions of people to learn new skills and support their families."
    )
  ).toBeVisible();

  ...
});
```

There are also tests to check that the donor has a supporter link in the menu bar, as well as a special stylized border around their avatar to indicate they are a supporter:

```js
test("The menu should have a supporters link", async ({ page }) => {
  const menuButton = page.getByTestId("header-menu-button");
  const menu = page.getByTestId("header-menu");

  await expect(menuButton).toBeVisible();
  await menuButton.click();

  await expect(menu).toBeVisible();

  await expect(page.getByRole("link", { name: "Supporters" })).toBeVisible();
});

test("The Avatar should have a special border for donors", async ({ page }) => {
  const container = page.locator(".avatar-container");
  await expect(container).toHaveClass("avatar-container gold-border");
});
```

By having these types of detailed tests, you can increase the test coverage for your application beyond just unit tests. End-to-end tests also help ensure that your application behaves correctly, and is predictable for users. Examples of other end-to-end testing tools include Cypress, Selenium, and Puppeteer.

While end-to-end testing is important, it is expensive because it is time-consuming to set up, design, and maintain. E2E tests are great for critical user flows, while unit tests are great for testing small units in the application.


## What Is Usability Testing, and What Does the Process Look Like?

### Description

Usability testing is when you have real users interacting with the application to discover if there are any design, user experience, or functionality issues in the app. This type of testing is important because this feedback will help ensure that the application meets the needs of the users.

The four common types of usability testing are explorative, comparative, assessment and validation testing.

Let's first start with explorative usability testing. This type of testing involves users interacting with the different features of the application to better understand how they work. The goal here is to identify any potential issues in the application so they can be addressed early on and resolved.

The second type of usability testing is comparative testing. This is where you compare your application's user experience with similar applications in the marketplace. The goal is to see where your application falls short compared to the competition so those areas can be improved on.

The third type of usability testing is assessment testing. This is where you study how intuitive the application is to use and if there are any major blockers for users. This type of testing will result in reduced costs and headaches once the application is live to thousands or even millions of users down the line.

The last type of usability testing is validation testing. This is where you identify any major issues that will prevent the user from using the application effectively. This type of testing usually happens after the initial development stage and just before the final release of the application.

There are many tools out there to assist with usability testing, but here are a few popular ones to be aware of:

- Loop11

- Maze

- Userbrain

- UserTesting and

- UXTweak

It is important to note that functional testing is not the same as usability testing. Functional testing focuses on the functionality of the application while usability testing focuses on the intuitiveness of the application by users.


## What Is Compatibility Testing?

### Description

When you build out web applications at scale, you will need to think beyond your personal computing environment. How will these applications work on a variety of devices, operating systems, and browsers? Well, this is where compatibility testing comes in.

The goal of compatibility testing is to see how well your software works in a variety of different computing environments. This provides the team with the ability to catch bugs before they reach production and will help contribute to a smoother product launch.

Different types of compatibility testing include backwards and forwards compatibility, hardware testing, operating systems, networks, browsers, and mobile devices.

Let's take a look at each of the types in more detail by starting with backwards and forwards compatibility. Backwards compatibility refers to when current software is compatible with earlier versions. Forwards compatibility is when software and systems will work with future versions of itself.

The next type of testing is for hardware. Hardware compatibility testing focuses on the software's ability to work properly in different hardware configurations. This includes components like processors, memory, different storage types, and graphics cards.

Another type of compatibility testing is for operating systems. You don't want to design software that works smoothly on Mac devices but has bugs on Windows or vice versa. You also need to consider Linux distributions like Ubuntu and Fedora.

The next type of testing is network compatibility testing. You will have users working with different network speeds, protocols, security settings, and more. Therefore, software teams will need to be mindful of all of those different conditions when testing.

Then, there's browser compatibility testing. There are a few popular browsers in the market like Google Chrome, Safari, Firefox, and more. Since all browsers work slightly differently, it's important to test your web application thoroughly and make sure your web applications work consistently across many browsers.

The last type of testing is mobile testing. There was a time in web development when most developers didn't think about testing for mobile devices. This was because, in the early 2000s, mobile devices weren't nearly as powerful or widely used as they are today. But now, tens of millions of people visit websites on phones and tablets. So, it is important to ensure that your software applications work on a variety of Android and iOS devices.

Those are just a few types of testing that you will need to consider when building out your applications. While this might seem like a lot of extra work, it is important to perform compatibility tests because you do want to ensure that your applications work in a variety of computing environments.


## What Is Performance Testing?

### Description

If a software application is slow to respond or unstable, that will lead to a poor user experience. Performance testing is what you do when you test an application's speed, responsiveness, scalability, and stability under different workloads. The goal is to resolve any type of performance bottleneck before it reaches your users.

In this lecture, we will go through a few types of performance testing.

The first type is load testing. A load in this context refers to the amount of work or demand put on a system. Load testing determines how a system behaves during normal and peak load times. The goal is to analyze metrics like response times and resource usage and determine if the current software build is ready or not.

Another type of testing is stress testing. This is where you test your application in extreme loads and see how well your system responds to the higher load. The goal here is to identify any bottlenecks and vulnerabilities by testing the system beyond its limits.

The next type of performance testing is soak testing, also known as endurance testing. This is a type of load testing where you test the system with a higher load for an extended period of time. The goal here is to determine any types of memory leaks and performance degradation.

Another type of testing is spike testing. This is where you dramatically increase and decrease the loads and analyze the system's reactions to the changes. The goal here is to see if your system will fail with these dramatic changes in the load.

Finally, there's breakpoint testing, also known as capacity testing. This is where the load will slowly increment over time to the point where the system starts to fail or degrade. The goal here is to better understand the system's limits and capacities.

These are just a few types of performance testing you can do on your applications. Since performance plays a vital role in software development, it is important that your perform these types of tests to ensure that your application doesn't have any major issues and provides a smooth experience for users.


## What Is Security Testing?

### Description

The web is a powerful place filled with a wealth of information and activities. But it can also be a dangerous place if you are not careful. There are many hackers and cyber criminals out there looking for new ways to breach websites and compromise data.

You've probably heard of a few high-profile data breaches that affected billion-dollar companies like Meta and Microsoft. When it comes to working on web applications, you will need to do thorough security testing to help identity vulnerabilities and weaknesses.

Here are a few principles to be aware of when it comes to performing security audits and testing:

- Confidentiality: This protects against the release of sensitive information to other recipients that aren't the intended recipient.

- Integrity: This involves preventing malicious users from modifying user information.

- Authentication: This involves verifying the user's identity to ensure that they are allowed to use that system.

- Authorization: This is the process of determining what actions authenticated users are allowed to perform or which parts of the system they are permitted to access.

- Availability: This ensures that information and services are available to authorized users when they need it.

- Non-repudiation: This ensures that both the sender and recipient have proof of delivery and verification of the sender's identity. It protects against the sender denying having sent the information.

Now that we understand the reasoning behind security testing, let's take a look at a few common security threats:

- Cross-site Scripting (XSS): You learned about this in an earlier lecture. But as a refresher, XSS attacks happen when an attacker injects malicious scripts into a web page that is viewed by other users. These scripts can then execute in the context of the victim's browser, potentially stealing cookies and session data or performing other malicious actions without the user's knowledge or consent.

- SQL Injection: SQL is a language for managing and storing information in a relational database. SQL injection allows malicious users to inject malicious code into a database. You will learn more SQL, relational databases, and SQL injection in a future module.

- Denial-of-Service (DoS) attack: This is when malicious users flood a website with a high number of requests or traffic, causing the server to slow down and possibly crash, making the site unavailable to users.

There are many more types of security threats, but there are many tools you can use to help protect your web applications and make them more secure. Here are the broad categories that security testing tools fall into:

- Static application security testing: These tools are used to evaluate the source code for an application to identify security vulnerabilities.

- Dynamic application security testing (DAST): These tools interface with the application's frontend to uncover potential security weaknesses. Unlike static application security testing, DAST tools do not have access to the source code.

Another type of security testing is penetration testing (or pentest for short). This involves creating simulated cyberattacks on the application to identify any vulnerabilities in the system. Mid to large-sized companies might have a team of dedicated cybersecurity professionals that perform pentests on a regular basis as part of their regular security audits.

The world of cybersecurity is very vast and detailed. But every developer should understand a few common threats against web applications and ways to guard against them.


## What Is A/B Testing?

### Description

Most of you have a select group of websites that you visit every day. This might include sites like X, Discord, or freeCodeCamp. But have you ever wondered why you often see small changes to the design of your most frequently visited pages? Well, this doesn't happen by accident.

Companies spend a lot of time analyzing analytics and studying user behavior. They do this to identify pain points in the user experience for their site or application. These companies then use that data to come up with solutions to create a smoother user experience.

One of the techniques companies employ is called A/B testing. This type of testing involves comparing two versions of a page or application and studying which version performs better. Sometimes, this type of testing is known as bucket or split testing.

Let's take a look at an example so you can better understand the concept. Imagine you have a landing page with some introductory text and a CTA (call to action) button. Remember that a CTA button is used to encourage users to perform a specific action, like donate or log in.

As you go through the site analytics, you realize that the click-through rate for the CTA is low. So you try redesigning that button so it's more prominent on the page. You increase the size of the button and change the button color from blue to green. To actually see if those changes made a difference, you can use A/B testing.

You can randomly divide your users into two groups. Group A is the control group, which sees the original version of the page with the  smaller blue button, while group B is the experimental group, which see the new version of the page with the larger green button. If the new version of the page results in a higher click-through rate, then you can confidently replace the old button styling with the new one.

Examples of tools to use for A/B testing include GrowthBook and LaunchDarkly.

There are many common use cases for A/B testing like testing ads, email campaigns, or new product features. A/B testing allows you to make more data-driven decisions and continually improve the user experience.


## What Is Alpha and Beta Testing?

### Description

Once the initial development and software testing are complete, it is important to have the application tested by testers and real users. This is where alpha and beta testing come in.

Alpha testing is done by a select group of testers who go through the application to ensure there are no bugs before it is released into the marketplace. This is part of acceptance testing, which ensures that the software application meets the needs of users before its release.

Alpha testing also utilizes both white and black box testing techniques. Black box testing only focuses on the expected behavior of the application, whereas white box testing involves the tester knowing the internal components and performing tests on that.

After the alpha testing phase, there is the beta testing phase. This is where the application is made available to real users. Actual users can interact with the application and provide feedback. This is a form of user acceptance testing which ensures that the application meets the business requirements as well as user needs.

While both stages of testing can be time-consuming, it is important to perform alpha and beta tests on your applications. This will help ensure that the application is truly ready for the marketplace and meets the needs of its users.


## What Is Regression Testing?

### Description

As an application continues to grow, it is not uncommon to have situations where new changes unintentionally break existing functionality. This is known as a regression.

To help catch these issues before they happen, you can use regression testing. Regression testing is when you re-run functional tests against parts of your application to ensure that everything still works as expected. If you've implemented bug fixes, enhancements, or even have updates to your configuration, then it's a good idea to perform regression testing.

There are different tools that you can use to perform regression testing. They include Puppeteer, Playwright, Selenium, and Cypress.

There are also a few testing techniques to be aware of when it comes to regression testing. The first is called unit regression testing. This is where you have a list of items that need to be tested each time major changes or fixes are implemented into the app.

Another testing technique is called partial regression testing. This involves targeted approaches to ensure that new changes have not broken specific aspects of the application.

Finally, there's complete regression testing. This is the most time-consuming and detailed option, which looks at all the functionalities affected by the recent changes in the codebase and runs tests against them.

It's important to note that retesting and regression testing are different. Retesting is used to check for known issues and ensure that they have been resolved, whereas regression testing searches for unknown issues that might have occurred through recent changes in the codebase.


## Module: Css Libraries And Frameworks


### Lecture Block: Lecture Working With Css Libraries And Frameworks


## What Is a CSS Framework, and What Are Some Advantages and Disadvantages of Using It?

### Description

As you work CSS, you may experience certain challenges, such as keeping the styles consistent and compatible across browsers, avoiding repetition, and handling the growing complexity and number of CSS files across your project. CSS frameworks are very helpful to prevent these issues from the start.

A CSS framework consists of pre-written CSS code that you can use to style your HTML elements.

By using a CSS framework, you can speed up your workflow, create a uniform visual style across the website, make your design look consistent across multiple browsers, and overall keep your CSS code more organized.

You can think of a CSS framework as toolbox, where you can quickly find a style or component that fits your needs and use it right away, without having to specify it yourself using CSS properties. These frameworks often include pre-defined styles and components that you can use very easily, including styles for creating responsive layouts.

Some of the most popular CSS frameworks are Tailwind CSS, Bootstrap, Materialize, and Foundation.

Let's talk a little bit about the two types of CSS frameworks: utility-first CSS frameworks, and component-based CSS frameworks.

Tailwind CSS is a utility-first CSS framework. This means that it has small classes with very specific purposes, like setting the margin, padding, or background color. You can usually assign these small classes directly to the HTML elements.

For example:

```html
<button class="bg-blue-500 text-white font-bold py-2 px-4 rounded-full hover:bg-blue-700">
  Button
</button>
```

This button will have a blue background with white and bold text, a vertical padding of 2 rem, a horizontal padding of 4 rem, and rounded borders. The class `hover:bg-blue-700` will turn the background dark blue when the user hovers over it with the mouse.

As you can see, Tailwind CSS classes are very granular, so they can be applied to individual HTML elements as needed.

In contrast, Bootstrap is a component-based CSS framework. It has pre-built components with pre-defined styles that you can easily add to your website. These components are usually available in the official documentation of the CSS framework, where you can copy and paste them quickly into your project.

For example, if you want to create a list group in Bootstrap, you would write something like this in HTML:

```html
<div class="card" style="width: 25rem;">
  <ul class="list-group list-group-flush">
    <li class="list-group-item">HTML</li>
    <li class="list-group-item">CSS</li>
    <li class="list-group-item">JavaScript</li>
  </ul>
</div>
```

These pre-defined classes will automatically apply standard styles to the card, list group, and list group items.

Notice that here, instead of adding small and general classes, we are adding the entire component, including the HTML structure. This is why Bootstrap is component-based.

```html
<div class="card" style="width: 25rem;">
  <ul class="list-group list-group-flush">
    <li class="list-group-item">HTML</li>
    <li class="list-group-item">CSS</li>
    <li class="list-group-item">JavaScript</li>
  </ul>
</div>
```

While CSS frameworks have many advantages, they also have certain disadvantages. It's important that you know both of them to make an informed decision.

Since CSS frameworks rely on pre-defined styles, if you try to add custom CSS on top them, specificity issues may arise. The selectors used by the framework may have a higher specificity than the selectors that you use in your custom CSS, so the correct style may not be displayed. To solve this, you will need to use a more specific CSS selector, so this may bring some additional challenges.

They can also limit uniqueness to a certain extent because their standard styles are used widely across many websites. However, this can be addressed by customizing the CSS with your unique styles. 

And finally, you should consider potential performance issues that CSS frameworks might introduce. Some frameworks are quite large, and may take some time to load.

As a developer, you will decide if using a CSS framework is helpful for your project, if using entirely custom CSS is better, or perhaps a mix of both.


## What Is the Value of Using a CSS Preprocessor, and What Are Some Disadvantages?

### Description

A CSS preprocessor is a tool that extends standard CSS with powerful features like variables, mixins, nesting, and selector inheritance. 

Some of these features, like variables and nesting, are now supported or are getting more support in native CSS, and this trend is very likely to continue. However, earlier versions of native CSS did not support these features.

That is why CSS preprocessors became so widely used in the first place. They take the CSS rules and styles you write, along with their extended syntax, and compile them into a native CSS file that browsers can understand.

By using a CSS preprocessor, you can structure your CSS code in a more reusable and logical way. You will also have access to powerful features, like mixins, that are not directly supported by CSS.

Some of the most popular CSS preprocessors are Sass, Less, and Stylus.

Let's talk about Sass.

Sass stands for "Syntactically Awesome Style Sheets." It's compatible with all versions of CSS and maintained by a large community of developers.

Sass supports features like:

- Variables, so you can store and reuse values throughout the spreadsheet.

- Nested CSS rules, so you can create a visual hierarchy in your file.

- Modules, so you can split your styles into multiple stylesheets.

- Mixins, so you can reuse CSS declarations throughout your site.

- Inheritance, so multiple CSS selectors can share properties.

- And operators, for basic mathematical operations.

Sass also supports two syntaxes.

The SCSS syntax stands for Sassy CSS, which is a superset of CSS. This means that SCSS expands the basic syntax of CSS.

SCSS is the most common syntax that you'll use and find when working with Sass. It requires the use of curly braces (`{` and `}`) around CSS properties and semicolons (`;`) at the end of CSS declarations, just like native CSS.

These files have a `.scss` extension. Here is an example:

```scss
$primary-color: #3498eb;

header {
  background-color: $primary-color;
}
```

What you see here, at the top, is a variable defined in SCSS. This variable is used in the CSS rule below.

Let's compare SCSS with a less-frequently used syntax, the indented syntax. This is also known as the "Sass syntax" since it was Sass's original syntax.

This syntax relies on indentation to define the rules. Here is an example:

```scss
$primary-color: #3498eb

header
  background-color: $primary-color
```

Notice that there are no curly braces around the CSS rule, or semi-colons at the end of CSS declarations. At the top, you can also see a variable. Notice that its name starts with a dollar sign (`$`) in this syntax, which is different than native CSS variables, but works very similarly.

Sass also supports a powerful feature, called mixins. 

Mixins allow you to group multiple CSS properties and their values under the name and reuse that block of CSS code throughout your stylesheet.

This makes your CSS code less repetitive and easier to maintain because, if you change something in that block, the change is applied everywhere you use the mixin.

Since mixins can have custom and descriptive names, they can be helpful to understand what each block of CSS code does, which can make your stylesheets easier to understand.

And mixins also promote consistency in stylesheets by applying uniform styles.

This is an example of a mixin in SCSS syntax:

```scss
@mixin center-flex {
  display: flex;
  justify-content: center;
  align-items: center;
}
```

To define a mixin, you start by writing the `@mixin` at-rule, followed by the name of the mixin. In this case, the mixin is called `center-flex`. It has three CSS properties to center elements using Flexbox.

Then, once you have your mixin defined, you would use the `@include` at-rule to include those properties in a CSS rule. You just need to write `@include` followed by the name of the mixin. In this case, the name is `center-flex`:

```scss
section {
  @include center-flex;
  height: 500px;
  background-color: #3289a8;
}
```

This is the full code with the mixin and the CSS rule:

```scss
@mixin center-flex {
  display: flex;
  justify-content: center;
  align-items: center;
}

section {
  @include center-flex;
  height: 500px;
  background-color: #3289a8;
}
```

You can include the mixin in as many CSS rules as needed. If you need to make any changes, you would only need to change the mixin itself and the changes would be applied everywhere automatically. This example is in SCSS syntax. Notice that it has the curly braces and the semicolons.

Here is the equivalent in indented syntax, also known as Sass syntax, without the curly braces or semicolons:

```scss
@mixin center-flex
  display: flex
  justify-content: center
  align-items: center

section
  @include center-flex
  height: 500px
  background-color: #3289a8
```

And this is the compiled CSS code, what the browser will actually interpret after the file is compiled into native CSS:

```css
section {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 500px;
  background-color: #3289a8;
}
```

Notice that it includes the three mixin properties at the top: `display`, `justify-content`, and `align-items`.

This is only a simple example of what CSS preprocessors are capable of. They have many powerful features that are worth learning and applying in your daily workflow.

However, they do have potential disadvantages that you should be aware of.

First, CSS preprocessors have to compile the CSS rules into standard CSS. While the potential overhead of this compilation process is often minimal in terms of time and resources, it is something that you should consider for real-world projects.

Next, they can create debugging challenges, since browsers use the compiled CSS directly. Finding out what is generating a problematic style from the extended syntax can take a few extra steps when compared to standard CSS.

However, the advantages of CSS preprocessors usually outweigh their disadvantages, especially for complex projects. They can be very helpful for writing cleaner, reusable, less repetitive, and scalable CSS.


## Module: Typescript Fundamentals


### Lecture Block: Lecture Introduction To Typescript


## What Is TypeScript, and Why Is It Used in the Industry?

### Description

JavaScript is considered a dynamically-typed language. This means that variables can receive any values at run time - declaring a variable as a number does not prevent you from assigning it a string value later, and function parameters can be passed any value.

The challenge of a dynamically-typed language is that the lack of type safety can introduce errors if you are not careful. TypeScript extends the JavaScript language to include static typing, which helps catch those errors before you even deploy your code. But how does it work?

Consider this JavaScript function:

```js
const getRandomValue = (array) => {
  return array[Math.floor(Math.random() * array.length)];
}
```

Our `getRandomValue` function takes an array and returns a random value from that array. But because JavaScript does not validate types, there is nothing preventing you from calling the function with a number:

```js
console.log(getRandomValue(10));
```

The console output for the current example will return `undefined` because it was expecting an array instead of a number.

But with TypeScript you can define a type for the array parameter:

```js
const getRandomValue = (array: string[]) => {
  return array[Math.floor(Math.random() * array.length)];
}
```

This type definition tells TypeScript that the array argument must be an array of strings. Then when you call `getRandomValue` and pass it a number, you get a different type of error called a compiler error.

Most JavaScript runtime environments, such as a browser or Node.js, cannot run TypeScript natively. Instead, you first need to compile, or translate, TypeScript code into regular JavaScript. You can do that with the built-in compiler that comes with the TypeScript language. When you run the compiler, TypeScript will evaluate your code and throw an error for any issues where the types don't match - such as passing a number into a function that expects an array.

You'll learn more about how these types work in the next few lectures. But it's this extra safety that makes TypeScript an appealing language for many developers and organizations.


## How Do the Different Types Work in TypeScript?

### Description

You've already seen one in the previous lecture: `string[]`, which represents an array of strings. But how does that actually work?

For the primitive data types `string`, `null`, `undefined`, `number`, `boolean`, and `bigint`, TypeScript offers corresponding type keywords. In our example, we are using these types to annotate our variables:

```js
let str: string = "Naomi";
let num: number = 42;
let bool: boolean = true;
let nope: null = null;
let nada: undefined = undefined;
```

Now, we have explicitly declared `str` as `string` - which might seem confusing because we assigned it a string value already, but this annotation ensures that we cannot reassign a different value type (like a number) to that variable.

But what about arrays and objects? Well, you've already seen the syntax for an array! You can define an array of specific type with two different syntaxes:

```js
const arrOne: string[] = ["Naomi"];
const arrTwo: Array<string> = ["Camperchan"];
```

Fundamentally, these two syntaxes are the same, and the choice between the two is generally a matter of preference.

Objects get a bit more complicated. You can define the exact structure of an object:

```js
const obj: { a: string, b: number } = { a: "Naomi", b: 42 };
```

This syntax means that property `a` must always be a string, property `b` must always be a number, and you cannot add or remove properties.

But maybe you don't want to restrict the properties? Maybe you want an object with any keys, but the values all need to be strings. There are two ways you can do this:

```js
const objOne: Record<string, string> = {};
const objTwo: { [key: string]: string } = {};
```

Like the array types, these are fundamentally similar. With these object types, you must define both the type of the keys and the type of the values. Keys must always be strings, but you can define custom string types to further restrict those keys.

In addition to these types, TypeScript offers four other helpful types. The first is `any`, which indicates that a value can have any type. This is effectively the Konami Code of TypeScript - it tells the compiler to stop caring about the type of that variable and let you do whatever.

The second is `unknown`, which is generally preferred over `any`. The `unknown` type tells TypeScript that you do care about the type of the value, but you don't actually know what it is. If you then try to perform type-specific actions (like a subtraction operator, or the `slice()` method to perform a specific string operation), TypeScript will expect you to narrow down the type of that value first. You'll learn more about type narrowing in an upcoming lecture.

The third is `void`. This is a special type that you'll typically only use when defining functions. It's effectively the opposite of `any` - it represents the absence of any type at all. Functions which don't have a return value, such as `console.log()`, have a return type of `void`.

Finally, there is the `never` type. This is probably something you won't use often - it represents a type that will never exist. For example, passing a mock object to a function in your test suite might be a good use of `never` to indicate that such an object would never really be passed to the function.

Expanding on these types, you have access to the `type` keyword. This keyword is like `const`, but instead of declaring a variable you can declare a type:

```js
type myString = string;
```

This might not seem terribly useful on its own, but when coupled with union types it becomes powerful. A union type allows you to combine two or more types into one. Here's an example:

```js
type stringOrNumber = string | number;
```

Our `stringOrNumber` type matches values that are a string and values that are a number. You can then combine your type with other types, like an array:

```js
const stuff: stringOrNumber[] = ["a", 2, "c", 1000];
```

You can also define more strict types that include only specific values:

```js
type bot = "camperchan" | "camperbot" | "naomi";
type digit = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
```

You could then combine those types to create more specific restrictions on an object:

```js
const artificialIntelligence: Record<bot, digit> = { camperchan: 5 }
```

Though if you need more control over the structure of an object, chances are you'll reach for our final type: `interface`. Interfaces are effectively classes, but for types. They can implement or extend other interfaces, are specifically object types, and are generally preferred unless you need a specific feature offered by a type declaration.

```js
interface wowie {
  zowie: boolean;
  method: () => void;
}
```

Finally, functions can also be given type signatures. In the previous lecture, you saw how to define the type of a particular parameter:

```js
const getRandomValue = (array: string[]) => {
  return array[Math.floor(Math.random() * array.length)];
}
```

But you can also define the return type of the function.

```js
const getRandomValue = (array: string[]): string => {
  return array[Math.floor(Math.random() * array.length)];
}
```

In this example, we've told TypeScript that the function should return a string. If we try to return anything else, TypeScript will provide a compiler error to let us know.

And that covers the basics of TypeScript's type system. It's pretty complex, and has a lot of moving parts, but it can often help to think of it as mirroring JavaScript's types.


## What Are Generics, and How Do They Work?

### Description

You have actually seen a generic type in a previous lecture: `Array<string>`. But you'll usually use generic types in functions. In fact, they can be thought of as a special parameter you provide to a function to control the behavior of the function's type definition.

Let's go back to our previous example of a function to get a random value from an array:

```js
const getRandomValue = (array: string[]): string => {
  return array[Math.floor(Math.random() * array.length)];
}
```

Our function accepts an array of strings and returns a string. But what if we wanted to pass in an array of numbers and return a number?

You could use a union type:

```js
const getRandomValue = (array: (string|number)[]): (string|number) => {
  return array[Math.floor(Math.random() * array.length)];
}
const val = getRandomValue([1, 2, 4])
```

But with this approach, even though we have passed in an array of only numbers, TypeScript determines that the `val` variable could be a number OR a string.

Instead, you can define a generic type for the function:

```js
const getRandomValue = <T>(array: T[]): T => {
  return array[Math.floor(Math.random() * array.length)];
}
const val = getRandomValue([1, 2, 4])
```

There are a couple of important components in our new example. First, the `<T>` syntax tells TypeScript that you are defining a generic type `T` for the function. `T` is a common name for generic types, but you can actually name it whatever you want (within JavaScript's variable conventions).

Then, we tell TypeScript that the array parameter is an array of values matching the generic type, and that the returned value is a single element of that same type. This allows TypeScript to properly detect that `val` will be a number, because the array we passed consists solely of numbers.

But what about functions you don't control? Let's take a look at the `document.querySelector()` method:

```js
const email = document.querySelector("#email");
console.log(email.value);
```

Because we're querying with an ID selector, TypeScript doesn't know what kind of element we are querying. It knows it's an `Element` of some sort, but our attempt to access the `value` property will throw an error because the top-level element interface does not have that property.

Thankfully, we can pass a type argument to the function call:

```js
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email.value);
```

Notice how we're using the angle bracket syntax again (`<HTMLInputElement>`), but this time in a function call. This tells TypeScript that the element we expect to find will be an `input` element, and we no longer get an error on the value property because input elements do have that property. Of course, `querySelector` can return `null` if an element is not found, and TypeScript will throw a compiler error here because we do not handle that case.

But you'll learn about that in the next lecture.


## What Is Type Narrowing, and How Does It Work?

### Description

There are going to be times where you have a value with a broad type and you need to narrow it down to a more specific type. For example, maybe you need to ensure an object matches an interface you defined. Or a string is within a specific list of values. There are quite a few ways to achieve this.

The first is narrowing by truthiness. Consider our example from the last lecture:

```js
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email.value);
```

We get a compiler error trying to access the `value` property of `email`, because `email` might be `null`. However, we can use a conditional statement to confirm `email` is truthy before accessing the property:

```js
const email = document.querySelector<HTMLInputElement>("#email");
if (email) {
  console.log(email.value);
}
```

In this updated example, because `null` is not a truthy value, TypeScript is able to infer that `email` MUST be an `input` element within the conditional block. So it no longer throws a compiler error.

Truthiness checks can also work in the reverse direction:

```js
const email = document.querySelector<HTMLInputElement>("#email");
if (!email) {
  throw new ReferenceError("Could not find email element!")
}
console.log(email.value);
```

With this approach, we throw an error if `email` is falsy. `null` is a falsy value. Throwing an error ends the logical execution of this code, which means when we reach the `console.log()` call TypeScript knows `email` cannot be `null`.

Optional chaining is also a form of type narrowing, under the same premise that the property access can't happen if the `email` value is `null`.

```js
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email?.value);
```

But what about other types? Well, you can also narrow types using the `typeof` operator. Let's look at an example of a variable we have indicated might be a string OR a number:

```js
const myVal = Math.random() > 0.5 ? 222 : "222";
console.log(myVal / 10)
```

In this example, we see a compiler error because we cannot perform arithmetic on a string value. But we can use a conditional to check the `typeof` the `myVal` variable:

```js
const myVal = Math.random() > 0.5 ? 222 : "222";
if (typeof myVal === "number") {
  console.log(myVal / 10);
}
```

Because we have used the `typeof` keyword, TypeScript now knows that `myVal` has to be a number, and we can safely perform arithmetic with it.

But what about more complex object types? If the object in question happens to come from a class, you can actually use the `instanceof` keyword to narrow the type. Going back to our `querySelector()` example:

```js
const email = document.querySelector("#email");
```

Rather than passing a generic type and telling TypeScript what the element is, we can use `instanceof` to narrow the type and write safer code:

```js
const email = document.querySelector("#email");

if (email instanceof HTMLInputElement) {
    console.log(email.value);
}
```

This approach may seem the same as our previous one, but `instanceof` is a runtime validation - which means, if we somehow got the TypeScript type wrong, our JavaScript code will still confirm that `email` is an `input` element.

Next, let's look at an example where we fetch a `User` object from an API and try to print the information:

```js
interface User {
    name: string;
    age: number;
}

const printAge = (user: User) => 
  console.log(`${user.name} is ${user.age} years old!`)

const request = await fetch("url")
const myUser = await request.json();
printAge(myUser);
```

We'll get a compiler error trying to pass `myUser` into the function because, even though we know the API returns the correct object, TypeScript does not. And the `.json()` method does not take a generic type.

The "easy" way to resolve this issue would be to cast the type:

```js
interface User {
    name: string;
    age: number;
}

const printAge = (user: User) => 
  console.log(`${user.name} is ${user.age} years old!`)

const request = await fetch("url")
const myUser = await request.json() as User;
printAge(myUser);
```

But whenever you cast the type, you're essentially weakening TypeScript's ability to catch potential errors. So instead of casting the type, you can write a type guard:

```js
interface User {
    name: string;
    age: number;
}

const isValidUser = (user: unknown): user is User => {
  return !!user && 
    typeof user === "object" &&
    "name" in user &&
    "age" in user;
}
```

The return type here is the key component of this function definition. The `user is User` syntax indicates that our function returns a boolean value, which when `true` means the `user` value satisfies the `User` interface. We then do some basic checks to ensure that the structure of the `user` object matches - note the use of a truthiness (`!!user`) narrowing and a `typeof` narrowing. We must do this because `typeof null` returns `"object"`:

```js
interface User {
    name: string;
    age: number;
}

const isValidUser = (user: unknown): user is User => {
  return !!user && 
    typeof user === "object" &&
    "name" in user &&
    "age" in user;
}

const printAge = (user: User) => 
  console.log(`${user.name} is ${user.age} years old!`)

const request = await fetch("url")
const myUser = await request.json() as User;
if (isValidUser(myUser)) {
    printAge(myUser);
}
```

Now, if we combine all of our logic together, we no longer get compiler errors and can successfully build our code.

Type narrowing is a powerful feature that helps you write safer, less error-prone code - but remember that TypeScript types are not completely rigid, so avoid practices like casting the type of a value without narrowing it.


## What Is a tsconfig File, and Why Is It Important to Include in Your TypeScript Projects?

### Description

TypeScript's compiler settings can be configured to meet your project's needs. That configuration lives in a `tsconfig.json` file in the root directory of your project. In fact, without it, the compiler will not run unless you pass it command flags directly. But what exactly does this file do? Well, let's take a look at an example file:

```json
{
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./prod",
    "lib": ["ES2023"],
    "target": "ES2023",
    "module": "ES2022",
    "moduleResolution": "Node",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "strict": true
  },
  "exclude": ["test/"]
}
```

This seems like a lot! So let's break it down. The `compilerOptions` property is going to contain the "meat" of your configuration - this is where you control how the TypeScript compiler behaves. Looking at that nested object…

The `rootDir` and `outDir` tell TypeScript which directory holds your source files, and which directory should contain the transpiled JavaScript code.

The `lib` property determines which type definitions the compiler uses, and allows you to include support for specific ES releases, the DOM, and more.

`module` and `moduleResolution` effectively work in tandem to manage how your package uses modules - either CommonJS or ECMAScript.

`esModuleInterop` allows for smoother interoperability between CommonJS and ES modules by automatically creating namespace objects for imports, making it easier to use modules from different systems together in your TypeScript projects, and the `skipLibCheck` option skips validating `.d.ts` files that aren't referenced by imports in your code.

And finally we reach the `strict` mode. One might argue that TypeScript isn't truly helpful without this flag enabled, as it toggles quite a few other checks, such as requiring you to properly handle nullable types, or warn when TypeScript can't infer a type and falls back to any.

Before we finish, a quick note about the top-level `exclude` property - when you've defined a source directory, you may have TypeScript code outside of that directory which you don't want compiled as part of your production code. For example, your test code. The `exclude` array tells the compiler to ignore these TypeScript files during compilation, but still allows tooling like Intellisense to expose potential issues.

There are a ton of other compiler options you can explore - over 50! I encourage you to explore the documentation and experiment to find the configuration that works for your project's needs.


## Module: Review Front End Libraries


# Chapter: Python


## Module: Python Basics


### Lecture Block: Lecture Introduction To Python


## What Is Python and What Are Some Common Uses in the Industry?

### Description

Python is a general-purpose programming language known for its simplicity and ease of use. This ease of use has made Python the most popular programming language in modern times. In 2024, Python officially surpassed JavaScript as the most popular language on GitHub.

Python is used in many fields like data science and machine learning, web development, scripting and automation, embedded systems, IoT, and much more.

Python is the main language that most data scientist and machine learning engineers currently use. Libraries like Pandas and Numpy make data analysis less tedious, while others like Tensorflow and Scikit make machine learning and working with AI models much more accessible.

In web development, Python frameworks like Django, FastAPI, and Flask let developers build scalable and secure backend systems with minimal effort. Many social media platforms like Instagram and Pinterest use Python on the backend.

Cybersecurity professionals and ethical hackers use Python to detect vulnerabilities like malware and other viruses, build automated security scans, and analyze threats.

Python runs well on microcomputers like the Raspberry Pi and MicroPython-compatible boards, so you can build all kinds of IoT projects like smart home devices, weather monitoring stations, and more.

Finally, one of Python's biggest strengths is automation. You can write simple scripts to help you with repetitive tasks like extracting data from spreadsheets, sending emails, and working with files on your local machine.

Libraries like Selenium and BeautifulSoup also make it easy to interact with websites, so you can scrape public data, automate tasks through a web UI, and even manage cloud deployments for your projects.

As you can see, Python is a very powerful language, and yet, it's easy to learn. From simple automation scripts to large-scale, industrial-level applications, you can use Python for just about anything.

Python is a great choice for anyone who wants to learn programming, regardless of what they choose to specialize in later.


## How Do You Install, Configure and Use Python in Your Local Environment?

### Description

In the last lecture, you learned what Python is and what you can do with it. Now, let's look into how you can set up Python on your local machine.

The best way to install Python on Windows and Mac is to download the installer from the official Python website. We'll also go over running Python on Linux later in this lecture.

Go to `https://www.python.org/` and hover over "Downloads". A modal will appear showing the current version of Python for your OS.

We'll go over how to install Python on a computer running macOS first:

- Click on the button showing the current version of Python (from the previous modal), and you'll start downloading a `.pkg` installation file automatically.
- Once the `.pkg` installer is finished downloading, open it, then click "Continue" in the window that opens up.
- Continue clicking the "Continue" button until you get to the "Installation Type" section. There, click the "Install" button.
- Enter in your password if necessary, then start the installation.
- After that, you should get a congratulations message saying that Python has been successfully installed.
- Click the "Close" button, and you're done!

You can verify the installation by opening up your terminal and running `python --version` or `python3 --version`.

You can also open the Python interpreter by running `python` or `python3` in the terminal.

Note that, on some older macOS and Linux systems, `python` can be reserved for Python 2, while `python3` is for Python 3 specifically. If you run `python --version` and see a version of Python 2 like `Python 2.7.18`, then it's possible that your OS relies on some software that was written in the older version of Python. If that's the case, you should use `python3` to run your Python code going forward.

To install Python on Windows, follow these steps:

- Go to `https://www.python.org/`, and hover over “Downloads“. You should see a modal that says "Download for Windows" and a download button with the current version of Python.
- Click on the version number, and you'll start downloading a Windows executable (`.exe`) file automatically.
- Once you've finished downloading the Python installer for Windows, double-click on it, and follow the instructions.
- When you see the option `Add python.exe to Path`, check that option, then click `Install Now`. Doing that will make things easier for you later.


You can verify the installation by opening up a command line shell like PowerShell and running `python --version`. You can also open the Python interpreter by running `python`.

For Python on Linux, most major distros like Ubuntu, Debian, and Fedora come with Python.

Just open a terminal and run `python --version`, or `python3 --version`:

If either command doesn't show a version of Python, you can search for an installation package for your flavor of Linux at `https://www.python.org`, or search online for the recommended way to install Python for your distro.


## How Do You Declare Variables and What Are Naming Conventions to Name Variables?

### Description

In Python, variables are like a labelled box for storing and referencing data of different types. To declare variables in Python, you assign a value to an identifier with the assignment (`=`) operator. You don't need to use special keywords like `let` or `const` in JavaScript, or `char` in C#.

In Python, you just write the name of the variable on the left, followed by the assignment operator, and the value you want to assign the variable on the right. Here's an example of how to declare `name` and `age` variables:

```python
name = 'John Doe'
age = 25
```

When naming variables in Python, there are some important rules you should keep in mind:

- Variable names can only start with a letter or an underscore (`_`), not a number.    
- Variable names can only contain alphanumeric characters (`a-z`, `A-Z`, `0-9`) and underscores (`_`).  
- Variable names are case-sensitive — `age`, `Age`, and `AGE` are all considered unique.
- Variable names cannot be one of Python's reserved keywords such as `if`, `class`, or `def`.
    

If you break any of those rules, your Python program will throw a `SyntaxError`:

```bash
    5variable_name = 5
     ^
SyntaxError: invalid syntax
```

Now let's go over some common naming conventions for variables in Python.

First, variables names should be in lowercase, with separate words separated by an underscore. This is called snake case:

```python
my_variable_name = 'freeCodeCamp'
```

Next, you should use descriptive names for variables. For example, if you want to save a user's age as a variable, `user_age` is better than `age` or an abbreviation like `ua`:

```python
user_age = 30
```

This way, you can easily communicate the purpose of a variable to other team members (or to your future self) in a large codebase.

Another convention is to avoid using single-letter variable names. This is very common in Python, but should be avoided because variable names with a single letter communicate no purpose or meaning:

```python
x = 56 # What do you mean by x?
```

This is different if you are in a loop or something similar, as variable names like `i`, `j`, `k`, and so on are common and acceptable.

Also, the pound symbol (`#`) and the text that follows in the example above is called a comment. You might already be familiar with comments, so let's go over them quickly and explain how they work.

In Python, comments start with a pound symbol (`#`), and the language ignores everything after the `#` symbol on that line:

```python
# This is a single-line comment
```

Multi-line comments can be created by using consecutive single-line comments:

```python
# This is a
# multi-line
# comment
```

You can use comments to explain your code, leave reminders for yourself, or clarify why a line exists. Comments are especially helpful when you're learning or working in teams.

However, you shouldn't use comments to explain what your variable names mean. Instead, the names you choose for your variables should be descriptive and communicate what they're for, and follow the other naming rules mentioned earlier to prevent syntax errors.


## How Does the Print Function Work?

### Description

Every programming language has some way to output data to the terminal with a built-in method, function, property, or keyword. In Python, you can use the `print` function to print data to the terminal. Let's take a closer look at the `print` function so you can start using it with confidence.

One of the first things you do when you're learning any programming language is to write a simple `Hello world!` program. You can do that really easily in Python with just the `print` function.

To do that, you just need to put the string `Hello world!` in between the opening and closing parentheses you use to call the `print` function:

```python
print('Hello world!') # Hello world!
```

You will learn more about strings and functions in Python in future lectures. For now, just consider strings as a sequence of characters surrounded by either single (`'`) or double (`"`) quotation marks.

There's a lot more to the `print` function than first meets the eye. There are four other arguments you can pass to it, so here's the full syntax of the function:

```python
print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)
```

Note that each of the arguments must be separated by a comma, otherwise you'll get a syntax error. Here are more details about each argument:

- `objects`: The data you want to print. The `*` sign means that you can print multiple things to the terminal by passing in multiple objects (in other words, strings, variables, numbers, and so on) separated by commas.    
- `sep=' '`: The separator between the objects. This defaults to a single space character (`' '`).
- `end='\n'`: What to print at the end of the object. This defaults to a new line character (`'\n'`).
- `file=sys.stdout`: Determines where to send the output. The default is the terminal, but it can be a file.
- `flush=False`: Determines whether to show the output data right away. The default is `False`, which means Python may wait before displaying the output.
    
You might be wondering how the other arguments outside of `object` are useful. Let's take a look at some common use cases.

If you print multiple things at once, they're just separated by spaces by default. For example:

```python
print('Footballers:', 'Ronaldo', 'Messi', 'Hazard', 'Kante', 'Okocha')

# Output: Footballers: Ronaldo Messi Hazard Kante Okocha
```

But you can use another separator of your choice with the `sep` argument:

```python
print('Footballers:', 'Ronaldo', 'Messi', 'Hazard', 'Kante', 'Okocha', sep=', ')

# Output: Footballers:, Ronaldo, Messi, Hazard, Kante, Okocha
```

In this example, you passed a comma followed by a single space character to `sep`. But the comma in front of the first value, `Footballers:` doesn't make sense, right?

To get rid of that comma, you can move the space to the `Footballers:` string directly, and use a plus sign (`+`):

```python
print('Footballers: ' + 'Ronaldo', 'Messi', 'Hazard', 'Kante', 'Okocha', sep=', ')

# Output: Footballers: Ronaldo, Messi, Hazard, Kante, Okocha
```

This is called string concatenation, which is when you combine multiple strings into one. In this case, you're combing the strings `Footballers:` and `Ronaldo` first, resulting in `Footballers: Ronaldo`, before printing everything to the terminal.

You'll learn more about string concatenation in future lectures.

The `end` parameter lets you avoid a common issue with the `print` function, where it automatically prints a new line when you have multiple of it. Here's an example:

The `end` parameter lets you modify the ending of the output. By default, the end character is a newline character (`\n`), which is helpful in most cases.

But what if you call `print` multiple times in a row?:

```python
print('Footballers:')
print('Ronaldo')
print('Messi')
print('Hazard')
print('Kante')
print('Okocha')

#Output:
# Footballers:
# Ronaldo
# Messi
# Hazard
# Kante
# Okocha
```

To avoid this common issue, you can specify a different value for the `end` argument:

```python
print('Footballers:', end=' ')
print('Ronaldo', end=', ')
print('Messi', end=', ')
print('Hazard', end=', ')
print('Kante', end=', ')
print('Okocha', end='.')

#Output: Footballers: Ronaldo, Messi, Hazard, Kante, Okocha.
```

How cool is that?

Here's how you can use the `file` argument to write the output of the `print` function to a separate file:

```python
with open('output.txt', 'w') as f:
   print('Hello world!', file=f)
```

This will print the text `Hello world!` into a file named `output.txt`. If the file doesn't exist, it will be automatically created. You will learn more about how working with the filesystem in future lectures.

The last argument of the `print` function we showed in its basic syntax is `flush`. When set to `True`, it immediately shows what you want to print instead of waiting for a short time.

The last argument is `flush`. When this is set to `True`, whatever you're outputting is shown immediately rather than waiting for potential delays in the program's execution:

```python
import time

print('Processing...', end=' ', flush=True)
time.sleep(2)
print('Done!')
```

In this case, the `Processing…` text immediately appears in the terminal, then `time.sleep(2)` delays the `Done` text from appearing for 2 seconds. This makes `flush` a great tool for displaying progress bars and loading text.

And that's how the `print` function works!


## What Are Common Data Types in Python and How Do You Get the Type of a Variable?

### Description

Python is a dynamically-typed language like JavaScript, meaning you don't need to explicitly declare types for variables. The language knows what data type a variable is based on what you assign to it.

Here are some examples:

```python
name = 'John Doe' # Python knows this is a string
age = 25 # Python knows this is an integer
```

This is in contrast to some statically-typed languages like C#, Java, and C++, where you have to declare types with variables, like this:

```csharp
string name = 'John Doe'
int age = 25
```

The dynamic-typing nature of Python makes coding really fast and more flexible, but it can lead to unexpected bugs because type errors are detected only when a program runs, not when the program compiles.

Here are the most common data types you'll use in Python:

- Integer: A whole number without decimals, for example, `10` or `-5`.

```python
my_integer_var = 10
print('Integer:', my_integer_var) # Integer: 10
```

- Float: A number with a decimal point, like `4.41` or `-0.4`.

```python
my_float_var = 4.50
print('Float:', my_float_var) # Float 4.50
```

- Complex: A number with a real and imaginary part, like `6 + 7j`.

```python
my_complex_var = 3 + 4j
print('Complex:', my_complex_var) # Complex: (3+4j)
```

- String: A sequence of characters enclosed in single or double quotation marks like `'Hello world!'`.

```python
my_string_var = 'hello'
print('String:', my_string_var) # String: hello
```

- Boolean: A true or false type, written as `True` or `False`.

```python
my_boolean_var = True
print('Boolean:', my_boolean_var) # Boolean: True
```

- Set: An unordered collection of unique elements, like `{4, 2, 0}`.
 
```python
my_set_var = {7, 5, 8}
print('Set:', my_set_var) # Set: {7, 5, 8}
```

- Dictionary: A collection of key-value pairs enclosed in curly braces, like `{'name': 'John Doe', 'age': 28}`. 

```python
my_dictionary_var = {'name': 'Alice', 'age': 25}
print('Dictionary:', my_dictionary_var) # Dictionary: {'name': 'Alice', 'age': 25}
```

- Tuple: An immutable ordered collection, enclosed in brackets, like `(7, 8, 4)`.

```python
my_tuple_var = (7, 5, 8)
print('Tuple:', my_tuple_var) # Tuple: (7, 5, 8)
```

- Range: A sequence of numbers, often used in loops, for example, `range(5)`.

```python
my_range_var = range(5)
print(my_range_var) # range(0, 5)
```

- List: An ordered collection of elements that supports different data types.
    
```python
my_list = [22, 'Hello world', 3.14, True]
print(my_list) # [22, 'Hello world', 3.14, True]
```

- None: A special value that represents the absence of a value.

```python
my_none_var = None
print('None:', my_none_var) # None: None
```

Many other programming languages group data types broadly as either primitive or reference types. Primitive types are simple and immutable, meaning they can't be changed once declared. Reference types can hold multiple values, and are either mutable or immutable. But Python doesn't draw a hard line between those two groups. Instead, all data gets treated as objects, and some objects are immutable while others are mutable.

Immutable data types can't be modified or altered once they're declared. You can point their variables at something new, which is called reassignment, but you can't change the original object itself by adding, removing, or replacing any of its elements. Examples of immutable data types in Python are string, integer, float, boolean, tuple, and range.

Here's an example showing that, while you can reassign a different string to a variable, direct modification of a string isn't allowed because strings are immutable:

```python
greeting = 'hi'
greeting = 'hello'
print(greeting) # hello

greeting[0] = 'H' # TypeError: 'str' object does not support item assignment
```

On the other hand, you can change mutable types without giving them a new name. You can add, remove, or update items right where they live. Examples are a list and a dictionary.

Here's an example of updating an element in a list:

```python
nums = [1, 2, 3]
nums[0] = 4

print(nums) # [4, 2, 3]
```

To get the data type of a variable, you can use the `type()` function:

```python
my_var_1 = 'Hello world'
my_var_2 = 21

print(type(my_var_1)) # <class 'str'>
print(type (my_var_2)) # <class 'int'>
```

And here's are all the data types covered in this lecture, along with their types in the terminal:

```python
my_integer_var = 10
print('Integer:', my_integer_var, '| Type:', type(my_integer_var))  # Integer: 10 | Type: <class 'int'>

my_float_var = 4.50
print('Float:', my_float_var, '| Type:', type(my_float_var))  # Float: 4.50 | Type: <class 'float'>

my_complex_var = 3 + 4j
print('Complex:', my_complex_var, '| Type:', type(my_complex_var))  # Complex: (3+4j) | Type: <class 'complex'>

my_string_var = 'hello'
print('String:', my_string_var, '| Type:', type(my_string_var))  # String: hello | Type: <class 'str'>

my_boolean_var = True
print('Boolean:', my_boolean_var, '| Type:', type(my_boolean_var))  # Boolean: True | Type: <class 'bool'>

my_set_var = {7, 5, 8}
print('Set:', my_set_var, '| Type:', type(my_set_var))  # Set: {7, 5, 8} | Type: <class 'set'>

my_dictionary_var = {'name': 'Alice', 'age': 25}
print('Dictionary:', my_dictionary_var, '| Type:', type(my_dictionary_var))  # Dictionary: {'name': 'Alice', 'age': 25} | Type: <class 'dict'>

my_tuple_var = (7, 5, 8)
print('Tuple:', my_tuple_var, '| Type:', type(my_tuple_var))  # Tuple: (7, 5, 8) | Type: <class 'tuple'>

my_range_var = range(5)
print('Range:', list(my_range_var), '| Type:', type(my_range_var))  # Range: [0, 1, 2, 3, 4] | Type: <class 'range'>

my_list = [22, 'Hello world', 3.14, True]
print('List:', list(my_list), '| Type:', type(my_list)) # List: [22, 'Hello world', 3.14, True] | Type: <class 'list'>

my_none_var = None
print('None:', my_none_var, '| Type:', type(my_none_var))  # None: None | Type: <class 'NoneType'>
```

Another way to check the type of a variable is to use the built-in `isinstance()` function, which checks if a variable matches a specific data type.

`isinstance()` takes in an object and the type you want to check it against, then returns a boolean. Here are some examples:

```python
isinstance('Hello world', str) # True
isinstance(True, bool) # True
isinstance(42, int) # True
isinstance('John Doe', int) # False
```

Although Python is dynamically typed, you can still add type hints. These are optional signals that tell other developers what the data type of a variable or function is expected to be. Here's a quick example for variable types:

```python
user_name: str = 'John Doe'
user_age: int = 24
```

Here's another example showing hints for function parameters and a return type:

```python
def greet(name: str, age: int) -> str:
    return f'Hello, {name}, age {age}.'
```

And here's a combination of the two:

```python
def greet(name: str, age: int) -> str:
    return f'Hello, {name}, age {age}.'

user_name: str = 'John Doe'
user_age: int = 24

print(greet(user_name, user_age)) # Hello, John Doe, age 24.
```

Note that, unlike TypeScript which enforces types at compile time, Python just uses these hints for static analysis, documentation, and editor support, **not** for enforcing types during runtime. This can help developers catch bugs early and improve code readability, especially in large projects.


## How Do You Work With Strings?

### Description

A string is a sequence of characters surrounded by either single or double quotation marks. In some programming languages, characters surrounded by single quotes are treated differently than characters surrounded by double quotes, but in Python, they're treated equally. So, you can use either when working with strings. Here are some examples of strings:

```python
my_str_1 = 'Hello'
my_str_2 = "World"
```

If you need a multi-line string, you can use triple double quotes or single quotes:

```python
my_str_3 = """Multiline
string"""
my_str_4 = '''Another
multiline
string'''
```

If your string contains either single or double quotation marks, then you have two options:

- Use the opposite kind of quotes. That is, if your string contains single quotes, use double quotes to wrap the string, and vice versa:
    

```python
msg = "It's a sunny day"
quote = 'She said, "Hello World!"'
```

- Escape the single or double quotation mark in the string with a backslash (`\`). With this method, you can use either single or double quotation marks to wrap the string itself:
    

```python
msg = 'It\'s a sunny day'
quote = "She said, \"Hello!\""
```

You can also combine multiple strings together with the plus (`+`) operator. This process is called string concatenation. Here's how to concatenate two strings with the plus operator:

```python
my_str_1 = 'Hello'
my_str_2 = "World"

str_plus_str = my_str_1 + ' ' + my_str_2
print(str_plus_str) # Hello World
```

But note that this only works with strings. If you try to concatenate a string with a number, you'll get a `TypeError`:

```python
name = 'John Doe'
age = 26

name_and_age = name + age
print(name_and_age) # TypeError: can only concatenate str (not "int") to str
```

This happens because Python does not automatically convert other data types like integers into strings when you concatenate them. Python requires all elements to be strings before it can concatenate them. To fix that, you can convert the number into a string with the built-in `str()` function:

```python
name = 'John Doe'
age = 26

name_and_age = name + str(age)
print(name_and_age) # John Doe26
```

You can also use the augmented assignment operator for concatenation. This is represented by a plus and equals sign (`+=`), and performs both concatenation and assignment in one step. Here's it in action:

```py
name = 'John Doe'
age = 26

name_and_age = name  # Start with the name
name_and_age += str(age)  # Append the age as string

print(name_and_age)  # John Doe26
```

Apart from regular strings, Python also has a category of string called **f-strings**, which is short for formatted string literals. It allows you to handle interpolation and also do some concatenation with a compact and readable syntax.

F-strings start with `f` (either lowercase or uppercase) before the quotes, and allow you to embed variables or expressions inside replacement fields indicated by curly braces (`{}`). Here's an example:

```python
name = 'John Doe'
age = 26
name_and_age = f'My name is {name} and I am {age} years old'
print(name_and_age) # My name is John Doe and I am 26 years old

num1 = 5
num2 = 10
print(f'The sum of {num1} and {num2} is {num1 + num2}') # The sum of 5 and 10 is 15
```

Now that you've learned about string concatenation and f-strings, let's look at how you can get the length of a string and work with the individual characters in a string, a process called **indexing**. To get the length of a string, you can use the built-in `len()` function. Here's an example:

```python
my_str = 'Hello world'
print(len(my_str))  # 11
```

Now onto indexing. Each character in a string has a position called an index. The index is zero-based, meaning that the index of the first character of a string is `0`, the index of the second character is `1`, and so on. To access a character by its index, you use square brackets (`[]`) with the index of the character you want to access inside. Here are some examples:

```python
my_str = "Hello world"

print(my_str[0])  # H
print(my_str[6])  # w
```

Negative indexing is also allowed, so you can get the last character of any string with `-1`, the second-to-last character with `-2`, and so on:

```python
my_str = 'Hello world'
print(my_str[-1])  # d
print(my_str[-2]) # l
```

Now that you're familiar with indexing, let's take things a bit further with **string slicing**. String slicing lets you extract a portion of a string or work with only a specific part of it. Here's the basic syntax:

```python
string[start:stop]
```

If you want to extract characters from a certain index to another, you just separate the `start` and `stop` indices with a colon:

```python
my_str = 'Hello world'
print(my_str[1:4]) # ell
```

Note that the `stop` index is non-inclusive, so `[1:4]` just extracted the characters from index `1`, and up to, but not including, the character at index `4`.

You can also omit the `start` and `stop` indices, and Python will default to `0` or the end of the string, respectively. For example, here's what happens if you omit the `start` index:

```python
my_str = 'Hello world'
print(my_str[:7])  # Hello w
```

This extracts everything from index `0` up to (but not including), the character at index `7`. And here's what happens if you omit the `stop` index:

```python
my_str = 'Hello world'
print(my_str[8:])  # rld
```

This extracts everything from the character at index `8` until the end of the string.

You can also omit both the `start` and `stop` indices, which will extract the whole string:

```python
my_str = 'Hello world'
print(my_str[:])  # Hello world
```

Apart from the `start` and `stop` indices, there's also an optional step parameter, which is used to specify the increment between each index in the slice.

Here's the syntax for that:

```python
string[start:stop:step]
```

In the example below, the slicing starts at index `0`, stops before `11`, and extracts every second character:

```python
my_str = 'Hello world'
print(my_str[0:11:2])  # Hlowrd
```

A helpful trick you can do with the `step` parameter is to reverse a string by setting step to `-1`, and leaving `start` and `stop` blank:

```python
my_str = 'Hello world'
print(my_str[::-1]) # dlrow olleH
```

It can also be helpful to check if a character or set of characters exist in a string before slicing it. To do that, Python provides the `in` operator, which returns a boolean that specifies whether the character or characters exist in the string or not.

Here are some examples:

```python
my_str = 'Hello world'

print('Hello' in my_str)  # True
print('hey' in my_str)    # False
print('hi' in my_str)    # False
print('e' in my_str)  # True
print('f' in my_str)  # False
```


## What Are Some Common String Methods?

### Description

Python provides a number of built-in methods that make working with strings a breeze. They include, but are not limited to, the following:

- `upper()`: Returns a new string with all characters converted to uppercase.
    

```python
my_str = 'hello world'

uppercase_my_str = my_str.upper()
print(uppercase_my_str)  # HELLO WORLD
```

- `lower()`: Returns a new string with all characters converted to lowercase.
    

```python
my_str = 'Hello World'

lowercase_my_str = my_str.lower()
print(lowercase_my_str)  # hello world
```

- `strip()`: Returns a new string with the specified leading and trailing characters removed. If no argument is passed it removes leading and trailing whitespace.
    

```python
my_str = '  hello world  '

trimmed_my_str = my_str.strip()
print(trimmed_my_str)  # "hello world"
```

- `replace(old, new)`: Returns a new string with all occurrences of `old` replaced by `new`.
    

```python
my_str = 'hello world'

replaced_my_str = my_str.replace('hello', 'hi')
print(replaced_my_str)  # hi world
```

- `split(separator)`: Splits a string on a specified separator into a list of strings. If no separator is specified, it splits on whitespace.
    

```python
my_str = 'hello world'

split_words = my_str.split()
print(split_words)  # ['hello', 'world']
```

- `join(iterable)`: Joins elements of an iterable into a string with a separator.
    

```python
my_list = ['hello', 'world']

joined_my_str = ' '.join(my_list)
print(joined_my_str)  # hello world
```

- `startswith(prefix)`: Returns a boolean indicating if a string starts with the specified prefix.
    

```python
my_str = 'hello world'

starts_with_hello = my_str.startswith('hello')
print(starts_with_hello)  # True
```

- `endswith(suffix)`: Returns a boolean indicating if a string ends with the specified suffix.
    

```python
my_str = 'hello world'

ends_with_world = my_str.endswith('world')
print(ends_with_world)  # True
```

- `find(substring)`: Returns the index of the first occurrence of `substring`, or `-1` if it doesn't find one.
    

```python
my_str = 'hello world'

world_index = my_str.find('world')
print(world_index)  # 6
```

- `count(substring)`: Returns the number of times a substring appears in a string.
    

```python
my_str = 'hello world'

o_count = my_str.count('o')
print(o_count)  # 2
```

- `capitalize()`: Returns a new string with the first character capitalized and the other characters lowercased.
    

```python
my_str = 'hello world'

capitalized_my_str = my_str.capitalize()
print(capitalized_my_str)  # Hello world
```

- `isupper()`: Returns `True` if all letters in the string are uppercase and `False` if not.
    

```python
my_str = 'hello world'

is_all_upper = my_str.isupper()
print(is_all_upper)  # False
```

- `islower()`: Returns `True` if all letters in the string are lowercase and `False` if not.
    

```python
my_str = 'hello world'

is_all_lower = my_str.islower()
print(is_all_lower)  # True
```

- `title()`: Returns a new string with the first letter of each word capitalized.
    

```python
my_str = 'hello world'

title_case_my_str = my_str.title()
print(title_case_my_str)  # Hello World
```


## How Do You Work With Integers and Floating Point Numbers?

### Description

Integers and floats are the primary numeric data types in Python. With them, you can store numeric data and perform mathematical operations.

Let's look at what integers and floats are, how to perform arithmetic calculations with them, and at several methods Python provides for working with both.

Integers are whole numbers without decimal points, either positive or negative:

```python
my_int_1 = 56
my_int_2 = -4

print(type(my_int_1)) # <class 'int'>
print(type(my_int_2)) # <class 'int'>
```

Here's how to perform an addition operation with integers:

```python
my_int_1 = 56
my_int_2 = 12

sum_ints = my_int_1 + my_int_2
print('Integer Addition:', sum_ints) # Integer Addition: 68
```

Here's how to perform a subtraction with integers:

```python
my_int_1 = 56
my_int_2 = 12

# Subtraction
diff_ints = my_int_1 - my_int_2
print('Integer Subtraction:', diff_ints) # Integer Subtraction: 44
```

Here's how to perform a multiplication operation with integers:

```python
my_int_1 = 12
my_int_2 = 4

# Multiplication
product_ints = my_int_1 * my_int_2
print('Integer Multiplication:', product_ints) # Integer Multiplication: 48
```

And here's how to perform a division operation with integers:

```python
my_int_1 = 56
my_int_2 = 12

# Division
div_ints = my_int_1 / my_int_2
print('Integer Division:', div_ints) # Integer Division: 4.666666666666667
```

Floats are positive or negative numbers with decimal points, like `3.14`, `-0.5`, or `0.0`.

```python
my_float_1 = -12.0
my_float_2 = 4.9

print(type(my_float_1)) # <class 'float'>
print(type(my_float_2)) # <class 'float'>
```

Here's an addition operation with floats:

```python
my_float_1 = 5.4
my_float_2 = 12.0

float_addition = my_float_1 + my_float_2
print('Float Addition:', float_addition) # Float Addition: 17.4
```

Here's a subtraction operation with floats:

```python
my_float_1 = 5.4
my_float_2 = 12.0

float_subtraction = my_float_2 - my_float_1
print('Float Subtraction:', float_subtraction) # Float Subtraction: 6.6
```

Here's a multiplication operation with floats:

```python
my_float_1 = 5.4
my_float_2 = 12.0

float_multiplication = my_float_2 * my_float_1
print('Float Multiplication:', float_multiplication) # Float Multiplication: 64.80000000000001
```

And here's a division operation with floats:

```python
my_float_1 = 5.4
my_float_2 = 12.0

float_division = my_float_2 / my_float_1
print('Float Division:', float_division) # Float Division: 2.222222222222222
```

If you add an integer and a float, the result is automatically converted to a float:

```python
my_int = 56
my_float = 5.4

sum_int_and_float = my_int + my_float

print(sum_int_and_float) # 61.4
print(type(sum_int_and_float)) # <class 'float'>
```

This is true for other basic arithmetic operations, too, like subtraction, multiplication, and division. If you mix integers and floats, Python will return a float as the result.

You can also perform more complex arithmetic calculations such as getting the remainder of two numbers with the modulo operator, floor division, and exponentiation with both integers and floats.

The modulo operator (`%`) returns the remainder when the value on the left is divided by the value on the right:

```python
my_int_1 = 56
my_int_2 = 12

my_float_1 = 5.4
my_float_2 = 12.0

mod_ints = my_int_1 % my_int_2
mod_floats = my_float_2 % my_float_1

print('Integer Modulus:', mod_ints) # Integer Modulus: 8
print('Float Modulus:', mod_floats) # Float Modulus: 1.1999999999999993
```

Floor division divides two numbers and rounds down the result to the nearest whole number. This is done with the double forward slash operator (`//`):

```python
my_int_1 = 56
my_int_2 = 12

my_float_1 = 5.4
my_float_2 = 12.0

floor_div_ints = my_int_1 // my_int_2
floor_div_floats = my_float_2 // my_float_1

print('Integer Floor Division:', floor_div_ints) # Integer Floor Division: 4
print('Float Floor Division:', floor_div_floats) # Float Floor Division: 2.0
```

Exponentiation raises a number to the power of another, and is done with the double asterisk operator (`**`):

```python
my_int_1 = 56
my_int_2 = 12

my_float_1 = 5.4
my_float_2 = 12.0

exp_ints = my_int_1 ** my_int_2
exp_floats = my_float_1 ** my_float_2

print('Integer Exponentiation:', exp_ints) # Integer Exponentiation: 951166013805414055936
print('Float Exponentiation:',  exp_floats) # Float Exponentiation: 614787626.1765089
```

Python also provides built-in functions for converting either numeric data or strings into integers or floats. You can use the `float()` function to convert an integer into a float by adding a decimal point of `0` to the integer:

```python
my_int_1 = 56
my_float_1 = float(my_int_1)

print(my_float_1)  # 56.0
print(type(my_float_1))  # <class 'float'>
```

And you can use the `int()` function to convert a float into an integer, which removes the decimal point and everything after it from the float you pass it:

```python
my_float = 12.92563
my_int = int(my_float)

print(my_int)  # 12
print(type(my_int))  # <class 'int'>
```

Also, you can use the same built-in functions to convert a string into either a float or integer:

```python
my_str_int = '45'
my_str_float = '7.8'

converted_int = int(my_str_int)
converted_float = float(my_str_float)

print(converted_int, type(converted_int))  # 45 <class 'int'>
print(converted_float, type(converted_float))  # 7.8 <class 'float'>
```

Here are some other methods Python provides for working with integers and floats.

- `round()`: Rounds a number to the specified number of decimal places. By default this function rounds to the nearest integer, and returns a whole number with no decimal places:
    

```python
my_int_1 = 4.798
my_int_2 = 4.253

rounded_int_1 = round(my_int_1)
rounded_int_2 = round(my_int_2, 1)

print(rounded_int_1) # 5
print(rounded_int_2) # 4.3
```

- `abs()`: returns the absolute value of a number,
    

```python
num = -15

absolute_value = abs(num)
print(absolute_value) # 15
```

- `bin()`: converts an integer to its binary representation as a string.
    
- `oct()`: converts an integer to its octal representation as a string.
    
- `hex()`: converts an integer to its hexadecimal representation as a string.
    

```python
my_int = 56

binary_representation = bin(my_int)
print(binary_representation)  # 0b111000

octal_representation = oct(my_int)
print(octal_representation) # 0o70

hex_representation = hex(my_int)
print(hex_representation) # 0x38
```

- `pow()`: raises a number to the power of another or performs modular exponentiation.
    

```python
result_1 = pow(2, 3)  # Equivalent to 2 ** 3
print(result_1)  # 8

result_2 = pow(2, 3, 5)  # (2 ** 3) % 5
print(result_2)  # 3
```


## How Do Augmented Assignments Work?

### Description

Augmented assignment combines a binary operation with an assignment in one step. It takes a variable, applies an operation to it with another value, and stores the result back into the same variable.

If you're familiar with a language like JavaScript, you've probably heard of the addition assignment operator (`+=`) or subtraction assignment (`-=`), and others. Those exist in Python, too. The only difference is that they're referred to as **augmented assignments**.

The basic syntax of an augmented assignment looks like this:

```python
variable <operator>= value
```

Which is a more efficient way of doing this:

```python
variable = variable <operator> value
```

For example, here's an example of using augmented assignment to add `5` to an existing variable:

```python
my_var = 10
my_var += 5

print(my_var) # 15
```

And here is the same thing, but without augmented assignment:

```python
my_var = 10
my_var = my_var + 5

print(my_var) # 15
```

The advantage of augmented assignment is that it provides a concise and readable way to update a variable value without repeating the variable name. In turn, this reduces redundancy and potential errors that might arise from a typo or something similar.

Every operator can use an augmented assignment. We've looked at the addition assignment operator (`+=`), so let's look at others.

- The subtraction assignment operator (`-=`) subtracts the right operand from the left variable and stores the difference in the left variable:

```python
count = 14
count -= 3

print(count) # 11
```

- The multiplication assignment operator (`*=`) multiplies the left variable by the right operand and stores the product back in the left variable:
    

```python
product = 65
product *= 7

print(product) # 455
```

- The division assignment operator (`/=`) divides the left variable by the right and stores the result back in the left variable:
    

```python
price = 100
price /= 4

print(price) # 25.0
```

- The floor division operator (`//=`) floor‑divides the left variable by the right and stores the result back in the left variable:
    

```python
total_pages = 23
total_pages //= 5

print(total_pages) # 4
```

- The modulus assignment operator (`%=`) computes the remainder of the left variable divided by the right and stores it back in the left variable:
    

```python
bits = 35
bits %= 2

print(bits) # 1
```

- The exponentiation assignment operator (`**=`) raises the left variable to the power of the right and stores the result back in the left variable:
    

```python
power = 2
power **= 3

print(power) # 8
```

There are other augmented assignment operators too, like those for bitwise operators. They include `&=`, `^=`, `>>=`, and `<<=`.

You can use some augmented assignment operators with strings, too. For example, the addition assignment operator makes it easy to concatenate strings:

```python
greet = 'Hello'
greet += ' World'

print(greet) # Hello World
```

And the multiplication assignment operator can be used to repeat a string:

```python
greet = 'Hello'
greet *= 3

print(greet) # HelloHelloHello
```

Other augmented assignments throw a `TypeError` when you use them with strings:

```python
greet = 'Hello'
greet -= ' World'

print(greet) # TypeError: unsupported operand type(s) for -=: 'str' and 'str'


greet = 'Hello'
greet /= 'World'

print(greet) # TypeError: unsupported operand type(s) for /=: 'str' and 'str' 
```

If you're wondering if increment and decrement operators (`++` and  `--`) work in Python, they don't. That's because Python deliberately avoids C-style increment and decrement shortcuts in order to keep the language clear and explicit.

Instead of `x++`, you can simply write `x += 1`, which makes it obvious that you're incrementing the value of `x` by `1`.

Writing `++x` in Python just applies the unary plus twice, and increment anything:

```python
my_var = 5

print(+my_var)   # 5
print(++my_var)  # 5
print(+++my_var) # 5

my_var += 1

print(my_var) # 6
```


## How Do Functions Work in Python?

### Description

Functions are reusable pieces of code that run when you call them. Many programming languages come with built-in functions that make it easier to get started. Python is no exception, and we've already covered some built-in functions like `print()` in previous lectures.

Another helpful built-in function is `input()`, which lets you prompt the user for input:

```python
name = input('What is your name?') # User types "Kolade" and presses Enter  
print('Hello', name) # Output: Hello Kolade
```

On the other hand, `int()` converts a number, boolean, and a numeric string into an integer:

```python
print(int(3.14)) # 3
print(int('42')) # 42
print(int(True)) # 1
print(int(False)) # 0 
```

You can also write your own custom functions. To do that, you use the `def` keyword, followed by the name you want to give your function, a pair of parentheses, and a colon. Then on a new line, you write the code your function should run. The code the function runs is also referred to as the function's body.

Here's an example of a custom function named `hello` that prints the string `Hello World` to the terminal:

```python
def hello():
    print('Hello World')
```

To run the function, you need to call it with its name followed by a pair of parentheses:

```python
hello() # Hello World
```

Notice the indentation before `print('Hello World')`. The level of indentation defines a "code block" in Python, which is a group of statements that belong together.

While other programming languages use characters like curly braces to define code blocks, and just use indentation for readability, in Python, code blocks are determined by indentation.

Though you can use either two or four spaces to determine each level of indentation, the Python style guide recommends using four spaces.

Blocks are also found in loops and conditionals, which you'll learn about in future lectures.

Here's another simple function that prints the sum of two numbers to the terminal:

```python
def calculate_sum(a, b):
    print(a + b)
```

You can see that our function, `calculate_sum`, has `a` and `b` in its parentheses, separated by a comma. Those are called parameters. Think of parameters as placeholder variables that act as "slots" for the values you pass into functions when you call them.

To use the parameters, you have to pass in "arguments". Arguments are the values you pass to a function when you call it.

Here's how to call the `calculate_sum` function to sum together the numbers `3` and `1`:

```python
calculate_sum(3, 1) # 4
```

If you call the function without the correct number of arguments, you'll get a `TypeError`:

```python
calculate_sum()

# TypeError: calculate_sum() missing 2 required positional arguments: 'a' and 'b'
```

Functions also use a special `return` keyword to exit the function and return a value. If you don't explicitly use `return`, Python will return `None` by default.

Here's an example:

```python
def calculate_sum(a, b):
    print(a + b)

my_sum = calculate_sum(3, 1) # 4
print(my_sum) # None
```

You can see that the `calculate_sum` function prints the sum of `a` and `b`, but it doesn't return anything explicitly. So when we assign its result to `my_sum`, the value is actually `None`. To fix that, you can use the `return` keyword to send back the result:

```python
def calculate_sum(a, b):
    return a + b

my_sum = calculate_sum(3, 1)
print(my_sum) # 4
```

Now, `calculate_sum` returns the sum of `a` and `b`, which gets stored in `my_sum`.

Decorators are a special kind of function in Python. They are like wrappers for other functions, so they take another function as an argument. With decorators, you get to add extra functionality to a function without modifying its original code. Here's an example of how to use a decorator:

```python
def say_hello():
   name = input('What is your name? ')
   return 'Hello ' + name

def uppercase_decorator(func):
   def wrapper():
       original_func = func()
       modified_func = original_func.upper()
       return modified_func
   return wrapper

say_hello_res = uppercase_decorator(say_hello)

print(say_hello_res())
```

In this code:

- We are getting a user input and storing it in a `name` variable.
    
- The function `say_hello` returns `Hello`, and the `name`.
    
- The decorator, `uppercase_decorator` takes a function, calls it, then turns its return value to uppercase, and returns the original function.
    
- The `uppercase_decorator` function is then called with the original `say_hello` function and saved in `say_hello_res`.
    
- `say_hello_res` is then called and printed in one line.
    

That's how decorators are typically used.


## What Is Scope in Python and How Does It Work?

### Description

In Python, scope determines the point at which you can access a variable. It's what controls the lifetime of a variable and how it is resolved in different parts of the code.

To correctly determine scope, Python follows the **LEGB** rule, which stands for the following:

- **Local scope (L)**: Variables defined in functions or classes.
    
- **Enclosing scope (E)**: Variables defined in enclosing or nested functions.
    
- **Global scope (G):** Variables defined at the top level of the module or file.
    
- **Built-in scope (B)**: Reserved names in Python for predefined functions, modules, keywords, and objects.

Python uses the LEGB rule to resolve the scope of the variables in your program. We'll dive into each of these rules so you get a better understanding of the process.

**Local scope** means that a variable declared inside a function or class can only be accessed within that function or class.

Here's an example:

```python
def my_func():
    my_var = 10
    print(my_var)
```

In this case, the `my_func` function has its own scope which cannot be accessed from outside the function. Calling `my_func` will output `10`, but printing `my_var` outside the function will lead to a `NameError`:

```python
def my_func():
    my_var = 10 # Locally scoped to my_func
    print(my_var)

my_func() # 10

print(my_var) # NameError: name 'my_var' is not defined
```

**Enclosing scope** means that a function that's nested inside another function can access the variables of the function it's nested within.

For example:

```python
def outer_func():
    msg = 'Hello there!'

    def inner_func():
        print(msg)

    inner_func()

outer_func() # Hello there!
```

In this example, the inner function, `inner_func`, can freely access the `msg` variable defined in the outer function, `outer_func`. However, note that outer functions cannot access variables defined within any nested functions:

```python
def outer_func():
    msg = 'Hello there!'
    print(res)

    def inner_func():
        res = 'How are you?'
        print(msg)

    inner_func()

outer_func() # NameError: name 'res' is not defined
```

That's because `res` is locally scoped to `inner_func`. Also, notice that `outer_func` tries to print `res` before `inner_func` is called.

One solution is to initialize `res` as an empty string in the enclosing scope, which is within `outer_func`. Then within `inner_func`, make `res` a non-local variable with the `nonlocal` keyword:

```python
def outer_func():
    msg = 'Hello there!'
    res = ""  # Declare res in the enclosing scope

    def inner_func():
        nonlocal res  # Allow modification of an enclosing variable
        res = 'How are you?'
        print(msg)  # Accessing msg from outer_func()

    inner_func()
    print(res)  # Now res is accessible and modified

outer_func()

# Output:
# Hello there!
# How are you?
```

**Global scope** refers to variables that are declared outside any functions or classes which can be accessed from anywhere in the program. Here, `my_var` can be accessed anywhere, even inside a function it's not defined in:

```python
my_var = 100

def show_var():
    print(my_var)

show_var() # 100
print(my_var) # 100
```

And if you want to make a locally scoped variable defined inside a function globally accessible, you can use the `global` keyword:

```python
my_var_1 = 7

def show_vars():
    global my_var_2
    my_var_2 = 10
    print(my_var_1)
    print(my_var_2)

show_vars() # 7 10

# my_var_2 is now a global variable and can be accessed anywhere in the program
print(my_var_2) # 10
```

You can also use the `global` keyword to modify a global variable:

```python
my_var = 10  # A global variable

def change_var():
    global my_var  # Allows modification of a global variable
    my_var = 20

change_var()

print(my_var)  # my_var is now modified globally to 20
```

Finally, **built-in scope** refers to all of Python's built-in functions, modules, and keywords, and are available anywhere in your program:

```python
print(str(45)) # '45'
print(type(3.14)) # <class 'float'>
print(isinstance(3, str)) # False
```


## How Do Conditional Statements and Logical Operators Work?

### Description

Conditional statements, or conditionals, let you control the flow of your program based on whether certain conditions are true or false.

But before we get into all that, let's go over the basic building blocks of conditional statements, starting with comparison operators. Comparison operators are operators that let you compare two or more values, and return a boolean value.

In a previous lecture, you learned that booleans are one of the data types in Python, and can only be `True` or `False`.

Here's a table with the comparison operators in Python:

| Operator | Name | Description |
| --- | --- | --- |
| `==` | Equal | Checks if two values are equal |
| `!=` | Not equal | Checks if two values are not equal |
| `>` | Greater than | Checks if the value on the left is greater than the value on the right |
| `<` | Less than | Checks if the value on the left is less than the value on the right |
| `>=` | Greater than or equal | Checks if the value on the left is greater than or equal to the value on the right |
| `<=` | Less than or equal | Checks if the value on the left is less than or equal to the value on the right |

Here are some of those expressions that evaluate to `True` or `False`:

```python
print(3 > 4) # False
print(3 < 4) # True
print(3 == 4) # False
print(4 == 4) # True
print(3 != 4) # True
print(3 >= 4) # False
print(3 <= 4) # True
```

These operators can be used in conditionals to compare values and run certain code based on whether the conditional evaluates to `True` or `False`.

In Python, the most basic conditional is the `if` statement. Here's the basic syntax:

```python
if condition:
    # Code to execute if condition is True
```

* `if` statements start with the `if` keyword.
    
* `condition` is an expression that evaluates to `True` of `False`, followed by a colon (`:`).

* The indentation specifies the block of code within the body of the `if` statement.
    

And here's an example:

```python
age = 18

if age >= 18:
    print('You are an adult') # You are an adult
```

But if `age` is anything less than `18`, nothing is printed in the terminal:

```python
age = 12

if age >= 18:
    print('You are an adult') # Nothing shows up in the terminal
```

But what if you also want to print something if `age` is less than `18`? That's where the `else` clause comes in. The `else` clause runs when the `if` condition is false. Here's the syntax for an `if…else` statement:

```python
if condition:
   # Code to execute if condition is True
else:
   # Code to execute if condition is False
```

For example:

```python
age = 12

if age >= 18:
    print('You are an adult')
else:
    print('You are not an adult yet') # You are not an adult yet
```

There might be situations in which you want to account for multiple conditions. To do that, Python lets you extend your if statement with the `elif` (else if) keyword.

Here's the syntax:

```python
if condition:
   # Code to execute if condition is True
elif condition2:
   # Code to execute if condition2 is True
else:
   # Code to execute if all conditions are False
```

For example:

```python
age = 12

if age >= 18:
    print('You are an adult')
elif age >= 13:
    print('You are a teenager')
else:
    print('You are a child') # You are a child
```

Note that you can use as many `elif` statements as you want:

```python
age = 2

if age >= 65:
    print('You are a senior citizen')
elif age >= 30:
    print('You are an adult in your prime')
elif age >= 18:
    print('You are a young adult')
elif age >= 13:
    print('You are a teenager')
elif age >= 3:
    print('You are a young child')
else:
    print('You are a toddler or an infant') # You are a toddler or an infant
```

Now that you understand how comparison operators and conditional statements work in Python, you can start writing programs that make decisions based on logic and input. Whether you’re comparing values or branching through multiple conditions, these tools are the foundation to writing flexible, responsive code.


## What Are Truthy and Falsy Values, and How Do Boolean Operators and Short-Circuiting Work?

### Description

In the previous lecture, you learned how to use comparison operators and conditional statements to control the flow of your programs.

While those are very powerful, you will often run into situations where you need to compare multiple values at once. This can lead to nested conditional statements, for example:

```python
is_citizen = True
age = 25

if is_citizen:
    if age >= 18:
        print('You are eligible to vote') # You are eligible to vote
else:
    print('You are not eligible to vote')
```

The above example will first check if `is_citizen` is `True`. If so, it will then go to the nested `if` statement and check if `age` is greater than or equal to `18`. Since `age` is greater than or equal to `18`, the message printed to the terminal will be `You are eligible to vote`. If `is_citizen` were `False`, then the message printed to the terminal would have been `You are not eligible to vote`.

If you are working with more complex conditional statements, then you can use Python’s `and`, `or`, and `not` operators.

But before we dive into those operators, let’s take a look at what truthy and falsy values are.

In Python, every value has an inherent boolean value, or a built-in sense of whether it should be treated as `True` or `False` in a logical context. Many values are considered **truthy**, that is, they evaluate to `True` in a logical context. Others are **falsy**, meaning they evaluate to `False`.

Here are a few falsy values:

- `None`
- `False`
- Integer `0`
- Float `0.0`
- Empty strings `""`

Other values like non-zero numbers, and non-empty strings are truthy.

If you want to check whether a value is truthy or falsy, you can use the built-in `bool()` function. It explicitly converts a value to its boolean equivalent and returns `True` for truthy values and `False` for falsy values. Here are a few examples:

```py
print(bool(False)) # False
print(bool(0))  # False
print(bool('')) # False

print(bool(True)) # True
print(bool(1)) # True
print(bool('Hello')) # True
```

Now that you understand truthy and falsy values, we can take a look at Boolean operators, which are also known as logical operators or Boolean operations. These are special operators that allow you to combine multiple expressions to create more complex decision-making logic in your code.

There are three Boolean operators in Python: `and`, `or`, and `not`.

Let’s first take a look at the `and` operator.

The `and` operator takes two operands and returns the first operand if it is falsy, otherwise, it returns the second operand. Both operands must be truthy for an expression to result in a truthy value.

Here is an example:

```python
is_citizen = True
age = 25

print(is_citizen and age) # 25
```

In the above example, the number 25 is printed to the terminal because the `and` operator will evaluate the second operand if the first operand is `True`. The `and` operator is known as a short-circuit operator. Short-circuiting means Python checks values from left to right and stops as soon as it determines the final result.

You'll often use `and` within `if` statements to check if multiple conditions are met. Here’s how you can refactor the earlier example to uses the `and` operator instead of nested `if` statements:

```python
is_citizen = True
age = 25

if is_citizen and age >= 18:
    print('You are eligible to vote') # You are eligible to vote
else:
    print('You are not eligible to vote')
```

In the example above, `is_citizen` is `True`, and `age >= 18` evaluates to `True`. Since both operands of the `and` operator are truthy, the condition `is_citizen and age >= 18` evaluates to `True`, and the `print` call in the `if` block is executed.

Now let's take a look at the `or` operator. This operator returns the first operand if it is truthy, otherwise, it returns the second operand. An `or` expression results in a truthy value if at least one operand is truthy. The `or` operator is also known as a short-circuit operator. Here is an example:

```python
age = 19
is_employed = False

print(age or is_employed) # 19
```

The following code will print the number 19 because the first operand `age` is `True`.

If you need to check if one or more expressions is `True`, then you can use the `or` operator in a conditional like this:

```python
age = 19
is_student = True

if age < 18 or is_student:
    print('You are eligible for a student discount') # You are eligible for a student discount
else:
    print('You are not eligible for a student discount')
```

In this case, `age < 18` is `False`, but `is_student` is `True`. Since at least one condition is true, the entire `or` expression evaluates to `True`, and the discount message in the `if` block is printed.

The last operator we will look at is the `not` operator which takes a single operand and inverts its boolean value. It converts truthy values to `False` and falsy values to `True`. Unlike the previous operators we looked at, `not` always returns `True` or `False`.

Here are a few examples:

```python
print(not '') # True, because empty string is falsy
print(not 'Hello') # False, because non-empty string is truthy
print(not 0) # True, because 0 is falsy
print(not 1) # False, because 1 is truthy
print(not False) # True, because False is falsy
print(not True) # False, because True is truthy
```

It is common to use the `not` operator in conditionals to check if something is not `True` or `False`, like this:

```python
is_admin = False

if not is_admin:
    print('Access denied for non-administrators.') # Access denied for non-administrators.
else:
    print('Welcome, Administrator!')
```

Since `is_admin` is `False`, then `not is_admin` is saying not `False` which is `True`. So the message `Access denied for non-administrators.` will be printed.

Now that you understand truthy and falsy values, the `and`, `or`, and `not` operators, and short-circuiting work, you can write more flexible and readable conditional logic.


## Module: Python Loops And Sequences


### Lecture Block: Lecture Working With Loops And Sequences


## What Are Lists and How Do They Work?

### Description

Over the next few lectures we are going to learn about lists, tuples, and ranges, which are three basic sequence types used in Python.

The list data type is an ordered sequence of elements that can be comprised of strings, numbers, or even other lists. Similar to JavaScript, lists are mutable and use zero-based indexing, meaning that the first element of the list is at index zero.

Here is the basic syntax for a list:

```py
cities = ['Los Angeles', 'London', 'Tokyo']
```

To access an element from the `cities` list, you can reference its index number in the sequence. Here is an example of accessing the first element of the `cities` list:

```py
cities = ['Los Angeles', 'London', 'Tokyo']
cities[0] # 'Los Angeles'
```

Negative indexing is used to access elements starting from the end of the list instead of the beginning at index `0`. To access the last element of any list, you can use `-1` like this:

```py
cities = ['Los Angeles', 'London', 'Tokyo']
cities[-1] # 'Tokyo'
```

Another way to create a list is to use the `list()` constructor. The `list()` constructor is used to convert an iterable into a list like this:

```py
developer = 'Jessica'
list(developer) # ['J', 'e', 's', 's', 'i', 'c', 'a']
```

An iterable is a special type of object that can be looped over one item at a time. You will learn more about loops in Python later on.

To get the total number of elements in a list, you can use the `len()` function like this:

```py
numbers = [1, 2, 3, 4, 5]
len(numbers) # 5
```

If you wanted to update a value at a particular index, you can do something like this:

```py
programming_languages = ['Python', 'Java', 'C++', 'Rust']
programming_languages[0] = 'JavaScript'
print(programming_languages) # ['JavaScript', 'Java', 'C++', 'Rust']
```

Since lists are mutable, you can update any element in the list as long as you pass in a valid index number. If you pass in an index (either positive or negative) that is out of bounds for the list, then you will receive an `IndexError`:

```py
programming_languages = ['Python', 'Java', 'C++', 'Rust']
programming_languages[10] = 'JavaScript'

"""
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
IndexError: list assignment index out of range
"""
```

If you want to remove an element from a list you can use the `del` keyword like this:

```py
developer = ['Jane Doe', 23, 'Python Developer']
del developer[1]
print(developer) # ['Jane Doe', 'Python Developer']
```

Sometimes it is helpful to check if an element is inside the list. To do that, you can use the `in` keyword like this:

```py
programming_languages = ['Python', 'Java', 'C++', 'Rust']

'Rust' in programming_languages # True
'JavaScript' in programming_languages # False
```

Sometimes it is common to have lists nested inside of other lists like this:

```py
developer = ['Alice', 25, ['Python', 'Rust', 'C++']]
```

In this example, we have one nested list containing three popular programming languages. To access the nested list, you will need to access it using index `2` since lists are zero based indexed:

```py
developer = ['Alice', 25, ['Python', 'Rust', 'C++']]
developer[2] # ['Python', 'Rust', 'C++']
```

Then to access the second language from that nested list, you will need to access it using index `1` like this:

```py
developer = ['Alice', 25, ['Python', 'Rust', 'C++']]
developer[2][1] # 'Rust'
```

Another common technique used with lists is unpacking values.

Unpacking values from a list is a technique used to assign values from a list to new variables. Here is an example of unpacking a `developer` list into new variables called `name`, `age` and `job`. 

```py
developer = ['Alice', 34, 'Rust Developer']
name, age, job = developer

print(name) # 'Alice'
print(age) # 34
print(job) # 'Rust Developer'
```

Here, `name` has the value `'Alice'`, `age` has the value `34`, and `job` has the value `'Rust Developer'`.

If you need to collect any remaining elements from a list, you can use the asterisk (`*`) operator like this:

```py
developer = ['Alice', 34, 'Rust Developer']
name, *rest = developer

print(name) # 'Alice'
print(rest) # [34, 'Rust Developer']
```

In this example, `name` will still have the value `'Alice'`, and `rest` is a list of two items: the number `34` and the string `'Rust Developer'`.

If the numbers of variables on the left side of the assignment operator doesn't match the total numbers of items in the list, then you will receive a `ValueError`:

```py
developer = ['Alice', 34, 'Rust Developer']
name, age, job, city = developer

"""
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
ValueError: not enough values to unpack (expected 4, got 3)
"""
```

The last concept we will look at is the slice operator (`:`). Similar to strings, you can access portions of a list by using the slice operator like this:

```py
desserts = ['Cake', 'Cookies', 'Ice Cream', 'Pie', 'Brownies']
desserts[1:4] # ['Cookies', 'Ice Cream', 'Pie']
```

In this example, the start index is `1` since that points to the second item in the list. Then we use the slice operator followed by an end index of `4`, which includes everything up to (but not including), the item at that index.

Another thing you can do with the slice operator `:` is specify a step interval which determines how much to increment between the indices. Let's say you had a list of numbers like this:

```py
numbers = [1, 2, 3, 4, 5, 6]
```

If you wanted to extract a list of just even numbers, you can use the slicing operator like this:

```py
numbers = [1, 2, 3, 4, 5, 6]
numbers[1::2] # [2, 4, 6]
```

The first even number is at index `1`, so that will be the start index. Since we want to go through the end of the list, then we omit the end index. Lastly, we specify `2` for the optional step interval so it will only increment by `2` instead of the default `1`.

Lists are a useful and flexible data structure that you will use a lot in your Python programs. In the next lecture, you will learn about common methods that you can use with lists.


## What Are Some Common Methods Used for Lists?

### Description

In the previous lecture, you were introduced to the list data type and learned how to access elements from a list as well as list slicing. In this lecture, you will continue to learn about lists and some common methods associated with them like `append()`, `pop()`, and `sort()`.

The first method we will look at is the `append()` method. This is used to add an item to the end of the list. Here is an example of using the `append()` method to add the number `6` to list of numbers:

```py
numbers = [1, 2, 3, 4, 5]
numbers.append(6)
print(numbers) # [1, 2, 3, 4, 5, 6]
```

If you want to add one list at the end of another, you can also use the `append()` method like this:

```py
numbers = [1, 2, 3, 4, 5]
even_numbers = [6, 8, 10]

numbers.append(even_numbers)
print(numbers) # [1, 2, 3, 4, 5, [6, 8, 10]]
```

Notice how the entire `even_numbers` list is nested inside of the `numbers` list.

But if you want to add all of the individual numbers from the `even_numbers` list at the end of the `numbers` list, then you can use the `extend()` method.

The `extend()` method is similar to the `append()` method, but with `extend()` you can add multiple elements from one list to another. Here's an example of adding the numbers `6`, `8`, and `10` from one list to the end of the `numbers` list:

```py
numbers = [1, 2, 3, 4, 5]
even_numbers = [6, 8, 10]

numbers.extend(even_numbers)
print(numbers) # [1, 2, 3, 4, 5, 6, 8, 10]
```

As you can see, the nested list is gone and it's just a list of numbers.

To insert an element at a specific index in a list, you can use the `insert()` method. This method accepts two arguments: the index where you wish to insert the new item and the item you want to insert.

Here is an example of using the `insert()` method:

```py
numbers = [1, 2, 3, 4, 5]
numbers.insert(2, 2.5)

print(numbers) # [1, 2, 2.5, 3, 4, 5]
```

The following code will insert the number `2.5` at index `2` in the `numbers` list.

If you want to remove an element from a list, you can use the `remove()` method. Here is an example of using the `remove()` method to remove a duplicate number from a `numbers` list:

```py
numbers = [1, 2, 3, 4, 5, 5]
numbers.remove(5)

print(numbers) # [1, 2, 3, 4, 5]
```

It is important to note that this method will only remove the first occurrence of an item. Not all of them:

```py
numbers = [1, 2, 3, 4, 5, 5, 5]
numbers.remove(5)

print(numbers) # [1, 2, 3, 4, 5, 5]
```

To remove an element at a specific index in the list, you can use the `pop()` method like this:

```py
numbers = [1, 2, 3, 4, 5]
numbers.pop(1) # The number 2 is returned
```

If you don't specify an element for the `pop` method, then the last element is removed.

```py
numbers = [1, 2, 3, 4, 5]
numbers.pop() # The number 5 is returned
```

If you need to empty the list, then you can use the `clear()` method like this:

```py
numbers = [1, 2, 3, 4, 5]
numbers.clear()

print(numbers) # []
```

The next method we will take a look at is the the `sort()` method. This method is used to sort the elements in place. Here is an example of sorting a random list of numbers in place:

```py
numbers = [19, 2, 35, 1, 67, 41]
numbers.sort()

print(numbers) # [1, 2, 19, 35, 41, 67]
```

In contrast to the `sort()` method, there is the `sorted()` function which works for any iterable and returns a new sorted list instead of modifying the original list. For example:

```py
numbers = [19, 2, 35, 1, 67, 41]
sorted_numbers = sorted(numbers)

print(numbers) # [19, 2, 35, 1, 67, 41]
print(sorted_numbers) # [1, 2, 19, 35, 41, 67]
```

As a reminder, an iterable is a special type of object that you can loop over, allowing you to access each item one at a time. You'll learn more about how loops work in Python in a future lecture.

Both the `sort()` method and `sorted()` function accept optional `key` and `reverse` parameters. You will learn more about these optional parameters in a future lecture when you learn about tuples. You'll also learn more about other built-in functions like `sorted()` in future lectures.

The next method we will take a look at is the the `reverse()` method. This method, will reverse a list of elements in place like this:

```py
numbers = [6, 5, 4, 3, 2, 1]
numbers.reverse()

print(numbers) # [1, 2, 3, 4, 5, 6]
```

The last method we will take a look at is the `index` method. This is used to find the first index where an element can be found in a list. Here is an example of using the `index` method to find the language `'Java'` in a `programming_languages` list:

```py
programming_languages = ['Rust', 'Java', 'Python', 'C++']
programming_languages.index('Java') # 1
```

If the element cannot be found, then Python throws a `ValueError`:

```py
programming_languages = ['Rust', 'Java', 'Python', 'C++']
programming_languages.index('JavaScript')

"""
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: 'JavaScript' is not in list
"""
```

There are a few more methods for Python lists, but this initial list of methods is a good place to start.


## What Are Tuples and How Do They Work?

### Description

A tuple is a Python data type used to create an ordered sequence of values. Tuples can contain a mixed set of data types like this:

```py
developer = ('Alice', 34, 'Rust Developer')
```

Tuples are similar to lists, but while lists are a mutable data type, tuples are immutable. This means that the elements in a tuple cannot be changed once it's created.

If you try to update one of the items in the tuple, you will get a `TypeError`:

```py
programming_languages = ('Python', 'Java', 'C++', 'Rust')
programming_languages[0] = 'JavaScript'

"""
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
TypeError: 'tuple' object does not support item assignment
"""
```

To access an element from a tuple, you can use bracket notation and the index number:

```py
developer = ('Alice', 34, 'Rust Developer')
developer[1] # 34
```

If you need to access elements starting from the end of a tuple, then you can use negative indexing. Here is an example of using a negative index to access the second to last element in a tuple:

```py
numbers = (1, 2, 3, 4, 5)
numbers[-2] # 4
```

If you try to pass in an index number that exceeds or equals the length of the tuple, then you will receive an `IndexError` like this:

```py
numbers = (1, 2, 3, 4, 5)
numbers[7]

"""
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
IndexError: list index out of range
"""
```

Another way to create a tuple is by using the `tuple()` constructor like this:

```py
developer = 'Jessica'
tuple(developer) # ('J', 'e', 's', 's', 'i', 'c', 'a')
```

For the `tuple()` constructor, you can pass in different iterables like strings, lists and even other tuples. 

To check if an item is in a tuple, you can use the `in` keyword like this:

```py
programming_languages = ('Python', 'Java', 'C++', 'Rust')

'Rust' in programming_languages # True
'JavaScript' in programming_languages # False
```

You can also unpack items from a tuple just like you did with lists:

```py
developer = ('Alice', 34, 'Rust Developer')
name, age, job = developer

print(name) # 'Alice'
print(age) # 34
print(job) # 'Rust Developer'
```

In this example, `name` has the value `'Alice'`, `age` has the value `34`, and `job` has the value `'Rust Developer'`.

If you need to collect any remaining elements from a tuple, you can use the asterisk (`*`) operator like this:

```py
developer = ('Alice', 34, 'Rust Developer')
name, *rest = developer

print(name, rest) # 'Alice'
print(rest) # [34, 'Rust Developer']
```

Here, `name` has the value `'Alice'`, and `rest` is a list comprised of the number `34` and the string `'Rust Developer'`.

Just like with a list, you can use the slice operator on a tuple to extract a portion of it. Here is an example of extracting the items `'pie'` and `'cookies'` into a separate tuple:

```py
desserts = ('cake', 'pie', 'cookies', 'ice cream')
desserts[1:3] # ('pie', 'cookies')
```

Remember that the first number represents the starting index for the extraction while the second number represents the ending index. But note that the item at the ending index is not included in the extracted tuple.

If you need to remove an item from a tuple, that isn't possible because tuples are immutable. So this example, will produce an error:

```py
developer = ('Jane Doe', 23, 'Python Developer')
del developer[1]

"""
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
TypeError: "tuple" object doesn't support item deletion
"""
```

So when might you use a tuple over a list?

If you need a dynamic collection of elements where you can add, remove and update elements, then you should use a list. If you know that you are working with a fixed and immutable collection of data, then you should use a tuple.

In the next lecture, we will take a look at some common methods you will use when working with tuples.


## What Are Some Common Methods for Tuples?

### Description

In the previous lecture, you learned how to work with the tuple data type. In this lecture, you'll learn about some common methods you'll use when working with tuples.

The first method we will cover is `count()`. This method is used to determine how many times an item appears in a tuple. Here is an example of checking how many times the string `Rust` appears in a tuple named `programming_languages`:

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')
programming_languages.count('Rust') # 2
```

Since `Rust` appears twice in the tuple, the `count()` method returns the number `2`. If the specified item in the `count()` function is not present at all in the tuple, then the return value is `0`:

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')
programming_languages.count('JavaScript') # 0
```

If no arguments are passed into the `count()` function, then Python raises a `TypeError`:

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')
programming_languages.count()

"""
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
TypeError: tuple.count() takes exactly one argument (0 given)
"""
```

The next method we will look at is the `index()` method. This method is used to find the index where a particular item is present in a tuple. Here is an example of using the `index()` method to find the index for the string `Java`:

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')
programming_languages.index('Java') # 1
```

If the specified item cannot be found, then Python raises a `ValueError`:

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')
programming_languages.index('JavaScript')

"""
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
ValueError: tuple.index(x): x not in tuple
"""
```

Another thing you can do with the `index()` method is to pass in optional start and stop index arguments. Here is an example of passing in an optional start index:

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python')
programming_languages.index('Python', 3) # 5
```

In this example, we are specifying where to start searching for the string `Python`. By passing in the number `3` as the second argument to the `index()` function, we are specifying to start searching at index `3`. Since `Python` appears twice in the tuple, the `index()` function will return index `5` instead of index `2` because of the use of the optional start index argument.

You can also pass in an optional stop index. Here is a modified example of specifying a start and stop index:

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python', 'JavaScript', 'Python')
programming_languages.index('Python', 2, 5) # 2
```

Now the result is index `2` because we are starting the search at index `2`, and searching up to, but not including, index `5`.

Another commonly used function used with tuples is the `sorted()` function. In a previous lecture you learned about the `sort()` method for lists. Well, the `sorted()` function can be used on any iterable including tuples.

Here is an example of creating a new list of numbers using the `sorted()` function:

```py
numbers = (13, 2, 78, 3, 45, 67, 18, 7)
sorted(numbers) # [2, 3, 7, 13, 18, 45, 67, 78]
```

The `sorted()` function will always create a new list of the sorted values. This differs from the `sort()` method which sorts the elements of a list in place and does not return a new list.

If you need to customize the sorting behavior for an iterable, you can use the optional `reverse` and `key` arguments. Here is an example of using `key` argument to sort items in a tuple by length:

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python')
sorted(programming_languages, key=len)

# Result
# ['C++', 'Rust', 'Java', 'Rust', 'Python', 'Python']
```

If you want to create a new list of values in reverse order, then you can use the `reverse` argument like this:

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python')

print(sorted(programming_languages, reverse=True))

# Result
# ['Rust', 'Rust', 'Python', 'Python', 'Java', 'C++']
```

Tuples are a common data type in Python. Understanding how to work with them, along with some helpful methods and functions, will help you write more efficient code.


## How Do Loops Work?

### Description

As you learned in earlier modules, loops are used to repeat a block of code for a set number of times. In this lecture you will learn how to work with different types of loops in Python.

The first loop we will go over is the `for` loop. Here is an example of using a `for` loop to iterate through a list and print each item to the console:

```py
programming_languages = ['Rust', 'Java', 'Python', 'C++']

for language in programming_languages:
    print(language)
```

The result would be:

```md
Rust
Java
Python
C++
```

Notice that the `print(language)` is indented inside of the loop. Without that indentation, you would get an `IndentationError`:

```python
"""
Traceback (most recent call last):
  File "<stdin>", line 4, in <module>
IndentationError: expected an indented block after 'for' statement on line 3
"""
```

You can also use a `for` loop to iterate through other iterables like a string. Here is an example of using a `for` loop to loop through the string `code` and print out each character:

```py
for char in 'code':
    print(char)
```

The result would be:

```md
c
o
d
e
```

Just like in JavaScript, you can also nest `for` loops in Python. Here is an example of using a nested `for` loop:

```py
categories = ['Fruit', 'Vegetable']
foods = ['Apple', 'Carrot', 'Banana']

for category in categories:
    for food in foods:
        print(category, food)
```

The outer loop will iterate through each `category` in the `categories` list. For each `category`, the inner loop will iterate through each `food` in the `foods` list. Here is the result that will be printed to the console:

```md
Fruit Apple
Fruit Carrot
Fruit Banana
Vegetable Apple
Vegetable Carrot
Vegetable Banana
```

Another type of loop you can use in Python is the `while` loop. This type of loop will repeat a block of code until the condition is `False`. Here is an example of using a `while` loop for a guessing game:

```py
secret_number = 3
guess = 0

while guess != secret_number:
    guess = int(input('Guess the number (1-5): '))
    if guess != secret_number:
        print('Wrong! Try again.')

print('You got it!')
```

In this example we have a `secret_number` variable with the value of `3` and an initial guess of `0`. Then we use the `input` function to get input from the user, then convert the input string into and integer with the `int()` function, and assign it to the `guess` variable. If the user guesses correctly by inputting `3`, the `while` loop is broken out of and the message `You got it!` is printed to the console. Otherwise, the message `Wrong! Try again.` is printed to the console, and the loop repeats, prompting the user to guess again.

Here's an example result:

```md
Guess the number (1-5): 2
Wrong! Try again.
Guess the number (1-5): 1
Wrong! Try again.
Guess the number (1-5): 3
You got it!
```

Just like in JavaScript, Python supports the `break` and `continue` statements.

The `break` statement is used to stop the execution of a loop. Here is an example of using the `break` statement for a list of `developer_names`:

```py
developer_names = ['Jess', 'Naomi', 'Tom']

for developer in developer_names:
    if developer == 'Naomi':
        break
    print(developer)
```

In this example, we iterate through a list of `developer_names` and print each name to the console. If the name is equal to `Naomi`, then we break out of the loop. This results in only the name `Jess` being printed to the console.

The `continue` statement is used to skip the current iteration of a loop and move onto the next iteration. Let's modify the example from earlier to use the `continue` statement instead of `break`:

```py
developer_names = ['Jess', 'Naomi', 'Tom']

for developer in developer_names:
    if developer == 'Naomi':
        continue
    print(developer)
```

Now the result in the console will be different. The names `Jess` and `Tom` are printed because the `continue` statement skips the second iteration of the loop when `developer` is equal to `Naomi`, and does not print that name to the console.

Both `for` and `while` loops can be combined with an `else` clause, which is executed only when the loop is not terminated by a `break` statement. Here is an example of using multiple `for` loops:

```python
words = ['sky', 'apple', 'rhythm', 'fly', 'orange']

for word in words:
    for letter in word:
        if letter.lower() in 'aeiou':
            print(f"'{word}' contains the vowel '{letter}'")
            break
    else:
        print(f"'{word}' has no vowels")
```

In this example we have a list of random words, and a `for` loop is used to loop through each word. Inside the outer `for` loop, we have another `for` loop to loop through each letter of each word. If the lowercase version of the letter is a vowel, we print the word followed by what vowels it contains, then break out of the inner loop. If the word contains no values, then we print a message indicating that.

Here is what the result looks like in the console:

```md
'sky' has no vowels
'apple' contains the vowel 'a'
'rhythm' has no vowels
'fly' has no vowels
'orange' contains the vowel 'o'
```

Loops are very common in Python, so it's important to get comfortable with them. In the next few lectures, you will learn how to work with the `enumerate()` and `range()` functions in loops.


## What Are Ranges and How Can You Use Them in a Loop?

### Description

The `range()` function is used to generate a sequence of integers. Here is the basic syntax for the `range()` function:

```py
range(start, stop, step)
```

The required `stop` argument is an integer that represents the end point for the sequence of numbers being generated. Here is an example of using the `range()` function:

```py
for num in range(3):
    print(num)
```

The following code generates a sequence of numbers between `0` and `2`. The integer `3` is not included because the `stop` argument is non-inclusive.

If a `start` argument is not specified, then the default is `0`. Otherwise, you can use the optional `start` argument to start the sequence of integers at a integer other than `0`. Here is an example of generating a sequence of integers between `1` and `4`:

```py
for num in range(1, 5):
    print(num)
```

By default the sequence of integers will increment by `1`. But if you want to change that default, then you can use the optional `step` argument. Here is an example of generating a sequence of even integers between `2` and `10`:

```py
for num in range(2, 11, 2):
    print(num)
```

As mentioned earlier, there is only one required argument for the `range()` function. If you don't provide any arguments to `range()`, then you'll get a `TypeError`:

```md
ERROR!
Traceback (most recent call last):
  File "<main.py>", line 1, in <module>
TypeError: range expected at least 1 argument, got 0
```

It is important to note that the `range()` function only accepts integers as arguments, not floats. Remember that floats are numbers with decimal points like `3.4`. If you try to pass floats as arguments, you'll get a `TypeError`:

```md
ERROR!
Traceback (most recent call last):
  File "<main.py>", line 1, in <module>
TypeError: 'float' object cannot be interpreted as an integer
```

If you want to generate a sequence of integers in decrementing order, then you can use a negative integer for the `step` argument, like this:

```py
for num in range(40, 0, -10):
    print(num)
```

The following code prints the numbers `40`, `30`, `20`, and `10` in that order to the console.

Another thing you can do with the `range()` function is create a list of integers by using it with the `list` constructor. The `list` constructor is used to convert an iterable into a list. Here is an example of generating a list of even integers between `2` and `10`:

```py
numbers = list(range(2, 11, 2))
print(numbers) # [2, 4, 6, 8, 10]
```

The `range()` function is a very handy way to generate a sequence of integers in Python. Once you get the hang of it, you'll probably find yourself using it a lot in your Python programs.


## What Are the Enumerate and Zip Functions and How Do They Work?

### Description

In previous lectures you learned how to work with the `for` loop, which is used to repeat a block of code a set number of times. Here is an example of using a `for` loop to print each language from the `languages` list to the console:

```py
languages = ['Spanish', 'English', 'Russian', 'Chinese']

for language in languages:
    print(language)
```

But what if you wanted to keep track of the index for each element? Well, one option is to create an `index` variable and increment it by `1` for each iteration of the loop, like this:

```py
languages = ['Spanish', 'English', 'Russian', 'Chinese']

index = 0

for language in languages:
    print(f'Index {index} and language {language}')
    index += 1
```

While that works, an easier way to do that is by using the `enumerate()` function. The `enumerate()` function keeps track of the index for an iterable and returns an enumerate object.

If we pass the `languages` list to the `enumerate()` function and convert its returned value into a list with the `list()` function, it looks like this:

```python
languages = ['Spanish', 'English', 'Russian', 'Chinese']

list(enumerate(languages))
# [(0, 'Spanish'), (1, 'English'), (2, 'Russian'), (3, 'Chinese')]
```

Each entry in the enumerate object (now a list) is a tuple containing a count, followed by a value from the iterable passed to the `enumerate()` function.

Now, let's refactor the example from earlier to use the `enumerate()` function:

```python
languages = ['Spanish', 'English', 'Russian', 'Chinese']

for index, language in enumerate(languages):
    print(f'Index {index} and language {language}')
```

We unpack the count and value for each tuple in the enumerate object into variables named `index` and `language`, respectively. Finally, both those variables are used in an f-string that's printed to the console in each iteration of the loop.

```md
Index 0 and language Spanish
Index 1 and language English
Index 2 and language Russian
Index 3 and language Chinese
```

This removes the need for manually creating and updating an `index` variable.

The `enumerate()` function also accepts an optional `start` argument that specifies the starting value for the count. If this argument is omitted, then the count will begin at `0`. Here is an example of using the optional `start` argument:

```python
languages = ['Spanish', 'English', 'Russian', 'Chinese']

for index, language in enumerate(languages, 1):
    print(f'Index {index} and language {language}')
```

And here is what the result will look like in the console:

```md
Index 1 and language Spanish
Index 2 and language English
Index 3 and language Russian
Index 4 and language Chinese
```

So far we've only been iterating over one list. But what if you need to iterate over multiple iterables in parallel? Well, you can use the `zip()` function for that, which combines lists into pairs of elements and returns an iterator of tuples.

If we pass a list of `developers` and `ids` to the `zip()` function and convert its returned value into a list with the `list()` function, here's what it looks like:

```python
developers = ['Naomi', 'Dario', 'Jessica', 'Tom']
ids = [1, 2, 3, 4]

list(zip(developers, ids))
# [('Naomi', 1), ('Dario', 2), ('Jessica', 3), ('Tom', 4)]
```

And here's an example of using the `zip()` function with a `for` loop to iterate over `developers` and `ids`:

```python
developers = ['Naomi', 'Dario', 'Jessica', 'Tom']
ids = [1, 2, 3, 4]

for name, id in zip(developers, ids):
    print(f'Name: {name}')
    print(f'ID: {id}')
```

In this example, `zip()` combines the two lists into pairs of elements and returns an iterator of tuples. The `for` loop then unpacks each tuple into `name` and `id`. Finally, for each print statement, we are printing each `name` and `id` from the `ids` and `developers` lists respectively. Here is what the result looks like in the console:

```md
Name: Naomi
ID: 1
Name: Dario
ID: 2
Name: Jessica
ID: 3
Name: Tom
ID: 4
```

The `enumerate()` and `zip()` functions are very powerful, and when combined with loops, can make your code much more concise.


## What Are List Comprehensions and What Are Some Useful Functions to Work With Lists?

### Description

For the past few lectures, you have been getting comfortable working with loops like this:

```py
even_numbers = []

for num in range(21):
    if num % 2 == 0:
        even_numbers.append(num)

print(even_numbers)
```

This example creates a new empty list called `even_numbers` and loops through a sequence of numbers between `0` and `20`. Inside the loop, there's a condition that checks if the current number has a remainder of `0` when divided by `2`. This is used to determine if the number is even. If the condition is `True`, then the current `num` is appended at the end of the `even_numbers` list. Finally, we print the `even_numbers` list to the console.

While this code works, there is a more concise way to write this that uses list comprehension instead. List comprehension allows you to create a new list in a single line by combining a loop and condition directly within square brackets. This makes the code shorter and often easier to read.

Here is the refactored example from earlier using square brackets:

```py
even_numbers = [num for num in range(21) if num % 2 == 0]
print(even_numbers)
```

In this refactored example, the `even_numbers` list is created using a single line of code. The list comprehension loops through numbers from `0` to `20`, and includes only those that are divisible by `2`. This approach is more compact and eliminates the need for a separate loop and conditional block.

Let's take a look at another example so we can better understand how list comprehension works:

```py
numbers = [1, 2, 3, 4, 5]
result = [(num, 'Even') if num % 2 == 0 else (num, 'Odd') for num in numbers]
print(result)
```

In this example, we have a list of numbers and want to create a new list of tuples indicating which numbers are even or odd. In the first part of the list comprehension, we use an `if` statement to check if the number is evenly divisible by `2`. If so, then the result is a tuple of that number followed by the word `Even`. Otherwise, the result is a tuple with the number followed by the word `Odd`.

Here is what the result looks like printed in the console:

```py
[(1, 'Odd'), (2, 'Even'), (3, 'Odd'), (4, 'Even'), (5, 'Odd')]
```

Another way to create a list starting from an existing iterable is the `filter()` function. Here is an example of creating a new list of just words longer than four characters:

```py
words = ['tree', 'sky', 'mountain', 'river', 'cloud', 'sun']

def is_long_word(word):
    return len(word) > 4

long_words = list(filter(is_long_word, words))
print(long_words) # ['mountain', 'river', 'cloud']
```

The `filter()` function is used to select elements from an iterable that meet a specific condition. The `filter()` function accepts a function and an iterable for its arguments. In this example, we are passing in an `is_long_word` function into the `filter()` function to check if the current word count is greater than `4`. All words that have a character count greater than `4` are added into a new list and assigned to the `long_words` variable.

Aside from the `filter()` function, there are a few more functions that are helpful when working with lists. Another function to be aware of is the `map()` function, which takes an iterable and applies a function to each of its elements. Here is an example of using the `map()` function to convert a list of temperatures from Celsius to Fahrenheit:

```py
celsius = [0, 10, 20, 30, 40]

def to_fahrenheit(temp):
    return (temp * 9/5) + 32

fahrenheit = list(map(to_fahrenheit, celsius))
print(fahrenheit) # [32.0, 50.0, 68.0, 86.0, 104.0]
```

Just like the `filter()` function, `map()` accepts a function and an iterable for its arguments. The `to_fahrenheit` function takes a temperature and converts it from Celsius to Fahrenheit.

The last function we will look at is the `sum()` function. This function is used to get the sum from an iterable like a list or tuple. Here is an example of using the `sum()` function:

```py
numbers = [5, 10, 15, 20]
total = sum(numbers)
print(total) # Result: 50
```

You can also pass in an optional `start` argument which sets the initial value for the summation. Here is an updated example using the `start` argument as a positional argument:

```py
numbers = [5, 10, 15, 20]
total = sum(numbers, 10) # positional argument
print(total) # 60
```

You can also choose to use the `start` argument as a keyword argument like this instead:

```py
numbers = [5, 10, 15, 20]
total = sum(numbers, start=10) # keyword argument
print(total) # 60
```

Both versions will produce the same result, but the keyword argument is a little more explicit.

List comprehension as well as other functions like `map()`, `filter()`, and `sum()` might seem a little confusing at first. But with enough practice and time, you will start to feel more comfortable using them in your Python programs.


## What Are Lambda Functions and How Do They Work?

### Description

Throughout the previous lectures, you have been used to defining functions by using the `def` keyword like this:

```py
def square(num):
    return num ** 2

print(square(4)) # 16
```

But when it comes to working with high order functions like `map()` and `filter()`, you can use an anonymous inline function. This is where lambda functions come in.

Here's what the `square()` function looks like when refactored into a lambda function:

```py
lambda num: num ** 2
```

As mentioned earlier, lambda functions are anonymous, so this function no longer has the name `square` associated with it. Lambda functions are great when you need to use them in higher order functions like this:

```py
numbers = [1, 2, 3, 4, 5]

even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(even_numbers)  # [2, 4]
```

In this example, we have a list of numbers and want to create a new list of even numbers. So we pass in a lambda function as one of the arguments to the `filter()` function to get a new list containing the numbers `2` and `4`.

When working with lambda functions it is important to be aware of best practices. For example, it is not a good practice to assign a lambda function to a variable like this:

```py
numbers = [1, 2, 3, 4, 5]

square = lambda x: x ** 2
squared_numbers = list(map(square, numbers))
print(squared_numbers) # [1, 4, 9, 16, 25]
```

This defeats the purpose of using anonymous functions. In this case, you should use a regular function, like this:

```py
numbers = [1, 2, 3, 4, 5]

def square(num):
    return num ** 2

squared_numbers = list(map(square, numbers))
print(squared_numbers) # [1, 4, 9, 16, 25]
```

Also, you should avoid creating lambda functions that are difficult to read or unnecessarily complicated, like this:

```py
result = (lambda x: (x**2 + 2*x - 1) if x > 0 else (x**3 - x + 4))(3)
print(result)  # 14
```

While this function runs fine and produces the correct result of `14`, it is not easy to read or look at. In this case, it would be better to create a separate function with an `if/else` statement, and then call that function:

```py
def calculate_expression(x):
    if x > 0:
        return x**2 + 2*x - 1
    else:
        return x**3 - x + 4

print(calculate_expression(3))  # 14
```

Both regular functions and lambda functions have their use cases in Python programs. If you are dealing with a single inline expressions, then you might consider using a lambda function. Otherwise, using a regular function would be the way to go.


## Module: Python Dictionaries And Sets


### Lecture Block: Lecture Working With Dictionaries And Sets


## What Are Dictionaries, and How Do They Work?

### Description

In Python, dictionaries are built-in data structures that store collections of key-value pairs. They work very similarly to real dictionaries, where you search for a word to find its corresponding meaning.

With Python dictionaries, you use a key to find its corresponding value. You should use dictionaries when you need to associate values to unique keys. This is helpful when you need to find a value fast based on the key, and when you need to represent structured data.

This is the general syntax of a Python dictionary:

```python
dictionary = {
    key1: value1,
    key2: value2
}
```

First, we find the variable that holds the dictionary. You don't necessarily need to assign the dictionary to a variable, but it's very common to do this to keep it in memory and use it later in the code.

Then that's followed by curly braces, which are sometimes called curly brackets. And within the curly braces, there are key-value pairs.

Each key is associated with a value, so you can use the key to access that value. After each value, except the last one, there's a comma to separate the different key-value pairs. Keys must be unique in the dictionary, and they must be an immutable data type. However, the values can be repeated, and they can be of any data type.

Here we have an example of a dictionary that stores information about a Margherita pizza recipe:

```python
pizza = {
    'name': 'Margherita Pizza',
    'price': 8.9,
    'calories_per_slice': 250,
    'toppings': ['mozzarella', 'basil']
}
```

The dictionary is assigned to the `pizza` variable. It has four key-value pairs: `name`, `price`, `calories_per_slice`, and `toppings`.

Another alternative would be using the `dict()` constructor, which builds the dictionary from a sequence of key-value pairs.

This would be the equivalent syntax for our pizza example. We pass a list of tuples as argument to the `dict()` constructor. These tuples contain the key as the first element and the value as the second element.

```python
pizza = dict([('name', 'Margherita Pizza'), ('price', 8.9), ('calories_per_slice', 250), ('toppings', ['mozzarella', 'basil'])])
```

To access the value of a key-value pair, you can use this syntax, known as bracket notation. It's the name of the variable that holds the dictionary, followed by square brackets, and the key you want to access within the square brackets:

```python
dictionary[key]
```

In our pizza example, if you want to access the value of `name`, you would write the name of the variable, `pizza`, followed by square brackets, and the key, `name`, within quotes:

```python
pizza['name']
```

This will evaluate to:

```python
'Margherita Pizza'
```

To update a value, you just need to add the assignment operator, followed by the new value.

If the key doesn't exist in the dictionary, a new key-value pair will be created. In recent versions of Python, dictionaries preserve the order of insertion. This is helpful when you need to iterate over the dictionary:

```python
pizza['name'] = 'Margherita'
```

Now the value of the key `name` is `'Margherita'`:

```python
print(pizza['name']) # 'Margherita'
```

Dictionaries also have helpful methods to perform common operations.

The `.get()` method retrieves the value associated with a key. It's similar to the bracket notation that we just used, but its advantage is that you can set a default value, so you won't get an error is the key doesn't exist:

```python
dictionary.get(key, default)
```

In this example, if the `toppings` key doesn't exist, it will return an empty list, which is the default value that we are passing here as the second argument. But if `toppings` does exist, it will return that value:

```python
pizza.get('toppings', []) # ['mozzarella', 'basil']
```

The `.keys()` and `.values()` methods return a view object with all the keys and values in the dictionary, respectively:

```python
pizza.keys()
# dict_keys(['name', 'price', 'calories_per_slice'])

pizza.values()
# dict_values(['Margherita Pizza', 8.9, 250])
```

A view object is just a way to see the content of a dictionary without creating a separate copy of the data.

The `.items()` method returns a view object with all the key-value pairs in the dictionary, including both the keys and the values:

```python
pizza.items()
# dict_items([('name', 'Margherita Pizza'), ('price', 8.9), ('calories_per_slice', 250)])
```

The `.clear()` method removes all the key-value pairs from the dictionary:

```python
pizza.clear()
```

The `.pop()` method removes the key-value pair with the key that you specify as the first argument and returns its value. If the key doesn't exist, it returns the default value that you specify as the second argument. If the key doesn't exist and you don't pass a default value, a `KeyError` is raised:

```python
pizza.pop('price', 10)
pizza.pop('total_price') # KeyError
```

In Python 3.7 and more recent versions, the `.popitem()` method removes the last inserted item:

```python
pizza.popitem()
```

And finally, the `.update()` method updates the key-value pairs with the key-value pairs of another dictionary. If they have keys in common, their values are overwritten.

In this example, we are updating the `pizza` dictionary. The `price` key exists in both of them, so its value will be replaced with `15`.

But `total_time` is new, so it will be added to the `pizza` dictionary as a new key-value pair:

```python
pizza.update({ 'price': 15, 'total_time': 25 })
```

This is the new dictionary with the updated `price` and the new `total_time`. Notice how the price is now `15` and `total_time` is a new key-value pair:

```python
{
    'name': 'Margherita Pizza', 
    'price': 15, 
    'calories_per_slice': 250, 
    'toppings': ['mozzarella', 'basil'], 
    'total_time': 25
}
```

These are some of the most commonly used dictionary methods, but there are many more. Choosing the right one can be helpful for performing complex operations efficiently.


## What Are Some Common Techniques to Loop Over a Dictionary?

### Description

You can loop over a dictionary if you need to access and process its key-value pairs. This is helpful for updating their values or applying some logic to them.

Let's take a look at some of the techniques you can use.

Let's say that we have a `products` dictionary that associates every product with its price:

```python
products = {
    'Laptop': 990,
    'Smartphone': 600,
    'Tablet': 250,
    'Headphones': 70,
}
```

If we want to offer a 20% discount on all our products, we can loop over all the key-value pairs and modify the prices.

The `.values()`, `.keys()`, and `.items()` methods are essential for these techniques. We covered them briefly in a previous lecture.

They return a view object with the values, keys, and key-value pairs of the dictionary. You can use these view objects in `for` loops to iterate over the elements.

For example, you can iterate over all the values of the dictionary like this.

You write `for`, the loop variable (`price` in this case), `products.values()` to get all the values of the `products` dictionary, a colon, and then the body of the loop, where you can apply any logic to the values. In this case, we are printing them.

The loop variable will take each one of the values, one per iteration:

```python
for price in products.values():
    print(price)
```

And here is the output. As you can see, each value is printed to the console, one by one:

```md
990
600
250
70
```

This works exactly the same for `.keys()` if you need to iterate over the keys of a dictionary. You just need to iterate over `products.keys()` or `products` directly, and assign a descriptive name for the loop variable:

```python
for product in products.keys():
    print(product)

for product in products:
    print(product)
```

This is the output. Each key is printed to the console, one at a time:

```md
Laptop
Smartphone
Tablet
Headphones
```

And this works exactly the same for key-value pairs if you need to iterate over the keys and their corresponding values simultaneously. You just need to iterate over `products.items()`:

```python
for product in products.items():
    print(product)
```

This is the output. Now you get individual tuples with the keys and their corresponding values:

```md
('Laptop', 990)
('Smartphone', 600)
('Tablet', 250)
('Headphones', 70)
```

If you want to store the key and the value in separate loop variables, you just need to define them and separate them with a comma. Then, you can use them in the body of the loop.

Here, we are defining a `product` loop variable and a `price` loop variable. Each one will hold its corresponding value. It's important to define them in order – the key first, and then the value:

```python
for product, price in products.items():
    print(product, price)
```

This is the output. We are printing them side by side, but you can use these values as you need them in your code.

```md
Laptop 990
Smartphone 600
Tablet 250
Headphones 70
```

Now that you know more about this, we can go back to our initial example. If we want to offer a 20% discount, we would multiply each price by `0.8` and reassign it as the value of that product key.

We could also round the result down if we want to work with integers:

```python
products = {
    'Laptop': 990,
    'Smartphone': 600,
    'Tablet': 250,
    'Headphones': 70,
}

for product, price in products.items():
    products[product] = round(price * 0.8)

print(products)
```

Then, if we print the dictionary, we would get these key-value pairs with the discounted prices:

```python
{
    'Laptop': 792, 
    'Smartphone': 480, 
    'Tablet': 200, 
    'Headphones': 56
}
```

And finally, if you need to iterate over the key-value pairs while keeping track of a counter, you can call the `enumerate()` function. This counter essentially acts as a sort of "index" or "count" for that element within the loop.

The function returns an `enumerate` object, which assigns an integer to each key-value pair, like a counter. You can start the counter from any number, but by default, it starts from 0.

Here, we are iterating over the keys of the `products` dictionary:

```python
for product in enumerate(products):
    print(product)
```

But the `enumerate()` function also assigns an integer to each key, so we get tuples with the integer and the key.

Here is the output:

```md
(0, 'Laptop')
(1, 'Smartphone')
(2, 'Tablet')
(3, 'Headphones')
```

If you need to, you can assign these values to separate loop variables. Here, we have two loop variables (`index` and `product`). This is what you will commonly see and use when you work with `enumerate()`:

```python
for index, product in enumerate(products):
    print(index, product)
```

If you need to iterate over the values, you can replace `products` by `products.values()`:

```python
for price in enumerate(products.values()):
    print(price)
```

The output will have the index and the price in each tuple:

```md
(0, 990)
(1, 600)
(2, 250)
(3, 70)
```

You can assign them to separate loop variables as well:

```python
for index, price in enumerate(products.values()):
    print(index, price)
```

This will be the output. You can use them as you need to in your code:

```md
0 990
1 600
2 250
3 70
```

And with `products.items()`, you can get the entire key-value pair in addition to the "index" or "counter":

```python
for index, product in enumerate(products.items()):
    print(index, product)
```

In this example, we get the index followed by a tuple that contains the key and the value of the corresponding key-value pair:

```md
0 ('Laptop', 990)
1 ('Smartphone', 600)
2 ('Tablet', 250)
3 ('Headphones', 70)
```

To customize the initial value of the count, you can pass a second argument to `enumerate()`. For example, here we are starting the count from 1:

```python
for index, product in enumerate(products.items(), 1):
    print(index, product)
```

You can see this change in the output. Now the first integer is 1 instead of 0:

```md
1 ('Laptop', 990)
2 ('Smartphone', 600)
3 ('Tablet', 250)
4 ('Headphones', 70)
```

This works with any variation we've seen so far. You just need to pass the initial number as the second argument.

There are many techniques to loop over a dictionary. These are some common ways, and you'll need to choose the best one for your project.


## What Are Sets, and How Do They Work?

### Description

Sets are one of Python's built-in data structures. One of the core characteristics of sets is that they don't store duplicate values. If you try to add a duplicate value to a set, only one of them will be stored.

Sets are mutable and unordered, which means that their elements are not stored in any specific order, so you cannot use indices or keys to access them. They can only contain values of immutable data types like numbers, strings, and tuples. And they support mathematical set operations, including union, intersection, difference, and symmetric difference.

To define a set, you just need to write its elements within curly braces and separate them with commas. This is an example of a set of numbers:

```python
my_set = {1, 2, 3, 4, 5} 
```

One quirk of working with sets is that, if you ever need to define an empty set, you must use the `set()` function. If you just write empty curly braces, like `{}`, Python will automatically create a dictionary.

```python
set() # Set
{}    # Dictionary
```

You can add an element to a set with the `.add()` method, and pass in the new element as argument:

```python
my_set.add(6)
```

In our example, the new set would be:

```python
{1, 2, 3, 4, 5, 6}
```

If you try to add an element that is already in the set, only one will be kept. In this case, we already have the number 5 in the set:

```python
my_set.add(5)
```

So the set will not change:

```python
{1, 2, 3, 4, 5, 6}
```

To remove an element from the set, you have two options. You can either use the `.remove()` method or the `.discard()` method, and pass in the element that you want to remove as argument.

The `.remove()` method will raise a `KeyError` if the element is not found, while the `.discard()` method will not:

```python
my_set.remove(4)
my_set.discard(4)
```

The `.clear()` method removes all the elements from the set:

```python
my_set.clear()
```

Python sets also have powerful methods that perform common mathematical set operations.

The `.issubset()` and the `.issuperset()` methods check if a set is a subset or superset of another set, respectively.

Here, we are checking if `your_set` is a subset of `my_set`, which is `False` because not all the elements of `your_set` are in `my_set`.

We are also checking if `my_set` is a superset of `your_set`. This is also `False` because `my_set` does not have all the elements of `your_set`:

```python
my_set = {1, 2, 3, 4, 5}
your_set = {2, 3, 4, 6}

print(your_set.issubset(my_set)) # False
print(my_set.issuperset(your_set)) # False
```

The `.isdisjoint()` method checks if two sets are disjoint, which means they don't have any elements in common. In this case, that's `False` because `my_set` and `your_set` do have common elements – 2, 3, and 4:

```python
print(my_set.isdisjoint(your_set)) # False
```

The union operator `|` returns a new set with all the elements from both sets:

```python
my_set | your_set # {1, 2, 3, 4, 5, 6}
```

The intersection operator `&` returns a new set with only the elements that the sets have in common:

```python
my_set & your_set # {2, 3, 4}
```

The difference operator `-` returns a new set with the elements of the first set that are not in the other sets. In this example, the numbers 1 and 5 are in `my_set` but NOT in `your_set`:

```python
my_set - your_set # {1, 5}
```

The symmetric difference operator `^` returns a new set with the elements that are either on the first or the second set, but not both. In this case, 1 and 5 are in `my_set` but not in `your_set`, so they are included. And the number 6 is in `your_set` but not in `my_set`, so it's included as well:

```python
my_set ^ your_set # {1, 5, 6}
```

Each one of these operators also has its corresponding compound assignment operator if you add the equal sign next to it. These operators automatically assign the resulting set to the first set in the expression:

```python
|= &= -= ^=
```

For example, the `-=` operator finds the difference between the sets and updates the first set with that result:

```python
my_set -= your_set
```

After this, `my_set` will be updated to `{1, 5}`:

```python
print(my_set) # {1, 5}
```

You can check if an element is in a set or not with the `in` operator. Here, we are checking if 5 is in `my_set`. The result will be a boolean value `True` or `False`:

```python
print(5 in my_set)
```

And those are the fundamentals of sets. They are very helpful when you don't need to store the values in any specific order, and when you only need to store unique values.


### Lecture Block: Lecture Working With Modules


## What Is the Python Standard Library, and How Do You Import a Module?

### Description

In software development, a library is like a toolbox for developers.

Instead of having to implement every single part of the code yourself from scratch, a library gives you pre-written and reusable code, like functions, classes, and data structures that you can use in your projects.

Python has an extensive standard library with many different built-in modules. They're all standardized, well-vetted solutions for many of the problems and tasks you'll face daily as a programmer, such as:

* Interacting with the operating system.
    
* Working with files.
    
* Networking.
    
* Working with date and time.
    
* Performing mathematical operations.
    
* Using regular expressions.
    
* Testing and debugging your code.
    
* And much more!
    

Some examples of popular built-in modules are `math`, `random`, `re` (short for "regular expressions"), and `datetime`.

The `math` module has helpful functions for performing more complex mathematical operations.

The `random` module is helpful for generating random numbers.

The `re` module is used for working with regular expressions.

And the `datetime` module is helpful for working with dates and times in Python.

But how can you access the variables, constants, functions, and classes defined in these built-in modules?

You use an import statement. These statements let you import modules into your Python script. Import statements are generally written at the top of the file. Also, you can customize them based on your needs. First, you use the `import` statement, followed by the name of the module:

```python
import module_name
```

Let's say that you want to import the `math` module. In that case, you would write this at the top of your file:

```python
import math
```

Then, if you need to call a method from that module in your Python script, you would use dot notation, with the name of the module followed by the name of the method:

```python
module_name.method_name() 
```

For example, to get the square root of 36, you would write `math` followed by a dot and then `sqrt`, an abbreviation of square root, and within parentheses, you would pass any necessary arguments. In this case, we only need to pass in the number we want the square root of:

```python
math.sqrt(36)
```

This is the most basic version of an import statement, but there are other alternatives.

If you need to import the module with a different name (also known as an "alias"), you can use this syntax, with `as` followed by the alias at the end of the import statement:

```python
import module_name as module_alias
```

This is often used to shorten long module names, or to avoid naming conflicts.

For example, to refer to the `math` module as `m` in your code, you can assign an alias to it, like this:

```python
import math as m 
```

Then, you can access the elements of the module using the alias:

```python
m.sqrt(36)
```

But sometimes you don't need to import everything from a module. Perhaps you only need one or two specific functions or classes. Python has exactly what you need in that case.

Now the import statement starts with `from`, followed by the name of the module, and then the `import` keyword followed by the name of the elements that you want to import:

```python
from module_name import name1, name2
```

Then, you can use these names without the module prefix in your Python script.

If you want to assign aliases to these names, you can do that by using the `as` keyword after each, followed by the alias you want to use:

```python
from module_name import name1 as alias1, name2 as alias2
```

Let's say that you only want to import the radians, sine, and cosine functions from the `math` module. You would write:

```python
from math import radians, sin, cos
```

Now you can call these functions directly in your code, without the `math` module as a prefix.

Here we have a more detailed example:

To find the sine and cosine of a specific angle initially expressed in degrees, we can call the `radians` function to convert it to radians, and then call the sine and cosine functions, passing the angle in radians:

```python
from math import radians, sin, cos

angle_degrees = 40
angle_radians = radians(angle_degrees)

sine_value = sin(angle_radians)
cos_value = cos(angle_radians)

print(sine_value) # 0.6427876096865393
print(cos_value)  # 0.766044443118978
```

Notice how we are calling the functions directly, without the name of the module as a prefix. This is because we imported the functions with this alternative syntax.

This is helpful, but it can result in naming conflicts if you already have functions or variables with the same name defined in the Python script itself. So that's something to keep in mind when choosing which type of import statement you want to use.

And finally, we find this import statement that ends with an asterisk. The asterisk is telling Python that you want to import everything in that module, but you want to import it so that you don't need to use the name of the module as a prefix:

```python
from module_name import *
```

For example, if you do this while importing the `math` module, you'll be able to call any function defined in that module without specifying the name of the module as a prefix. Here are some examples:

```python
from math import *
print(sqrt(36))  # 6.0
print(pow(5, 2)) # 25.0
print(exp(1))    # 2.718281828459045
```

However, this is generally discouraged because it can lead to namespace collisions, and make it harder to know where certain names are coming from.

Import statements work exactly the same for functions, classes, constants, variables, and any other elements defined in the module.

Here is an example of a constant from the `math` module, the number `pi`:

```python
import math
print(math.pi)
```

And here is an example of a class from the `datetime` module. We create a date object that represents July 15, 1959. Then, we assign that `date` object to a variable and access the day, month, and year individually using dot notation:

```python
import datetime
birthday = datetime.date(1959, 7, 15)
print(birthday.day)    # 15
print(birthday.month)  # 7
print(birthday.year)   # 1959
```

You can find more information about the content of the module in the official Python documentation for that module.

Great. Now that you know more about modules, you should also know about this very important idiom in Python scripts, because they are very closely related:

```python
if __name__ == '__main__': 
    # Code
```

`__name__` is a special built-in variable in Python.

When a Python file is executed directly, Python sets the value of this variable to the string `"__main__"`.

But if the Python file is imported as a module into another Python script, the value of the `__name__` variable is set to the name of that module (usually the filename without the `.py` extension).

This is why you'll often find this conditional in Python scripts. It contains the code that you want to run **only if** the Python script is running as the main program:

```python
if __name__ == '__main__': 
    # Code
```

But if the script is imported as a module, the code within that block doesn't run.

This is helpful because it allows Python scripts to have two purposes. They can be run directly to execute their main logic, or they can be imported into another module without executing their main logic.


## Module: Python Error Handling


### Lecture Block: Lecture Understanding Error Handling


## Step 1

### Description

Watch the video or read the transcript and answer the questions below.


## Module: Python Classes And Objects


### Lecture Block: Lecture Classes And Objects


## How Do Classes Work and How Do They Differ From Objects?

### Description

In Python, classes and objects work hand in hand to organize and manage data. You build a class to define shared behavior, then create objects that use those behaviors.

In other words, a class is like a blueprint or template you use to create objects with.

Let's look at what classes are, and how to use them to create objects.

To create a class, you use the `class` keyword followed by the name of the class and a colon. Then within the class, you can add an initializer, along with any attributes and methods.

Attributes are like variables within a class, and are used to store data. Methods are functions defined within a class, and are the actions objects created with a class can perform.

Here's the basic syntax of a class:

```python
class ClassName:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def sample_method(self):               
        print(self.name.upper())
```

* `class ClassName` is made up of the `class` keyword to create a class, followed by the name of the class, here called `ClassName`. It is common in Python to use the **PascalCase** convention when naming classes.
    
* `def __init__(self, name, age)` is the special method automatically called when a new object is created. It initializes the attributes of the objects that will be created with the class.
    
    In addition to that, the first parameter of `__init__` is always a reference to the specific object being created or used. By convention, this parameter is named `self`, but technically, you can use any name. `self` lets you access the object's own attributes and methods.
    
* `self.name = name` and `self.age = age` are the attributes the objects will have.
    
* `def sample_method(self):` is the method each object created can call.
    
* `print(self.name.upper())` is what the `sample_method` method will do, in this case, it prints the name in uppercase.
    

If that all sounds like a lot, don't worry. Let's take a look at a similar example of a `Dog` class, and how you can create objects from that:

```python
class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def bark(self):
        print(f"{self.name.upper()} says woof woof!")
```

With this `Dog` class, you can create an object. Here's the basic syntax for creating objects from a class:

```python
object_1 = ClassName(attribute_1, attribute_2)
object_2 = ClassName(attribute_1, attribute_2)
```

You can also call any of the methods defined in the class from each object:

```python
object_1.method_name()
object_2.method_name()
```

Now let's create two dogs by using the `Dog` class as the blueprint:

```python
class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def bark(self):
        print(f"{self.name.upper()} says woof woof! I'm {self.age} years old!")

dog_1 = Dog("Jack", 3)
dog_2 = Dog("Thatcher", 5)

# Call the bark method
dog_1.bark()  # JACK says woof woof! I'm 3 years old!
dog_2.bark()  # THATCHER says woof woof! I'm 5 years old!
```

As you can see, we create two dog objects using the `Dog` class. When initializing `dog_1`, the string `Jack` and the number `3` are passed, which sets the `name` and `age` attributes for that instance. And `dog_2` is initialized with the string `Thatcher` and number `5` as its `name` and `age`, respectively.

Then when you call the `.bark()` method on `dog_1` and `dog_2`, you can see how both outputs differ, and use the unique `name` and `age` attributes you passed in when creating each object.

In summary, the difference between a class and an object is that a class is the template or the blueprint, and an object is what is created using that template.

Also, a class defines what data and behavior the object should have, and an object holds the actual data and uses that behavior. You write a class once, and you can make many objects from it, each with different data.


## What Are Methods and Attributes, and How Do They Work?

### Description

In the last lecture, you learned about classes and how they act as blueprints for creating objects.

Here, we will dive deeper into attributes and methods.

Let's take a closer look at attributes first, then methods.

Attributes are variables that belong to an object, so they hold data. There are two kinds of attributes: instance attributes and class attributes.

Instance attributes are unique to each object created from a class, and you usually set them with the `__init__` method. Class attributes, on the other hand, belong to the class itself and are shared by all instances of that class.

To access an attribute, you use dot notation.

Here are examples of both instance and class attributes, and how to access them from objects:

```python
class Dog:
    species = "French Bulldog" # Class attribute

    def __init__(self, name):
        self.name = name # Instance attribute

print(Dog.species) # French Bulldog

dog1 = Dog("Jack")
print(dog1.name)    # Jack
print(dog1.species) # French Bulldog

dog2 = Dog("Tom")
print(dog2.name)    # Tom
print(dog2.species) # French Bulldog
```

Note that you can access class attributes directly from the class itself, but you need to create an object and pass it data first before you can access instance attributes.

Cars are another good example, since all cars have a model and color:

```python
class Car:
    def __init__(self, color, model):
        self.color = color
        self.model = model

car_1 = Car("red", "Toyota Corolla")
car_2 = Car("green", "Lamborghini Revuelto")

print(car_1.model) # Toyota Corolla
print(car_2.model) # Lamborghini Revuelto

print(car_1.color) # red
print(car_2.color) # green
```

Methods are functions defined inside a class. With them, any object defined from a class can perform actions that operate on or modify its own data. You also access a method with dot notation.

For example, dogs can bark. So we can have a `bark` method in the `Dog` class like you saw in a previous lecture:

```python
class Dog:
   species = "French Bulldog"

   def __init__(self, name):
     self.name = name

   def bark(self):
       return f"{self.name} says woof woof!"

jack = Dog("Jack")
jill = Dog("Jill")

print(jack.bark()) # Jack says woof woof!
print(jill.bark()) # Jill says woof woof!
```

A `Car` class can also have a `describe` method:

```python
class Car:
    def __init__(self, color, model):
        self.color = color  # Instance attribute
        self.model = model  # Instance attribute

    def describe(self):
        return f"This car is a {self.color} {self.model}"

car_1 = Car("red", "Toyota Corolla")
car_2 = Car("green", "Lamborghini Revuelto")

print(car_1.describe()) # This car is a red Toyota Corolla
print(car_2.describe()) # This car is a green Lamborghini Revuelto
```


## What Are Special Methods and What Are They Used For?

### Description

Special methods in Python, also known as "magic methods" or "dunder methods", are special Python methods that start and end with double underscores (`__`). The word "dunder" itself comes from double underscores (**d** for double, **under** for underscores).

You've probably used special methods already without knowing it. Every time you write something like `3 + 4`, Python quietly runs `3.__add__(4)` under the hood. That's a special method in action. So while you *can* call special methods directly, you rarely do. Something like `3 + 4` is much clearer and easier to read than calling `3.__add__(4)` yourself.

Apart from `__add__`, `__init__()` is another special method you'll see and use the most, as it's a class initializer. There are also others like `__len__()` and `__str__()`.

Think of special methods as the directors of the activities between a person programming and the Python language interpreter itself.

Remember, you don't need to call special methods directly. Instead, Python automatically calls them when certain actions happen. These operations include:

- **Arithmetic operations like addition, subtraction, multiplication, division, and others**. In addition, `__add__()` is called, `__sub__()` for subtraction, `__mul__()` for multiplication, and `__truediv__()` for division.
    
- **String operations like concatenation, repetition, formatting, and conversion to text**. `__add__()` is called for concatenation, `__mul__()` for repetition, `__format__()` for formatting, `__str__()` and `__repr__()` for text conversion, and so on.
    
- **Comparison operations like equality, less-than, greater-than, and others**. `__eq__()` is called for equality checks, `__lt__()` for less-than, `__gt__()` for greater-than, and so on.
    
- **Iteration operations like making an object iterable and advancing through items**. `__iter__()` is called to return an iterator and  `__next__()` to fetch the next item.
    

Normally, Python data types like strings and numbers already know how to add things, do concatenation, compare for equality, be used in loops, and others.

But when you create your own class, Python won't know how to handle things automatically.

This is where special methods come in — they let you customize Python's built-in behavior.

Let's say you want to get the number of pages in book objects created with the class below, or compare them and get a readable string of the objects. Here's what happens without special methods:

```python
class Book:
   def __init__(self, title, pages):
       self.title = title
       self.pages = pages

book1 = Book("Built Wealth Like a Boss", 420)
book2 = Book("Be Your Own Start", 420)

print(len(book1)) # TypeError: object of type 'Book' has no len()
print(str(book1)) # <__main__.Book object at 0x102ed2900>
print(book1 == book2) # False even though they have the same number of pages
```

In the example:

- `len(book1)` failed because Python doesn't know how to get the length of your book object without `__len__()`
    
- `str(book1)` printed something like `<__main__.Book object at 0x102ed2900>` because that's the default representation when you don't use `__str__()`
    
- `book1 == book2` resulted in `False` because Python just checks if both objects are the same in memory, not by content.
    

Here's how you can define your own `__len__()`, `__str__()`, and `__eq__()` special methods to make working with objects created from the `Book` class easier:

```python
class Book:
   def __init__(self, title, pages):
       self.title = title
       self.pages = pages

   def __len__(self):
       return self.pages

   def __str__(self):
       return f"'{self.title}' has {self.pages} pages"

   def __eq__(self, other):
       return self.pages == other.pages
  
book1 = Book("Built Wealth Like a Boss", 420)
book2 = Book("Be Your Own Start", 420)

print(len(book1)) # 420
print(len(book2)) # 420
print(str(book1)) # 'Built Wealth Like a Boss' has 420 pages
print(str(book2)) # 'Be Your Own Start' has 420 pages
print(book1 == book2) # True
```

Another example is a shopping cart where you do the following:

- Add items to the cart
    
- Remove items from the cart
    
- Get the number of items in the cart
    
- Check what items are in the cart
    
- Check if a specific item is in the cart
    
- Return or display an item at a specific index in the cart
    

While you might have a method that adds items to the cart and removes certain items from the cart, you can create special methods for all the other functionality:

- `__len__()` to get the length of the items in the cart
    
- `__iter__()` to loop through the items in the cart so you can see them
    
- `__contains__()` to check if a specific item is in the cart
    
- `__getitem__()` to return or display an item at a specific index in the cart
    

Here's an example of a `Cart` class with these user-defined methods and special methods:

```python
class Cart:
   def __init__(self):
       self.items = []

   def add(self, item):
       self.items.append(item)

   def remove(self, item):
       if item in self.items:
           self.items.remove(item)
       else:
           print(f'{item} is not in cart')

   def list_items(self):
       return self.items

   def __len__(self):
       return len(self.items)

   def __getitem__(self, index):
       return self.items[index]

   def __contains__(self, item):
       return item in self.items

   def __iter__(self):
       return iter(self.items)
```

And here's how you can use them:

```python
cart = Cart()
cart.add('Laptop')
cart.add('Wireless mouse')
cart.add('Ergo keyboard')
cart.add('Monitor')

for item in cart:
   print(item, end=' ') # Laptop Wireless mouse Ergo keyboard Monitor

print(len(cart)) # 4
print(cart[3]) # Monitor

print('Monitor' in cart) # True
print('banana' in cart) # False

cart.remove('Ergo keyboard')

print(cart.list_items()) # ['Laptop', 'Wireless mouse', 'Monitor']

cart.remove('banana') # banana is not in cart
```

And those are a few ways you'll use special methods in Python in the real-world.


## Module: Python Object Oriented Programming


### Lecture Block: Lecture Understanding Object Oriented Programming And Encapsulation


## Step 1

### Description

Watch the video or read the transcript and answer the questions below.


### Lecture Block: Lecture Understanding Inheritance And Polymorphism


## Step 1

### Description

Watch the video or read the transcript and answer the questions below.


### Lecture Block: Lecture Understanding Abstraction


## Step 1

### Description

Watch the video or read the transcript and answer the questions below.


## Module: Python Linear Data Structures


### Lecture Block: Lecture Working With Common Data Structures


## What Is an Algorithm and How Does Big O Notation Work?

### Description

Every computer program that runs on your device has a specific set of instructions, which are executed in a specific order to complete a task.

The task could be sorting a set of numbers, modifying an image, tracking inventory, or even running your favorite video game.

This is where algorithms come into play. An **algorithm** is a set of unambiguous instructions for solving a problem or carrying out a task.

You can think of algorithms as "recipes". When you cook, recipes list all the ingredients that you'll need, and provide step by step instructions on how to prepare a dish.

Equivalently, you can think of algorithms as "recipes" that tell computers exactly what should be done and how to do it.

Algorithms have two key characteristics:

* They cannot continue indefinitely. They must finish in a finite number of steps.
    
* Each step must be precise and unambiguous.
    

They may have zero, one, or more inputs, and generate one or more outputs.

The steps of an algorithm are independent from any programming language.

But to actually make them run on a computer, you need to implement them in a programming language, like Python or JavaScript.

If an algorithm is correct, the output for any valid input should match the expected output.

In addition to being correct, algorithms should also be efficient.

Algorithm efficiency can be measured in terms of how long they take to run and how much space they require in memory to complete the task.

Knowing an algorithm's efficiency is very important because it gives you an idea of how well it will perform as the input size grows.

For example, sorting 15 integers is not the same as sorting 1 million integers.

As the process grows in size and complexity, if the algorithm is not efficient enough to handle it, you might end up with a very slow computer program that may even crash the entire system.

That's why it's very important to develop and choose the most efficient algorithms possible.

This is where Big O notation becomes very important.

Big O notation describes the worst-case performance, or growth rate, of an algorithm as the input size increases.

The growth rate of an algorithm refers to how the resources it requires increase as the input size grows.

Big O notation focuses on the worst-case performance because this case is very important to understand how efficient the algorithm can be, even in the worst case scenario, regardless of the input.

Going back to our sorting example, sorting 1 million integers should intuitively take more time and resources than sorting 15 integers.

But how much more?

This really depends on the algorithm that you choose to sort them.

Big O notation will not give you an exact number to describe the algorithm's efficiency, but it will give you an idea of how it scales as the input size grows, based on the number of operations performed by the algorithm.

In Big O notation, we usually denote input size with the letter `n`. For example, if the input is a list, `n` would denote the number of elements in that list.

Constant factors and lower-order terms are not taken into account to find the time complexity of an algorithm based on the number of operations. That's because as the size of `n` grows, the impact of these smaller terms in the total number of operations performed will become smaller and smaller.

The term that will dominate the overall behavior of the algorithm will the term with `n`, the input size.

For example, if an algorithm performs `7n + 20` operations to be completed, the impact of the constant `20` on the final result will be smaller and smaller as `n` grows. The term `7n` will tend to dominate and this will define the overall behavior and efficiency of the algorithm.

Another example would be an algorithm that takes `20n² + 15n + 7` operations to be completed. The term `20n²` will tend to dominate as `n` grows, so this algorithm would have a quadratic time complexity because the dominant term has `n²`.

Quadratic time complexity is one of many different types of time complexities that you can find in the world of algorithms.

Let's learn about some of the most common ones.

**`O(1)`** is known as "Constant Time Complexity". When an algorithm has constant time complexity, it takes the same amount of time to run, regardless of input size.

For example, checking if a number is even or odd will always take the same amount of time, regardless of the number itself.

```python
def check_even_or_odd(number):
    if number % 2 == 0:
        return 'Even'
    else:
        return 'Odd'
```

**`O(log n)`** is known as "Logarithmic Time Complexity". This means that the time required by the algorithm increases slowly as the input size grows. This is common in problems in which the size of the problem is repeatedly reduced by a constant fraction.

For example, a popular search algorithm called Binary Search has `O(log n)` worst-case time complexity. This is because it eliminates half of the remaining elements in each comparison, which makes it more efficient overall.

**`O(n)`** is known as "Linear Time Complexity". The running time of algorithms with this time complexity increases proportionally to the input size.

For example, a `for` loop that iterates over all the elements of a list will perform more iterations as the number of list elements increases. If the list is doubled in size, the number of operations will approximately double as well.

```python
for grade in grades:  # grades is a list.
    print(grade)
```

**`O(n log n)`** is known as "Log-Linear Time Complexity". This is a common time complexity of efficient sorting algorithms, like Merge Sort and Quick Sort.

**`O(n²)`** is known as "Quadratic Time Complexity". The running time of these algorithms increases quadratically relative to the input size, which is generally not efficient for real-world problems.

Nested loops are a common example of quadratic time complexity. The inner loop will perform `n` iterations for each one of the `n` iterations of the outer loop, resulting in `n` squared iterations.

```python
for i in range(n):
    for j in range(n):
        print("Hello, World!")
```

Other time complexities include "Exponential Time Complexity", denoted as `O(2^n)`, and "Factorial Time Complexity", denoted as `O(n!)`. Both are inefficient for real-world scenarios.

In this graph, you can compare the growth of the mathematical functions that represent the most common time complexities. Think of the x-axis (horizontal) as the input size and the y-axis (vertical) as the running time of the algorithm.

You can see that the Quadratic Time Complexity (`O(n²)`) (yellow) grows much faster than the other ones, while the Constant Time Complexity (`O(1)`) (red) stays constant, even if the input gets larger.

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/what-is-an-algorithm-and-how-does-big-o-notation-work-1.png" alt="graph comparing time complexity">

Great. So far, you've learned about Big O notation in terms of time requirements, but this notation can also be applied to the context of space requirements.

In this context, it describes how the memory space required by the algorithm grows as the input size grows.

Algorithms with "Constant Space Complexity" `O(1)` always require a constant amount of memory space, even as the input gets larger.

An example would be an algorithm that only creates and stores a few variables in memory.

In contrast, the space required by algorithms with "Linear Space Complexity" `O(n)` increases proportionally as the input size grows.

An example of this would be an algorithm that creates and stores a copy of a list of length `n`.

And finally, the space requirements of an algorithm with "Quadratic Space Complexity" `O(n²)` increase quadratically as the input size grows.

An example of this would be creating a 2D matrix, where the dimensions are determined by the input size, storing all possible pairs.

Algorithms are the building-blocks of computer programs, while Big O notation is a powerful framework for analyzing how efficient they are, based on how their time and space requirements in the worst-case scenario scale as the input size grows. Understanding their efficiency is very important for developing software that works efficiently in real-world scenarios.


## What Are Good Problem-Solving Techniques and Ways to Approach Algorithmic Challenges?

### Description

During your learning journey, you should work on developing strong problem-solving skills. These core skills will be essential for tackling real-world problems in your daily work.

Solving algorithmic challenges is a great way to practice. It requires an analytical way of thinking, being able to break the problem down into its core components, and finding a solution that generates the right output efficiently.

But where do you start?

There are several problem-solving techniques that you can use to start approaching these challenges.

As an example, we'll reverse a string in Python.

This is the challenge:

"Given a string, write an algorithm that returns a new string with the characters in reverse order."

The first thing that you should do when you come across this type of problem is to read the description multiple times to make sure that you understand what it says. You may miss critical information if you skip this step or read it too fast.

Then, once you are familiar with the problem, start breaking it down into its core components.

Ask yourself:

* "What is the input?"
    
* "What is the expected output?"
    
* "How can I transform the input into the expected output?"
    

In this problem, you can determine that the input is a string because the challenge starts with "Given a string…"

The output is "a new string with the characters in reverse order."

So you need to take the original string and reverse it.

This initial analysis might seem a bit repetitive at first, but it's very helpful to make sure that you fully understand the requirements.

Then, you should start thinking about how the algorithm that you will develop will transform the input into the output.

During this planning and analysis phase, it's common to use pseudocode to map out the necessary steps.

**Pseudocode** is a high-level description of the algorithm's logic that is general in nature, and is not based on any specific programming language.

Pseudocode is not as formal as actual code, since it's only intended for humans to read. It should be easy to understand at a glance. Its main purpose is to give a clear idea of the sequence of steps that will be performed.

Pseudocode is usually a mixture of a common written language, like English, with programming constructs, like `IF`, `ELSE`, `FOR`, and `WHILE`.

This is an example of pseudocode that you may write to solve the "Reverse a String" challenge.

```md
GET original_string

SET reversed_string = ""

FOR EACH character IN original_string:
  ADD character TO THE BEGINNING OF reversed_string

DISPLAY reversed_string
```

Note how the steps are outlined in a way that is easy to understand. The words and constructs themselves might vary depending on the standards that you are following.

If you wanted to, you could implement these steps in multiple programming languages following the same logic, since the pseudocode is independent of the programming language.

By this point, you may have already realized that this problem can be solved in many different ways. This isn't the only way to reverse a string.

But remember that choosing the right algorithm is important.

In a previous lecture, you learned about algorithmic complexity and why it is important to choose algorithms that are efficient in terms of time and space.

That's where you will play a vital role as a developer. You will need to choose the most efficient algorithm to solve the challenge.

Thinking through different available algorithms is an important problem-solving skill that you should practice. Take a moment to ask yourself if the solution that you are proposing in your pseudocode is the best one or not.

For example, there are many different algorithms for sorting elements, but some of them are more efficient than others. Bubble sort, for example, is very inefficient for sorting large lists, while Quick Sort is usually more efficient.

For our "Reverse a String" challenge, we could use either one of these approaches, assuming that we are planning to implement our algorithm in Python:

* Using the extended slice syntax `[::-1]` to get a new reversed string.
    
* Looping over the characters from left to right and adding the new character to the beginning of the new string.
    
* Calling the `reversed()` function to get an iterator with all the characters in reverse order, and then the `““.join()` method to concatenate them back into a string.
    

Which one should you use? That's your choice.

Making these decisions based on your knowledge and experience can make a huge difference in the final performance of your application. Consider different approaches, their efficiency, implications, and implementation.

Ask yourself:

* "How will I approach this problem?"
    
* "What data structures will I use?"
    
* "Are the data structures that I chose the most efficient ones for the problem at hand?"
    
* "Am I covering all possible edge cases?"
    

Edge cases are specific, valid inputs or conditions that occur at the boundaries of what an algorithm should handle.

For example, in the "Reverse a String" challenge, an edge case would be taking an empty string as input. Are you handling this correctly? If not, consider the best way to handle this edge case and add it to your pseudocode.

Then, once you are happy with your plan, you can move on to the implementation phase. At this phase, you will implement your algorithm in a programming language.

When structuring your program, you should write modular code that is easy to read and understand.

Use the tools of the programming language based on your current knowledge. Some programming languages include built-in solutions for common problems and tasks. Use them if possible.

To be consistent, follow the best practices of the programming language of your choice.

Test your code as you write it and make sure that you are handling edge cases appropriately.

Once your solution is implemented, check if it works correctly for all the examples and potentially refactor your code to make it clearer or simpler.

Going back to your solution is very important. Development is not necessarily a linear, step-by-step process. You can always go back to your code and use your critical thinking skills to improve it.

These are some common problem-solving techniques that you can follow to approach algorithmic challenges. If you practice consistently, you will gradually develop your problem-solving skills.


## How Do Dynamic Arrays Differ From Static Arrays?

### Description

Arrays are a fundamental data structure in computer science. All arrays store ordered collections of data, but depending on their type, they may work differently behind the scenes.

Their underlying behavior can have an important effect in the program's efficiency, so let's learn about dynamic and static arrays and their differences, so you can choose the most efficient one for your program.

We'll start with static arrays.

**Static arrays** have a fixed size. They store elements in adjacent memory locations.

The size of a static array is determined when the array is initialized. Once that specific block of memory is allocated, it's fixed, and cannot be changed while the program is running. This is a key characteristic of static arrays.

Storing elements in adjacent memory locations makes the data retrieval process more efficient because the program can store the location of the first element and then use indices to make simple calculations and find the other elements in memory.

Thanks to this, accessing the values of a static array takes constant time `O(1)`, which is very efficient.

You can use a static array when you know the number of elements that will be stored in advance. It's also helpful when the values will be accessed very frequently, since the access operation is very efficient.

However, this data structure cannot grow or shrink, so if the number of elements that will be stored can vary, you should use a dynamic array instead.

Trying to increase the size of a static array would involve creating a new array and copying all the elements from the old array to a new one, which is inefficient. In that case, a dynamic array would be much better because it handles this process automatically.

Python does not include traditional static arrays as built-in data structures.

But other programming languages, like Java, do support them. This is an example of a static array in Java that can store three integers:

```java
int[] numbers = new int[3]; 
```

Arrays in Python are dynamic, so let's take a look at those.

**Dynamic arrays** are more flexible because they can grow or shrink automatically while the program is running.

They work through an automatic resizing mechanism that copies the elements into a new array when the original array is full. The process is done efficiently because the size of the new array is chosen in an efficient way that makes these computationally expensive operations less frequent.

Accessing the elements of a dynamic array takes constant time `O(1)`, so this operation is very efficient.

Inserting an element in the middle of the array takes linear time `O(n)` because the elements after it need to be relocated.

Inserting an element at the end of the array takes constant time `O(1)` if there is still space available in the dynamic array, but if the array is full and needs resizing, this operation has a `O(n)` complexity.

You should use dynamic arrays when you don't know in advance the number of values that you will need to store in the array. They are also helpful when you will be frequently inserting and deleting elements.

Python's built-in `list` data structure works as a dynamic array. You can create a list by writing the elements within square brackets, separated by commas.

```python
numbers = [3, 4, 5, 6]
```

You can access an element by writing the name of the variable that holds the list, followed by square brackets, and within the square brackets, the corresponding index.

Indices start from 0 for the first element and are incremented by 1 for each subsequent element:

```python
numbers[0]  # 3
numbers[1]  # 4
numbers[2]  # 5
numbers[3]  # 6
```

To update a value, you just need to reassign it:

```python
numbers[2] = 16
```

You can append elements to the list with the `.append()` method:

```python
numbers.append(7)
```

You can insert elements at a specific index with the `.insert()` method, passing the index as the first argument and the element itself as the second argument.

```python
numbers.insert(3, 15)
```

You can remove an element at a specific index with the `.pop()` method:

```python
numbers.pop(2)
```

If you don't specify the index, `.pop()` will remove the last element.

There are other built-in list methods that you can check in the documentation for adding and removing elements quite easily.

That's the power of dynamic arrays, or lists in this case.

In general, you should use static arrays when you know the number of elements in advance and you need to access them frequently, and use dynamic arrays when the number of elements is unknown or variable over time.

You should always consider the tradeoff between the simplicity of static arrays and the flexibility of dynamic arrays. They are both helpful for specific use cases and scenarios. Being able to choose the best one for a given problem is part of the problem-solving skills that you will gradually develop with practice.


## How Do Stacks and Queues Work?

### Description

Stacks and queues are data structures commonly used in computer science.

They're linear data structures that follow specific rules for adding and removing elements.

## Stacks

Let's start with **Stacks**.

A **stack** is a Last-in, First-out (LIFO) data structure.

This means that the last element that was added to the stack is the first one to be removed.

Stacks have two ends, which we know as top and bottom.

Elements are added and removed from the top of the stack.

You can think of a stack as a pile of dishes, where you can only place dishes at the top of the pile and take dishes from the top of the pile.

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-stacks-and-queues-work-1.png" alt="stack data structure visualization">

These operations of adding and removing elements have special names in this context.

Adding an element to a stack is known as a "push" operation. We say that we "push" an element onto the stack when we add it to the top of the stack.

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-stacks-and-queues-work-2.png" alt="stack push operation visualization">

Removing an element from a stack is known as a "pop" operation. We say that we "pop" an element from the stack when we remove it from the top of the stack.

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-stacks-and-queues-work-3.png" alt="stack pop operation visualization">

You can see that we don't really perform any operations at the bottom of the stack but we keep it there as a reference.

The time complexity of the push and pop operations is typically `O(1)`, a constant time complexity.

When you push an element onto the stack, the element is simply added to the top.

When you pop an element form the stack, the element at the top is removed.

Therefore, the time it takes to perform these operations remains constant regardless of the size of the stack.

The space complexity of the push and pop operations is usually constant `O(1)`. This means that the amount of memory required to perform these operations remains constant regardless of the size of the stack.

## Queues

Now that you know more about stacks, let's learn about **Queues**.

A queue is a First-in First-out (FIFO) linear data structure. This means that the first element added to the queue is the first one to be removed.

Queues have two ends: front and back.

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-stacks-and-queues-work-4.webp" alt="queue data structure visualization">

Elements are added to the back of the queue and they are removed from the front of the queue.

You can think of a queue as a line of people waiting to pay for their groceries at the supermarket. The first person in line is the first one to go to the cash register while new people join the line at the end.

The operations of adding and removing elements have special names in the context of a queue.

Adding an element to the back of a queue is known as an "enqueue" operation.

In an enqueue operation, the new element is added to the end of the queue, becoming the end of the line.

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-stacks-and-queues-work-5.png" alt="queue enqueue operation visualization">

Removing an element from the front of the queue is known as a "dequeue" operation.  
  
In the dequeue operation, the element at the front of the queue is removed, and the next element in line becomes the new front.

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-stacks-and-queues-work-6.png" alt="queue dequeue operation visualization">

The time complexity of the enqueue and dequeue operations is `O(1)`, constant time. The time it takes to perform these operations remains constant, regardless of the size of the queue.

The space complexity of the enqueue and dequeue operations is usually constant `O(1)`. This means that the amount of memory required to perform these operations remains constant regardless of the size of the queue.

Stacks and queues are data structures used in computer science for organizing and managing elements. Understanding them is essential for building efficient algorithms in various programming applications.


## How Do Singly Linked Lists Work and How Do They Differ From Doubly Linked List?

### Description

A **linked list** is a linear data structure in which each node is connected to the next node in the sequence.

These connections create a data structure that looks like a chain of nodes, where each node stores data and a reference to the next node in the linked list.

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-1.png" alt="linked list basic structure visualization">

We use these references to go from the first node to the next node and so on.

Linked lists are commonly used for implementing other data structures, such as stacks, queues, and deques. They can also be used to implement essential graph algorithms, such as depth-first search and breadth-first search.

## Singly Linked Lists

A **singly linked list** is a type of linked list in which each node is connected to the next node in the sequence.

Each node is connected to the next one by storing a reference to it.

This single reference per node allows you to traverse the linked list in one direction, from start to end.

The search can only move forward, not backwards.

In this example, you would start at the head node, node A.

The **head** node is the first node in the linked list.

In a singly linked list, the head node is usually the only node that is directly accessible. This is where the search process will start when you're trying to find a specific node.

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-2.webp" alt="singly linked list traversal visualization">

The process will start at node A, then it will continue to node B, then node C, and finally node D, the **tail** node. It may also stop before that if you implement specific logic in your code.

The **tail** node is the last node. It's used to determine when the process has reached the end of the linked list.

### **Inserting Nodes**

One of the great things about linked lists is that they do not have a fixed size. They can be expanded or shrunk as needed by simply updating the connections between the nodes.

You can **insert** a node at the start, middle, and end of a linked list.

Linked lists don't necessarily need to store the nodes in a specific order. The order will be determined by the connections between the nodes.

However, if you do need to keep the nodes in a specific order for your particular use case, you can do so by implementing that logic in your code and the criteria you implement will determine if the node is inserted at the start, middle, or end.

To insert a node at the start of the linked list, you just need to create a connection between the new node and the node that used to be the head node and make the new node the head node instead.

This is an example, where we insert node E at the start and make this new node the head node of the linked list.

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-3.png" alt="singly linked list insert at beginning visualization">

Inserting a node at the beginning of the linked list has a constant time complexity `O(1)` because it only requires updating the reference to the head node and the connection between the new head node and the next node in the sequence.

In this example, we are inserting node E at the start of the linked list. This will work correctly. But if we wanted to keep the linked list sorted in alphabetical order, node E would have to be inserted at the end of the linked list instead.

To insert a node at the end of the linked list, first you need to reach the end and then add a connection to the new node to make it the new tail node.

This operation has linear time complexity, `O(n)`, where n is the number of nodes stored in the linked list, because first you need to reach the end of the linked list to make the insertion and this would require going from one node to the next and so on until the end is reached.

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-4.png" alt="singly linked list insert at end visualization">

If the node has to be inserted somewhere in the middle of the linked list, the connections between the nodes will have to be updated too. The previous node in the sequence should be connected to the new node and the new node should be connected to the next node, like in the following diagram.

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-5.webp" alt="singly linked list insert in middle visualization">

The insertion operation has a constant space complexity `O(1)`, since inserting a new node only requires creating it and updating the connections between the nodes. This operation doesn't depend on the size of the linked list itself.

### **Removing Nodes**

Just as you can insert nodes, you can also remove them from the start, middle, and end of the linked list.

To remove a node from the start, you need to update the reference to the head node, which should be the next node in the sequence.

This operation has a constant time complexity `O(1)`, because it only requires updating the linked list's reference to the head node.

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-6.png" alt="singly linked list remove from beginning visualization">

To remove a node from the middle of the linked list, you need to update the reference of the previous node to connect it to the next node in the sequence, forming a sort of "bridge" between them, as you can see in this diagram.

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-7.png" alt="singly linked list remove from middle visualization">

That will remove the node that you want to remove, in this case node B, from the sequence of connections, so it won't be reached the next time you traverse it.

To remove a node from the end of the linked list, you need to remove the connection of the previous node and make this node the new tail node. Now the linked list will end at the new tail node.

This operation has a linear time complexity `O(n)`, because first you have to reach the end of the linked list.

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-8.png" alt="singly linked list remove from end visualization">

The deletion operation has a constant space complexity `O(1)`, because no additional memory is required to delete a node.

## Doubly Linked Lists

Now that you know more about singly linked lists, let's talk about doubly linked lists.

In a **doubly linked list**, each node stores two references: a reference to the next node and a reference to the previous node in the sequence.

This means that doubly linked lists can be traversed in both directions.

<img src="https://cdn.freecodecamp.org/curriculum/lecture-transcripts/how-do-singly-linked-lists-work-and-how-do-they-differ-from-doubly-linked-list-9.webp" alt="doubly linked list structure visualization">

In this type of linked list, it's also common to keep a reference to the tail node in the linked list itself to start the traversal from the end if necessary.

That sounds great, right? They're more flexible than singly linked lists.

However, doubly linked lists do require more memory than singly linked lists because each node stores **two** references instead of one.

This is something that you should keep in mind when you're choosing the right data structure for your project.

There **is** a tradeoff.

The insertion and deletion operations work exactly the same. The only difference is that now you will need to update two references per node and keep track of the reference to the tail node to insert elements at the end of the doubly linked list very efficiently and start the traversal process from the back, if necessary.

Singly and doubly linked lists are essential data structures in computer science used for storing and manipulating elements in a sequential order. Understanding their differences is essential for choosing the right one for your specific application.


## How Do Maps, Hash Maps and Sets Work?

### Description

In this lecture, we'll go over maps, hash maps, and sets. But before we do that, let's define Abstract Data Types.

An Abstract Data Type (ADT) is a conceptual representation of a data type, including what operations can be performed on the data and the properties of that data.

Abstract Data Types are like blueprints that describe **what** operations can be performed, not **how** they are performed. They separate the interface from the actual implementation of the operations.

A **map** is an ADT that manages collections of key-value pairs and their operations in a very specific and efficient way.

In a map, every value is associated with a specific key.

One of the key characteristics of maps is that every key must be unique. This uniqueness allows for direct lookups, which makes the process of retrieving information much more efficient.

Only keys must be unique, values can be repeated.

The map Abstract Data Type also defines important operations, such as inserting key-value pairs, getting the value associated with a key, updating the value associated with a key, removing a key-value pair, and checking if a key exists in the map.

It doesn't actually specify how these operations should be performed, it just lists them as part of the available operations of the data type.

A **hash map**, also known as a hash table, is a concrete implementation of the map Abstract Data Type.

Hash maps use a technique called "hashing" to perform common operations very efficiently.

Hashing essentially works by generating a hash value for each element using a hash function.

The hash value is generated based on the key of the key-value pair and it's used to calculate an index in an underlying array, the actual data structure where the key-value pairs are stored.

But you might be asking yourself: What happens if two keys result in the same index?

Hash maps solve these collisions with clever strategies.

One option is to use the "chaining" strategy, where each array index points to a linked list (another data structure), where all the elements with the same index are stored.

Another strategy is to use "open addressing", which involves searching for the next available index in the array based on a predefined search sequence.

The average case time complexity of hash maps is "Constant Time" `O(1)` for inserting, retrieving, and deleting key-value pairs.

The worst case time complexity of these operations is Linear Time `O(n)`, which occurs when there are many hash collisions, so the collision resolution strategy has to be applied multiple times.

The space complexity of inserting into a hash map is constant `O(1)` on the average case, a constant amount of memory to store the new pair. However, in the worst case, it can have linear space complexity `O(n)` due to a resizing operation of the underlying array. In general, removing an element has a constant space complexity `O(1)`.

This turns the hash table into something similar to a linear data structure where `n` elements have to be scanned to find the target key. However, this is relatively rare if the hash map is implemented properly.

Python's **dictionaries** are implemented as hash maps behind the scenes.

To create a Python dictionary, you just need to write the key-value pairs within curly brackets and separate them with a comma. Each key should be separated from its corresponding value with a colon.

```python
my_dictionary = {
  "A": 1,
  "B": 2, 
  "C": 3
}
```

In this code, `"A"` is the key and `1` is the value:

```python
"A": 1
```

Alternatively, you can use `dict()`:

```python
my_dictionary = dict(A="1", B="2", C="3")
```

You can get the value through its corresponding key:

```python
my_dictionary["A"]  # 1
```

You can also update the value associated with a key:

```python
my_dictionary["A"] = 4
```

And you can remove a key-value pair:

```python
del my_dictionary["A"]  
```

You can also check if a key is in the dictionary (or not):

```python
"C" in my_dictionary
```

And you can call these methods to get the keys, values, and items of the dictionary, respectively.

```python
my_dictionary.keys()
my_dictionary.values()
my_dictionary.items()
```

Great. Now that you know more about maps and hash maps, let's talk about sets.

**Sets** are unordered collections of unique elements.

Let's break this concept down into its key components:

* Sets are unordered. The elements of a set are not stored in any specific order, so you cannot access them through indices.
    
* Sets only contain unique elements. If you try to add the same value twice, only one copy of the value will be kept.
    

They are analogous to sets in mathematics and they implement the same set operations, like intersection, union, and difference.

One of the main advantages of sets is that they guarantee that the elements will be unique (no duplicates). This is why they are often used to remove duplicates from lists and other data structures.

They are also dynamic. They can adjust to the number of elements that are currently stored. This makes them quite powerful.

The average case time complexity of adding, removing, getting the length of the set, and checking if an element is in the set is "Constant Time" `O(1)`, which is very efficient.

Since sets are implemented as hash tables, the worst case time complexity of adding, removing, and checking membership is "Linear Time" `O(n)`. This may occur when there are multiple hash collisions, transforming the hash table into something similar to a linear data structure, where `n` scans are required to find the key.

In terms of space complexity, in the average case, inserting an element would have constant complexity `O(1)`, with a new unique element requiring a constant amount of memory. However, in the worst case, there could be a resizing operation of the underlying array, which could take linear space complexity `O(n)`. In general, removing an element would take constant space complexity `O(1)`.

Python has a built-in `set` data structure that you use to work with sets in your programs.

Behind the scenes, Python sets are implemented using a hash table where only the keys are stored, without any associated values.

Sets can only store objects of immutable data types because their hash values always remain the same. In contrast, the hash values of mutable objects can change when they are mutated. That's why they cannot be part of sets. If the hash value of an object stored in the set changes, the program would not be able to find it anymore.

To define a set in Python, you just need to surround the elements with curly brackets and separate them with commas:

```python
numbers = {1, 2, 3, 4}
```

To create an empty set, you can call `set()`:

```python
numbers = set()
```

Note that if you use empty curly brackets, this will automatically create a Python dictionary, not a set, so you must call the `set()` function to create an empty set.

You can add an element to a set with the `.add()` method:

```python
numbers.add(5)
```

You can also remove elements from the set with the `.remove()` method:

```python
numbers.remove(5)
```

This will throw a `KeyError` if the element is not found. But if you don't want to throw an error in that case, you can use the `.discard()` method instead.

The `.pop()` method returns an arbitrary element from the set, while the `.clear()` method removes all elements from the set.

You can test if an element is in a set with the `in` operator:

```python
5 in numbers
```

Python also support set operations, including union, difference, symmetric difference, and intersection, which you can perform with these methods:

```python
set_a = {1, 2, 3, 4}
set_b = {2, 3, 4, 5, 6}

set_a.union(set_b)
set_a.intersection(set_b)
set_a.symmetric_difference(set_b)
set_a.difference(set_b)
```

Or with their equivalent operators:

```python
set_a | set_b
set_a & set_b
set_a ^ set_b
set_a - set_b 
```

The average case time complexity for adding, removing, and testing membership is "Constant Time" `O(1)`.

The worst case time complexity for these operations is "Linear Time" `O(n)` because of the hash map's worst case collision scenario.

You can also check if a set is a subset or superset of another one:

```python
set_a.issubset(set_b)
set_a.issuperset(set_b)
```

In general, you should use sets when you need to store a collection of unique items and frequently check for the presence of an item.

Maps, hash maps, and sets are powerful data structures designed for efficient data organization and retrieval. Each one of them has its own unique characteristics and use cases. As a developer, you will need to choose the best one for your project.


## Module: Python Algorithms


### Lecture Block: Lecture Searching And Sorting Algorithms


## What Is Binary Search and How Does It Differ From Linear Search?

### Description

Searching through a list of items is a common occurrence in computer science. There are two key algorithms you should know about when it comes to searching: linear search and binary search.

Linear search starts at the beginning of a list and iterates through each item until it finds the target value it is looking for.

If the target value is found, the index where it's located in the list is returned. If the target value isn't found, `-1` is returned. We return `-1` because it's not a valid index in most programming languages.

Here is what the code looks like for linear search:

```python
def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return -1
```

If the list we'll search through is `[13, 4, 7, 9, 10]` and the target value is `9`, the function would return `3` because `9` is at index `3`.

If we changed the target value to `5`, the function would return `-1` because `5` is not in the list.

While this is a relatively straightforward algorithm, it is not the most efficient. If you have a large list of items, linear search can take a long time to find the target value.

The time complexity of linear search is `O(n)` because the time it takes to search through the list grows linearly with the size of the list.

The space complexity of linear search is `O(1)` because it doesn't require any additional space to search through the list.

Binary search is a more efficient algorithm for searching through a large list of items. The condition here is that the list must be sorted in ascending order.

Binary search works by dividing the list in half and checking if the target value is in the middle of the list. If the target value is in the middle of the list, the index of the target value is returned. Otherwise, the algorithm checks if the target value is in the left or right half of the list.

It continues to divide the remaining parts of the list into halves until the target value is found. If the target value is not in the list, it returns `-1`

Here is what the code looks like for binary search:

```python
def binary_search(arr, target):
    low = 0
    high = len(arr) - 1

    while low <= high:
        mid = (low + high) // 2  

        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1

    return -1
```

We start by identifying a `low` and `high` index. This represents the range of the list we are searching through.

We then check the condition of `low` being less than or equal to `high`. If `low` is greater than `high`, we have searched through the entire list and the target value is not found. In that case we stop the search and return `-1`.

If the `low` index is less than or equal to the `high` index, we calculate the middle index of the list, `mid`. We then check if the target value is at the middle index. If it is, we return the middle index.

Otherwise, we check if the value at the midpoint is less than the target. If it is, we update the low index to be the middle index plus one. This means we will search the right half of the list.

Lastly, if none of the other conditions are `True`, we update the `high` index to be the middle index minus one. This means we will search the left half of the list.

We continue to repeat this process until we find the target or determine that the target is not in the list.

The time complexity of binary search is `O(log n)` because the time it takes to search through the list grows logarithmically with the size of the list.

The space complexity of binary search is `O(1)` because it doesn't require any additional space to search through the list.

Binary search and linear search can be used for a variety of problems you will encounter in computer science. It is important to understand the differences between the two algorithms and when to use each one.


## What Is Divide and Conquer, and How Does Merge Sort Work?

### Description

The divide and conquer paradigm in computer science is a technique for recursively breaking down problems into smaller sub problems. One of the key aspects of this technique is recursion, which happens when a function calls itself repeatedly until a base case is reached. In this lecture, we will take a look at the merge sort algorithm to better understand how the divide and conquer technique works.

Let's say we had this list of numbers:

```md
42 37 53 17
```

The goal is to sort that list from smallest to largest using the merge sort algorithm. The first step is to divide that list in half:

```md
42 37 | 53 17
```

Then we need to look at the left side of the list:

```md
42 37
```

We take that sub list and divide in half again until each sub list has only one item in it:

```md
42 | 37
```

A list with only one item in it is sorted by default. Next we need to merge each of those one element sub lists into a sorted list:

```md
37 42
```

Then we follow the same process for the right side of the original list:

```py
# right side of original list
53 17

# divide the list in half
53 | 17

# merge the lists in sorted order
17 53
```

Now that both halves of the original list are sorted, we merge those two halves together and sort the elements:

```markdown
17 37 42 53
```

Here is what the algorithm looks like in code:

```py
def merge_sort(arr):
    if len(arr) <= 1:
        return arr

    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])

    sorted_list = []
    i = 0
    j = 0

    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            sorted_list.append(left[i])
            i += 1
        else:
            sorted_list.append(right[j])
            j += 1

    sorted_list.extend(left[i:])
    sorted_list.extend(right[j:])

    return sorted_list
```

The time complexity for merge sort would be `O(n log n)` because the list is continuously divided in half (`log n`) and then merged together (`O(n)`). Unlike other sorting algorithms like bubble sort, merge sort is not sorted in place and has a space complexity of `O(n)`.


## Module: Python Graphs And Trees


### Lecture Block: Lecture Understanding Graphs And Trees


## Step 1

### Description

Watch the video or read the transcript and answer the questions below.


## Module: Python Dynamic Programming


### Lecture Block: Lecture Understanding Dynamic Programming


## Step 1

### Description

Watch the video or read the transcript and answer the questions below.


## Module: Review Python


# Chapter: Relational Databases


## Module: Bash Fundamentals


### Lecture Block: Lecture Understanding The Command Line And Working With Bash


## What Is the Terminal, and How Does It Differ from the Command Line?

### Description

Let's learn about the terminal, and how it differs from the command line.

The command line is a basic text input interface which allows a user to enter "commands", usually in the form of a series of characters, and submit or execute them, usually by pressing the "Enter" key. You will most-commonly see command line interfaces within a terminal.

A terminal is a special application that offers a command line interface to perform system-level commands beyond the basic read/write operations. You may also hear about "terminal emulators", which are essentially applications that wrap a basic terminal interface to offer additional features or functionality. But for most general purposes, you are probably safe to refer to these as "terminals" as well.

Finally, we will also need to talk about "shells". A shell is the software that wraps the command line and interprets your inputs as commands, returning the output.

But how can you access the terminal on your system?

Well, if you are running a modern version of Windows, you will likely have two different options. Windows offers two distinct shell applications out of the box: Powershell and Command Prompt.

Both of these shells come with their own terminal applications (which share the name of the respective shell), so you can use your application menu to start either a Powershell terminal or a Command Prompt terminal.

Windows also offers a relatively new and modernized terminal emulator aptly named Microsoft Terminal.

You can install this application from the Windows Store, and are then able to launch it just like you would your Powershell or Command Prompt terminals. The advantage of the Microsoft Terminal is that it allows you to access both the Powershell and Command Prompt shells from the same application, as well as your respective Linux shell if you have configured Windows Subsystems for Linux.

MacOS offers a terminal that is aptly named "Terminal". You can access this through your spotlight search, or through your application launcher.

MacOS also offers support for third-party terminal emulators, such as iTerm or Ghostty. You can install these applications from their home pages.

On Linux, the default terminal (and how you launch it) depends highly on the distro and desktop environment you use. There's a lot of support for third-party terminal emulators, too. For example, you could set up kitty in Arch Linux - and you can launch it with an application manager such as wofi.

Linux arguably has the largest variety of terminal applications to choose from. Most of these can be installed through your distro's package manager.

The distinction between "terminal", "shell", and "command line" may seem rather pedantic at times. And for the most part, the terms can generally be used interchangeably. But it is important to know that they have specific meanings, and what each of those meanings are.


## What Are Some Shortcuts You Can Use in the Command Line to Speed Up Productivity?

### Description

Let's learn about command line shortcuts you can use to speed up productivity.

Terminal and command line shortcuts can help you streamline your workflows and maximize your productivity. For Linux and macOS, which can both trace their roots to Unix, many of these shortcuts will be the same. But for Windows, there will be some differences.

The first shortcut is the up arrow key. Pressing this key will allow you to cycle backwards through your command history, one command at a time. The down arrow key, then, can be used to cycle forwards through your command history. These two keys allow you to quickly cycle through the commands you have previously run to find one you need to run again.

Many shells will also offer an auto-complete feature, proposing commands based on what you have started to type. The tab key can be used to fill in the rest of the suggestion, quickly populating your command line with the full syntax. How these suggestions are generated will vary from shell to shell. For example, in zsh these suggestions are based on your most recent command history. But in PowerShell, they are based on commands, variables, and arguments that are available (with less weight on how recently they were used).

Sometimes a command may result in a lot of output on your terminal. This extra noise can get in the way, or become disruptive to your workflow. In *nix based terminals found on Linux and macOS devices, you can press Control + L to clear the entire screen and start with a fresh clean prompt. In PowerShell, you would need to run the `cls` command (which you can bind to a key combination like Control + L).

If you need to interrupt a command to stop its execution, you can use Control + C to kill the process. This will terminate the command and create a new prompt, allowing you to continue with whatever else you may need to work on. For PowerShell users, Control + C is also used to copy text - and will only work to terminate a process when the context is not ambiguous (such as when there is no text selected to copy).

The next couple of shortcuts are only available in *nix based terminals, and do not have a PowerShell alternative.

There may be times when you need to multitask, allowing a process or command to run in the background while you work on another. Pressing Control + Z places the current process in a background task and returns you to the command line, where you can continue your work. When you need to shift focus back to the background task, you can use `fg` to restore it.

And finally, there may be commands you need to run twice in a row. You can press the up arrow key to cycle backwards to the previously run command, but you can also type two exclamation points (`!!`) into the command line and hit enter - this will automatically run the last executed command.

Many terminals offer even more shortcuts, and I encourage you to read the documentation for your particular setup to find the shortcuts that work best for you. But these basic universal shortcuts should serve as a great starting point for maximizing your productivity and becoming a terminal wizard.


## What Is Bash, and What Are Some Basic Commands?

### Description

Let's learn about Bash and some of its basic commands.

Bash stands for Bourne Again SHell, and is arguably the most common shell you will encounter in Unix-like environments. As such, it can be very beneficial to understand how to navigate this shell and use the common commands.

The first command is `pwd`, which prints the current working directory to the terminal. The "working directory" refers to the directory the terminal is currently pointed at, which is an important thing to know for many of these other commands.

It is entirely possible that your terminal is pointed to the wrong directory. The `cd` command allows you to change directories. You can specify an absolute path, prefixed with a forward slash (`/`), a relative path with no prefix, and use the double-dot (`..`) syntax to move up to the parent directory.

The next command is `ls`, which lists the contents of your current working directory. This is helpful to see if a file or folder exists in your directory. The `ls` command also takes flags to show hidden files (the `-a` flag), file permissions (the `-l` flag), and other features. You will learn more about command flags in the next lecture. You can also use `less` or `cat` to view the contents of a file. 

What if the directory does not contain the file or folder you need? There are commands called `mkdir` and touch that allow you to create them. `mkdir` creates a new directory, or folder, and `touch` creates a new file. Both of these commands accept the name of the file or folder you want to create. For example, `touch readme.md` creates a new Markdown file named `readme.md`.

Maybe your new file should not have been named `readme.md`, but it should have been `readthis.md`. Thankfully, the `mv` command allows you to move (or rename) a file. It takes the old file name and the new file name.

The `rm` command allows you to remove (or delete) a file, and with the `-r` flag will delete a directory. Sometimes a file might be protected, and you'll need to include the `-f` flag.

The `cp` command can be used to copy a file or directory to a new location. Unlike the `mv` command, the `cp` command does not remove the original file - and in order to copy a directory, you'll need to pass the `-r` flag.

The `echo` command can be thought of as the Bash equivalent of a `console.log()` or `print()` function. `echo` takes a string argument, wrapped in quotes, and prints it to the terminal. This might seem silly to run in the terminal, just to get text back in the terminal, but you can actually chain `echo` to a control symbol. The `>` symbol allows you to specify a filename to create or overwrite with the new string, like `echo "Naomi was here." > readme.md`, and the `>>` symbol will append to the file.

There are many more Bash commands available to you, such as `head`, `tail`, `chown`, and `chmod`. It would be impossible to cover them all in this lecture. But you can use the man command to see the manual or help page for nearly any command.

You'll likely remember the commands you use most frequently. And for the rest, you can always check the man page.


## What Are Some Command Options and Flags?

### Description

Let's learn about command options and flags.

In a previous lecture, you learned about passing arguments to commands such as `touch readme.md`. Options, or flags, are special arguments you can pass to a command that affect the way it behaves. The two terms are used interchangeably, though "flags" tends to be used more specifically for options that serve as an on/off toggle.

Options are typically prefixed with one or two hyphen (`-`) symbols, which helps provide a visual distinction between an option and an argument. First, let's look at the two-hyphen, or "long form", syntax.

Many applications, such as `ls`, accept a `--version` flag, which prints the current version of the application to the terminal instead of running the application's commands.

Many applications also offer a `--help` flag, which prints instructions on how to use the application.

The one-hyphen, or "short form", syntax typically uses options that are a single letter. For example, the `-a` flag with `ls` lists all files, including hidden files that start with a dot (`.`), like `.env`.

The advantage of these short options is that you can chain multiple flags together. Instead of `ls --all --human-readable --size` you can use the single letters all at once with `ls -ahs`.

Some options expect a value to be passed to them.

When using long-form options, you typically need to use an equal sign. In this syntax, the value is directly concatenated to the option with the equal (`=`) symbol. Here is an example of modifying the behavior of `ls` to either include or exclude colors:

```bash
ls --color=never
```

When using short-form options, you typically separate the value with a space. For example, here are the long and short form options for setting the `width` of the `ls` result:

```bash
ls -w 50
```

```bash
ls --width=50
```

Notice how the short form uses `-w 50`, while the long form uses `--width=50`. This distinction is important to know, to avoid passing an option value as a positional argument instead.

But if you are ever unsure, remember you can usually use the `--help` flag to see the expected syntax for options!


## Module: Relational Databases


### Lecture Block: Lecture Working With Relational Databases


## What Are Relational Databases, and How Do They Differ from Non-Relational Databases?

### Description

A relational database is a collection of data organized into tables. These tables are made of rows and columns.

Rows represent individual records. For example, if you're storing user data, each row could represent a specific user.

Columns represent the attributes or fields that describe each record. The table might include columns for common user attributes, such as name and national ID number.

One of the key characteristics of relational databases is that they allow us to connect different pieces of information by linking tables through common attributes, making it easier to see how they relate to each other.

Relational databases require a schema. The schema defines the overall structure of the database, including its tables, columns, data types, relationships, and constraints.

All tables in a relational database have a primary key, which is a unique identifier for each row. They enable relationships between tables via foreign keys. You'll learn more about primary keys, foreign keys, and how they work in the coming lectures. For now, just know they are fundamental to linking records across tables.

For example, let's say that you're creating a database for an organization that runs a wildlife conservation center for critically endangered animals.

One of the tables could store general information about the animals, you might call it `animals`. Each row could represent an animal, while each column could represent an attribute of that animal, like species, size, weight, age, and other unique characteristics.

To uniquely identify each animal, you would typically add an `id` column to the table. This would be the primary key of the table because it's unique for each animal. The ID of each animal could be used to link its record in this table to related records in other tables.

You could also have a `species` table to store information about each species, such as their habitat and conservation status. Each animal in the `animals` table could reference a species from this table using a species ID.

You could also create a table to store the veterinary records of the animals. This way, the center can track their health, treatments, and medications.

Once you have this general schema, you could link these tables to the `animals` table, which acts as the central point for animal-related data.

This way, you don't have to keep all the information about an animal in the same table. Instead, you can store related data in separate tables and link them through relationships. By creating these relationships, you can get the specific data you need with a single query.

A query is a request for specific data from the database. Examples of queries that you could make in the context of our example would be finding all animals that need a veterinary checkup, finding the most critically endangered species in the center, finding the number of animals who were born in captivity, and more. You can customize the queries to fit your needs.

Our example was related to wildlife conservation, but relational databases have a wide range of applications across industries such as healthcare, construction, business, gaming, education, government, e-commerce, social media, and more.

They offer several advantages, including scalability. They can handle large datasets, so they're perfect for complex, real-world applications. They also enforce data integrity through primary keys, foreign keys, and data types, which ensures that the data will be consistent and accurate.

In addition to relational databases, you can work with non-relational databases.

The main difference between relational and non-relational databases is how the data is stored. Non-relational databases, also known as NoSQL databases, are more flexible. They store data in individual files that are not connected. Their data model is more flexible too.

While some non-relational databases may have a basic schema or data model, it is often less rigid than the schema defined in relational databases. You can add, modify, or remove data fields if necessary.

The decision to use a relational or non-relational database depends on various factors, including the nature of the data and the specific requirements of the application. You should evaluate the tradeoffs between these two approaches to choose the best one for your application.


## What Are Some Common Relational Databases, and How Do You Install and Use Postgres?

### Description

Relational databases have a wide range of applications, including web development, inventory management systems, healthcare systems, e-commerce applications, and more.

Some of the most common relational databases are MySQL, PostgreSQL, SQLite, and Microsoft SQL Server. Let's learn a little bit about each one of them.

MySQL is an open-source relational database management system. It's very popular for web development because it's easy to use, reliable, and efficient for building real-world applications. It also has an active community of developers that support and maintain it.

PostgreSQL is officially described as "The World's Most Advanced Open Source Relational Database." It's a free, open source object-relational database system known for its reliability, data integrity, and extensibility. For example, you can define your own data types, custom functions, and write code in different programming languages without re-compiling your database.

SQLite is a free, open source, and lightweight file-based SQL database engine. It's one of the most widely used database engines in the world. SQLite is self-contained and serverless. It's a zero-configuration database, which means that it doesn't require an initial setup process, which is great for getting started quickly.

These three databases are free and open source. There are other popular proprietary options too, including Microsoft SQL Server and Oracle database.

Microsoft SQL server is a popular relational database management system developed by Microsoft and used in various applications.

Oracle database is a scalable relational database management system often used for enterprise applications that require high performance.

Great. Now that you know more about the different options available, let's see how you can install PostgreSQL.

First, you need to go to the official website: <a href="https://www.postgresql.org/" target="_blank">https://www.postgresql.org/</a>.

Once you're there, click on the "Download" button.

This will take you to a page where you can select your operating system. If you click on one, you will be taken to the instructions for that OS.

We will go through the installation process for the Windows operating system, but the process is similar across operating systems.

From this page, you can download the installer by clicking on the "Download the installer" link.

This will take you to a page where you can choose the version of PostgreSQL you want to install. If you click on the corresponding icon, the download should start.

Then, in your Downloads folder or the folder where you store your downloads by default, you should see the installer.

If you double-click on it, you will start the setup process. Click Next.

Choose the directory where PostgreSQL will be installed. You'll see one by default but you can customize it.

Then, select the component that you want to install. There are four possible components:

- PostgreSQL Server, the database engine itself.
- pgAdmin 4, a user-friendly tool for database management.
- Stack Builder, a tool for downloading and installing additional PostgreSQL-related software and extensions
- And Command Line Tools, to interact with the PostgreSQL server directly from your terminal. This includes psql, an interactive terminal for executing SQL queries.

When you're ready, click Next.

Then, select a directory to store your data. You will see a default path but you can customize this. When you're ready, click Next.

Now you'll need to enter a password for the database superuser, the user with unrestricted access to all databases and objects. Type in your password, retype it, and then click Next.

Then, select the port number the server should listen on. By default, it's 5432. Then, click Next.

You'll need to choose a locale for the new database cluster. This is important for the database to interpret locale-sensitive data types. Then, click Next.

Finally, you'll see a pre-installation summary. Take a moment to review this and click Next.

You will need to confirm that you want to start the installation process. If you click Next, the process will start. It should only take a few minutes.

When the process is completed, based on the components that you installed, you may have to choose if you want to launch Stack Builder to download and install additional tools, drivers, and applications.

If you decide to launch Stack Builder, you'll see a screen where you can start the installation. Alternatively, you can click Cancel to do this later on.

Congratulations! Now you have PostgreSQL installed on your computer. The process should be similar for other operating systems. After this, you can start using the database.

Go to your apps and search for pgAdmin, an open source administration and development platform for PostgreSQL that should have been installed if you selected it in the components. Click on pgAdmin 4 to open it.

You'll see an initial loading screen when the application starts. Then, you should see a dashboard where you can start a new server, check your databases, configure pgAdmin, and more. You'll also find helpful links to the documentation.

If you click on "Servers" at the top left, you will need to enter the password that you chose during the installation.

After entering your password, you should see a screen where you will have access to your databases, including their tables.

You'll also find another very helpful tool, psql, an interactive terminal for SQL queries. To open it, search for psql on your system. Click on it.

It will open the SQL Shell, where you can start running commands.

And that's how you can install PostgreSQL on Windows. The process is very similar for macOS and Linux.

Alternatively, if you are installing it on macOS, you can use Homebrew, a package manager. Once you have Homebrew installed, run this command to install PostgreSQL:

```bash
brew install postgresql@<version>
```

You can specify the version that you want to install by writing the number after the at (`@`) symbol.


## What Is SQL, and How Can You Create a Database with Tables?

### Description

SQL stands for Structured Query Language. It was developed in the 1970s, when it was initially known as the structured English query language (SEQUEL). This term was later shortened to SQL.

SQL is a programming language used for storing and managing data in relational databases.

Like you learned in a previous lecture, relational databases organize data into tables. Each table has a set of rows and columns, where the data attributes and their relationships are represented. Each row represents a record while each column represents a specific attribute or field of that record.

With SQL, you can add, change, delete, find, and retrieve data from a relational database. It provides a comprehensive set of commands for querying, filtering, sorting, and aggregating data.

SQL can help optimize database performance, by querying only the necessary data, and it can be easily integrated with a wide range of programming languages, so you can use it to interact with databases directly from your applications.

It has been also adopted as an industry standard. It enforces data integrity and includes many security features, like support for user authentication and data encryption.

It's also scalable, portable, and compatible with a wide range of database management systems.

SQL is based on commands, commonly known as SQL statements or SQL queries.

As a developer, you will write these statements using specific SQL language elements or keywords. They allow you to perform the necessary operations on your database.

Before you can enter SQL commands, you need to open the psql shell so you can directly interact with the PostgreSQL database. In the command prompt or terminal, enter:

```bash
psql -U <username> -d <database_name>
```

Replace `username` with your username and `database_name` with the database you want to connect to. If you haven't created own your database yet, use `postgres`, it comes with the installation.

Once connected, you will see the prompt change to:

```bash
postgres=#
```

It shows the database name you are connected to and waits for SQL commands.

Let's go over some of the most fundamental SQL commands that you should be familiar with. You'll notice that, by convention, SQL commands end with a semicolon (`;`).

First, you can use this command to create a database named `my_database`:

```sql
CREATE DATABASE my_database;
```

You can type `CREATE` followed by `DATABASE`, and the name of the database that you want to create. Notice that the SQL keywords of the command are written in capital letters.

Then, once you have your database, you can connect to it.

How you connect to the database really depends on the environment and tool you're using.

In the command prompt or terminal, you can use the method shown earlier. In the interactive psql shell, you can switch databases with the `\c` shortcut command followed by the database name like this:

```bash
\c my_database
```

Note that the `\c` command and other shortcut commands (ones with a backslash in front of them) are part of the psql shell and not part of the SQL language itself, so they do not require a semi-colon to complete the command.

Now that you've connected to your new database, you will see the prompt has changed:

```bash
my_database=#
```

Once you have created and connected to a database, you can create a table with the `CREATE TABLE` keywords:

```sql
CREATE TABLE products (
  id SERIAL,
  name VARCHAR(255)
);
```

In the command, you write `CREATE TABLE`, followed by the name of the table that you want to create. In this case, it will create a table named `products`.

Then, within parentheses, you write the names of the columns that the table should have and specify the data type of the values that will be stored in each column.

In the example, the table will have two columns, a column for the product ID and another one for the name of the product.

The standard naming convention for table and column names is snake case, writing words in lowercase and separating them with an underscore (`_`). For example: `delivery_orders`

These are few essential SQL commands you should know to get started.

With SQL, you can easily query, manipulate, and analyze data to make informed decisions and solve real-world problems.


## What Are the Basic Data Types in SQL?

### Description

To define a table in SQL, you need to specify the data type of each column.

Remember that this is the basic syntax for creating a table in SQL. Each column has its own data type.

```sql
CREATE TABLE table_name(
  column1 data_type column_constraint,
  column2 data_type column_constraint,
  column3 data_type column_constraint,
  ... etc
);
```

As a developer, your goal is to choose these data types as accurately as possible.

There are six popular categories of data types in SQL:

- Numeric, such as `INTEGER`, `FLOAT`, `SERIAL`, and `DECIMAL`.
- Date and time, such as `TIMESTAMP`, `DATE`, and `TIME`.
- Character and string. These include `CHAR`, `VARCHAR`, and `TEXT`.
- Unicode, including `NTEXT`, and `NVARCHAR`. These are used to make sure that text will be stored and retrieved correctly, regardless of the characters' origin.
- Binary, used to store non-textual data, like images, audio, and video files.
- And other miscellaneous data types, such as `XML` and `TABLE`.

In this lecture, we'll cover some of the most widely used ones with PostgreSQL. Data types will vary across database management systems, but they are generally pretty similar. So you'll need to check the full list in the documentation.

We'll start with numeric values.

First, we have the `INTEGER` data type:

```sql
units_sold INTEGER
```

In this example, we assign this data type to a `units_sold` column.

`INTEGER` types consume 4 bytes in the database and can range in value from -2,147,483,648 to 2,147,483,647. The official PostgreSQL documentation describes it as the "typical choice for integer."

We also have `SMALLINT` and `BIGINT`, which are basically the same as `INTEGER` except have a smaller and bigger range of numbers, respectively, due to how much size they are allotted in the database.

A useful feature available in PostgreSQL is to create a column using the `SERIAL` keyword. Here, an `id` column is created using `SERIAL`:

```sql
id SERIAL
```

While it's not a true data type, it's very helpful for creating unique identifier columns because the column will have an `INTEGER` type, will not allow `NULL` values, and automatically increment when rows are added.

For example, the first row will automatically have an `id` of `1`, the second row will have an `id` of `2`, and so on, creating a unique ID for each record.

In MySQL, the equivalent of `SERIAL` would be the `AUTO_INCREMENT` attribute, used to generate sequential integers automatically:

```sql
id INT AUTO_INCREMENT
```

You can see that different database management systems may have different ways of achieving exactly the same functionality in your database.

These are the most commonly used numeric data types, but sometimes, you may need to represent text or sequences of characters.

For this, you have the `VARCHAR` data type. This data type is used for a variable string length. You can set the maximum character length within parentheses:

```sql
name VARCHAR(50)
```

In this example, we define a `name` column, where the values can be up to 50 characters long.

This data type sets a maximum length for the strings, but if you need to store strings of any length, you can use `TEXT` instead:

```sql
name TEXT
```

In addition to numbers and strings, it's also common to store dates and times.

For example, if you create a table to store events, you may need to store the date of each event in a specific format. For this, you have the `DATE` data type:

```sql
event_date DATE
```

To store time, you can also use the `TIME` data type. For example, you may store the time when an event starts:

```sql
start_time TIME
```

The `TIMESTAMP` data type combines both of them. It includes both the date and time. It may also include the time zone if you write `TIMESTAMP WITH TIME ZONE`:

```sql
event_timestamp TIMESTAMP
```

```sql
event_timestamp TIMESTAMP WITH TIME ZONE
```

And finally, if you need to store a boolean value, `TRUE` or `FALSE`, you can use the `BOOLEAN` data type:

```sql
is_active BOOLEAN
```

Now you know some of the most common data types in SQL, but there are many more. You can check the documentation of your database management system to find more information about the data types that you can use.


## How Do You Insert and View Data in a Table?

### Description

Let's see some of the fundamental commands that you can use to insert and view data in SQL.

First of all, to view data, you need to insert it. So we'll start with insertions.

The examples that we will cover in this lecture will be based on this table of dog records:

```sql
CREATE TABLE dogs(
  id SERIAL,
  name VARCHAR(100),
  age INTEGER
);
```

The table will store the names and ages of various dogs.

If we assume that we are working with PostgreSQL, we can use the `SERIAL` data type for the `id`. Since `id` was created using `SERIAL`, its value will be an `INTEGER`, starting from `1`, and incremented automatically when a new record is inserted. So you will not need to pass a value for it when you insert a record.

Let's start by inserting records to our `dogs` table with the `INSERT INTO` statement. There are many ways to do this. The first one would be inserting a single row and specifying the columns of the values that will be inserted.

You write `INSERT INTO`, followed by the name of the table (in this case, `dogs`), then the columns within parentheses, then `VALUES`, and their corresponding values within parentheses.

This is an example, we're inserting a dog record with the `name` of `'Gino'`, whose `age` is `3`, remember that the `id` will be assigned automatically:

```sql
INSERT INTO dogs (name, age)
VALUES ('Gino', 3);
```

This is usually the safest option because you specify the columns explicitly, so the values will be assigned to those columns in order.

Notice that `'Gino'` needs to be in single quotes because it is a `VARCHAR` type.

Another alternative is to insert the record without specifying the columns, like this:

```sql
INSERT INTO dogs
VALUES ('Gino', 3);
```

This is valid too, but it's more prone to errors because the values are assigned to the columns based on their order.

You can also insert multiple records in the same SQL command by separating them with a comma.

Here, we are inserting two dog records, one for `'Gino'` and another one for `'Nora'`.

```sql
INSERT INTO dogs (name, age)
VALUES
  ('Gino', 3),
  ('Nora', 2);
```

And just like you can insert records, you can query information from the database. In the context of databases, a query is a request for data.

In SQL, the `SELECT` statement is used for querying data from one or more tables. You can customize the query to get the exact information that you need.

If you need to query all the information from the `dogs` table, you just need to write `SELECT`, followed by an asterisk (`*`), then `FROM`, and the name of the table, `dogs`:

```sql
SELECT *
FROM dogs;
```

In this command, the asterisk is a wildcard character that represents "all columns."

You will get all the data of all the records in the table:

```sql
 id | name | age 
----+------+-----
  1 | Gino |   3
  2 | Nora |   2
```

To query specific columns, you can write the names of those columns in the command, right after `SELECT`, separated by a comma. In this example, we query the `name` and `age` columns of the `dogs` table:

```sql
SELECT name, age
FROM dogs;
```

The result will only include the `name` and `age` columns:

```sql
 name | age 
------+-----
 Gino |   3
 Nora |   2
```

Sometimes, you might need to query data based on a specific condition. For example, to get all dogs who are less than 3 years old you can use the `WHERE` keyword and the less than (`<`) comparison operator:

```sql
SELECT *
FROM dogs
WHERE age < 3;
```

The result will only include dogs whose age is less than 3:

```sql
 id | name | age 
----+------+-----
  2 | Nora |   2
```

If you are just trying to find the `age` of `'Gino'`, you can you can use the equals (`=`) comparison operator:

```sql
SELECT age
FROM dogs
WHERE name = 'Gino';
```

And here's the result:

```sql
 age 
-----
  3
```

These are common and simple ways to insert and view data in SQL, but there are many different options that you can choose from and some of them are more advanced. You'll learn about them in coming lectures.


## What Are Primary and Foreign Keys in SQL, and How Do They Work?

### Description

In SQL, primary keys and foreign keys are used to establish relationships between tables.

Let's start with primary keys.

A primary key is a column or set of columns that uniquely identifies each record (row) in a table. This constraint ensures that no records in the table will have the same value for the primary key.

This is why a table can only have one primary key.

Values in the primary key column can't be `NULL` either, so they will always have a valid value.

In PostgreSQL, to make a column the primary key of your table, you just need to add `PRIMARY KEY` after the data type:

```sql
column_name data_type PRIMARY KEY
```

This is an example of a `students` table:

```sql
CREATE TABLE students (
  student_id SERIAL PRIMARY KEY,
  name VARCHAR(100)
);
```

Each student will have its own `student_id`, and this ID will be the primary key of the table. The `SERIAL` type is useful here because it ensures the `student_id` will always have a unique value.

A composite primary key is for when a table doesn't have a single unique column to identify the row. In this case, you can use a combination of two or more columns as the primary key that, together, are unique.

To do this, denote which columns are the composite primary key when you create the table like this:

```sql
CREATE TABLE table_name (
  column1 data_type column_constraint,
  column2 data_type column_constraint,
  column3 data_type column_constraint,
  ...
  PRIMARY KEY (column1, column2)
);
```

Imagine you have a table with `student_id` and `course_id` columns that tells you what students are enrolled in various classes.

Each student will be enrolled in several classes, and each class will have several students enrolled in it. So neither column is unique - but you will never have the same student enrolled in the same class more than once. So you can use the combination of the two columns as the primary key:

```sql
CREATE TABLE course_enrollments (
  student_id INT,
  course_id INT,
  ...
  PRIMARY KEY (student_id, course_id),
);
```

Primary keys are essential for ensuring data uniqueness and integrity, for optimizing data retrieval, and for establishing relationships with other tables in a relational database.

That takes us to the next type of key that we will cover in this lecture: foreign keys.

A foreign key is a column (or set of columns) in a table that references the primary key of another table. A table can have multiple foreign keys.

In this example, we have two tables, `customers`, and `orders`:

```sql
CREATE TABLE customers (
  customer_id SERIAL PRIMARY KEY,
  first_name VARCHAR(100) NOT NULL,
  ...
);

CREATE TABLE orders (
  order_id SERIAL PRIMARY KEY,
  customer_id INTEGER,
  ...
  FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);
```

The primary key of the `customers` table is `customer_id` and the primary key of the `orders` table is `order_id`.

But notice that there is also a `customer_id` column in the `orders` table.

Why are we storing customer information in the `orders` table?

We do this to create a relationship between the `customers` and `orders` tables. Each order will store the ID of the customer who submitted it.

To create the relationship between the tables, we will make the `customer_id` column in the `orders` table a foreign key that references the `customer_id` column in the `customers` table:

```sql
FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
```

Values in a foreign key column must either match the primary key values in the referenced table or be `NULL` (if the foreign key allows `NULL`s).

Why is this helpful?

By making sure that these columns in both tables match exactly, foreign and primary keys prevent the creation of "orphaned" records, records that refer to a non-existent record in another table.

Primary and foreign keys are fundamental for relational databases. They power the "relational" aspect of these databases, allowing you to model real-world data in an accurate way.


## What Are the Different Types of Relationships in a Relational Database?

### Description

Like you learned in previous lectures, relational databases store data in tables, which are made of rows and columns.

The "relational" aspect of "relational databases" comes from the fact that records in different tables can have different types of relationships.

There are five main types of relations:

- one-to-one
- one-to-many
- many-to-one
- many-to-many
- And self-referencing relationships (also known as recursive relationships).

Two tables have a **one-to-one** relationship when each record in the first table can be associated with at most one record in the second table, and vice versa.

For example, let's say a company only assigns one vehicle per employee.

In that case, the database could have an `employees` table and a `vehicles` table, where each employee record corresponds to one, and only one, vehicle record in the database.

In contrast, **one-to-many** relationships occur when one record in a table can be related to one or more records in another table.

For example, if we have a `customers` table and an `orders` table, each customer could be related to one or more orders but each order can only be related to one customer.

This is the same as the **many-to-one** relation, but from the opposite perspective. One or more orders can be related to one customer.

**Many-to-many** relationships occur when a record in a table can be related to multiple records in another table and vice versa.

For example, let's analyze a database for a library. For simplicity purposes, let's assume that this database only has two tables: `books` and `authors`.

An author can write multiple books, and a single book can be written by multiple authors.

Implementing this type of relationship is a little bit more complex because the relational model at its core doesn't support many-to-many relationships directly.

To handle this, you would usually create an intermediate table, also known as a junction table.

This table solves these initial limitations by transforming the many-to-many relationship into two one-to-many relationships.

It creates a one-to-many relationship between the first table and the junction table and a one-to-many relationship between the second table and the junction table.

The name of the junction table is usually a combination of the entities. In the context of our example of `books` and `authors`, you may call it `books_authors`.

In the junction table itself, you would associate the authors and their books by creating two columns: a column for the author's id (`author_id`) and another column for the book's id (`book_id`).

These would be foreign keys referencing their corresponding primary keys in the `authors` and `books` tables, respectively.

With this junction table, you'll be able to query all the authors of a given book or all books written by a given author.

Using a junction table makes it easier to query the data, prevents redundancy, and simplifies the database schema. They are very helpful for implementing many-to-many relationships.

And finally, we find **self-referencing** relationships, which occur when the records of a table can be related to other records on the same table. This is also known as a recursive relationship.

Understanding these relationships is essential for designing and modeling complex and efficient relational databases.


## What Are the Different Ways to Join Tables?

### Description

Even though relational databases organize data into separate tables, SQL's `JOIN` operations allow you to combine related information from tables to query data.

There are five main types of `JOIN` operations:

- `INNER JOIN`
- `FULL OUTER JOIN`
- `LEFT OUTER JOIN`
- `RIGHT OUTER JOIN`
- `SELF JOIN`
- And `CROSS JOIN`

Let's start with `INNER JOIN`.

An `INNER JOIN` filters the result to include only rows where the values in the joining columns that you specify are equal in both tables. Basically, it gives you the intersection of the data.

To illustrate this, let's say that we have two tables.

The first is this `products` table with multiple products. It includes their ID's, names, category, price, and origin.

```sql
| product_id | product_name     | category    | price (USD) | origin        |
| ---------- | ---------------- | ----------- | ----------- | ------------- |
| 1          | Ice Cream        | Food        | 2.50        | India         |
| 2          | Pizza Margherita | Food        | 12.00       | Italy         |
| 3          | Sushi            | Food        | 18.75       | Japan         |
| 4          | T-Shirt          | Clothing    | 25.00       | USA           |
| 5          | Jeans            | Clothing    | 60.00       | Argentina     |
| 6          | Coffee           | Beverages   | 35.00       | France        |
| 7          | Juice            | Beverages   | 5.00        | Colombia      |
```

And second, we have a `sales` table, with the sale ID, product ID, quantity, and sale date.

```sql
| sale_id | product_id | quantity | sale_date  |
| ------- | ---------- | -------- | ---------- |
| 101     | 1          | 2        | 2025-07-18 |
| 102     | 2          | 3        | 2025-02-13 |
| 103     | 6          | 10       | 2025-06-08 |
| 104     | 5          | 8        | 2025-01-10 |
| 105     | 2          | 1        | 2025-05-15 |
```

We can perform an `INNER JOIN` based on the `product_id` like this:

```sql
SELECT *
FROM products
INNER JOIN sales
  ON products.product_id = sales.product_id;
```

This will only get the rows that have the same `product_id` in both tables. So if a product is not in the sales table or in products table, it will not be included.

This is the result:

```sql
product_id | product_name     | category  | price | origin    | sale_id | product_id | quantity | sale_date
---------- | ---------------- | --------- |-------|-----------|---------|------------|----------|------------
     1     | Ice Cream        | Food      |  2.50 | India     |     101 |          1 |        2 | 2025-07-18
     2     | Pizza Margherita | Food      | 12.00 | Italy     |     102 |          2 |        3 | 2025-02-13
     2     | Pizza Margherita | Food      | 12.00 | Italy     |     105 |          2 |        1 | 2025-05-15
     5     | Jeans            | Clothing  | 60.00 | Argentina |     104 |          5 |        8 | 2025-01-10
     6     | Coffee           | Beverages | 35.00 | France    |     103 |          6 |       10 | 2025-06-08
```

We only see the rows of the products that have been sold. For example, `'Pizza Margherita'` is in the `sales` table, with a `product_id` of `2`, so we get that product in the result.

However, `'T-Shirts'` with a `product_id` of `4` were not sold, so this product is not in the `sales` table. They are not in both tables, so they are not included in the result.

Joining tables does exactly what it sounds like. It joins two or more tables into one, which is why we see all the columns from both tables, including `product_id` twice.

A `FULL OUTER JOIN` returns all rows from both tables.

If a match is found in the specified columns, the data is combined and you get all columns for each matching record.

If there's no match in the specified columns, in either one of the tables, the missing columns are filled with `NULL` values.

Let's perform a `FULL OUTER JOIN` in our example, based on the `product_id` column. This column will determine if there is a match or not.

```sql
SELECT *
FROM products
FULL OUTER JOIN sales
  ON products.product_id = sales.product_id;
```

This is the result:

```sql
product_id | product_name     | category  | price | origin    | sale_id | product_id | quantity | sale_date
---------- | ---------------- | --------- |-------|-----------|---------|------------|----------|------------
         1 | Ice Cream        | Food      |  2.50 | India     |     101 |          1 |        2 | 2025-07-18
         2 | Pizza Margherita | Food      | 12.00 | Italy     |     102 |          2 |        3 | 2025-02-13
         3 | Sushi            | Food      | 18.75 | Japan     |         |            |          |
         4 | T-Shirt          | Clothing  | 25.00 | USA       |         |            |          |
         5 | Jeans            | Clothing  | 60.00 | Argentina |     104 |          5 |        8 | 2025-01-10
         6 | Coffee           | Beverages | 35.00 | France    |     103 |          6 |       10 | 2025-06-08
         7 | Juice            | Beverages |  5.00 | Colombia  |         |            |          |
         2 | Pizza Margherita | Food      | 12.00 | Italy     |     105 |          2 |        1 | 2025-05-15
```

Notice how `'Pizza Margherita'` has all the data, including columns from the `sales` table because there was a match.

But `'T-Shirt'` has empty (`NULL`) columns because no match was found in the `sales` table (this product was not sold).

A `LEFT OUTER JOIN` is used to get all the records from the left table and the matching information from the right table for each row of the left table.

If no match is found, the columns from the right table are filled in with `NULL` values.

Let's perform a `LEFT OUTER JOIN` in our example.

```sql
SELECT *
FROM products
LEFT JOIN sales
  ON products.product_id = sales.product_id;
```

This is the result:

```sql
product_id | product_name     | category  | price | origin    | sale_id | product_id | quantity | sale_date
---------- | ---------------- | --------- |-------|-----------|---------|------------|----------|------------
         1 | Ice Cream        | Food      |  2.50 | India     |     101 |          1 |        2 | 2025-07-18
         2 | Pizza Margherita | Food      | 12.00 | Italy     |     102 |          2 |        3 | 2025-02-13
         3 | Sushi            | Food      | 18.75 | Japan     |         |            |          |
         4 | T-Shirt          | Clothing  | 25.00 | USA       |         |            |          |
         5 | Jeans            | Clothing  | 60.00 | Argentina |     104 |          5 |        8 | 2025-01-10
         6 | Coffee           | Beverages | 35.00 | France    |     103 |          6 |       10 | 2025-06-08
         7 | Juice            | Beverages |  5.00 | Colombia  |         |            |          |
         2 | Pizza Margherita | Food      | 12.00 | Italy     |     105 |          2 |        1 | 2025-05-15
```

In this case, it's the same as the `FULL OUTER JOIN` because it includes all rows from the first table, `products`.

A `RIGHT OUTER JOIN` is very similar, but now we get all the records from the right table and the matching information from the left table for each row of the right table.

If there's no match, the columns from the left table are filled in with `NULL` values.

Let's perform a `RIGHT OUTER JOIN` in our example.

```sql
SELECT *
FROM products
RIGHT JOIN sales
  ON products.product_id = sales.product_id;
```

Here is the result:

```sql
product_id | product_name     | category  | price | origin    | sale_id | product_id | quantity | sale_date
---------- | ---------------- | --------- |-------|-----------|---------|------------|----------|------------
         1 | Ice Cream        | Food      |  2.50 | India     |     101 |          1 |        2 | 2025-07-18
         2 | Pizza Margherita | Food      | 12.00 | Italy     |     102 |          2 |        3 | 2025-02-13
         6 | Coffee           | Beverages | 35.00 | France    |     103 |          6 |       10 | 2025-06-08
         5 | Jeans            | Clothing  | 60.00 | Argentina |     104 |          5 |        8 | 2025-01-10
         2 | Pizza Margherita | Food      | 12.00 | Italy     |     105 |          2 |        1 | 2025-05-15
```

You'll notice that it has fewer rows. This is because it takes all the records from the right table (`sales` in this case), and this table has fewer rows than the `products` table.

If it finds a match in the `products` table, it fills those columns with the data. But if there's no match, the columns are filled with `NULL`.

In this case, every product that has been sold has a record in the `products` table, so the data is complete.

These are the most commonly-used `JOIN` operations, but there are two additional ones that you should know about.

A `SELF JOIN` allows you to join the table with itself. You can think of it as joining two copies of the same table. This is helpful for comparing different rows within the same table.

A `CROSS JOIN`, also known as a Cartesian Join, joins every row from the first table with every row of the second table. Therefore, it generates all possible row combinations. This operation doesn't need any conditions to join the tables.

These `JOIN` operations are fundamental for working with SQL. By choosing the right one, you can query the data you need as efficiently as possible.


## Module: Bash Scripting


### Lecture Block: Lecture Understanding Bash Scripting


## What Is Bash Scripting, and What Are Some Advantages to Using It?

### Description

In previous lectures, you learned about Bash and some of the common commands you might use. But Bash supports a full scripting language, which you can use to perform more complex automated tasks.

Bash scripting involves writing a sequence of Bash commands in a file, which you can then execute with Bash to run the contents of the file.

Let's look at what a bash script may look like:

```bash
#!/bin/bash

servers=("prod" "dev")

for server in "${servers[@]}"
do
  echo "Pulling $server"
  rsync --archive --verbose $server:/etc/nginx/conf.d/server.conf configs/$server.conf
done
```

This script pulls NGINX configuration files from a list of remote servers, which can be useful for backing up those configs into a local repository. NGINX is a popular web server and you will learn more about working with servers in a future module. 

The first line is called a "shebang" (`#!`) and tells the system which interpreter should be used to run the script. Common values here are `/usr/bin/bash`, `/bin/bash`, or `/bin/sh`.

The first line, `servers=("prod" "dev")`, instantiates a list of strings representing the server names. `"prod"` is often used to refer to the production site, while `"dev"` refers to the development site, which is typically used for testing new features and changes before they are deployed to the live production environment.

Then, the list is iterated through with a `for` loop - the `servers[@]` syntax expands the list into individual elements. Each element is assigned to server with each iteration.

The `do` statement indicates the beginning of the loop's logical block, or the code that should run with each iteration.

`echo "Pulling $server"` interpolates the current value of the server variable, which would be prod or dev in this case, and logs it to the terminal.

Then `rsync` is used to pull the actual file from the server and save it locally, using more interpolation to manage that command.

`done` indicates the end of the loop's logical block.

There are a number of significant advantages to understanding and leveraging Bash scripting.

The first is that nearly every Unix environment comes with Bash readily available, which means you can run your script as-is without having to configure any language runtimes like Node.js or Python.

The second is that you have access to all of the binary applications available on the system with minimal effort. If your system has doctl installed, your script can execute that binary. A binary is a compiled program that the computer runs. When you have a bash script, you can execute the binary which will launch the program.

And finally, the syntax you use for your script is also executable directly in the terminal. This means that testing a small portion of your script becomes much less convoluted - you can copy and paste that portion directly into your terminal and see the result!

Understanding Bash will not only level up your scripting game, but will make you a wizard in the command line!


## Module: Sql And Bash


### Lecture Block: Lecture Working With Sql


## What Is Normalization in SQL?

### Description

Normalization is the process of organizing a relational database using established normal forms to reduce data redundancy and improve data integrity.

To normalize a database, you analyze the attributes and relationships in your table structures to identify opportunities for simplification based on normalization rules. Then, you divide the data into smaller, more focused tables and establish relationships between them using primary and foreign keys. These smaller tables will store all the data that you originally had, but they will be easier to manage, organize, and work with, compared to larger tables.

By minimizing data redundancy, normalization reduces storage space and prevents inconsistencies. For example, if a customer's address changes, you only need to update it in one customer table rather than in every order record. 

It also helps preserve data integrity by making sure that dependencies are enforced by primary and foreign key constraints. This reduces the likelihood of insertion, update, and deletion anomalies.

A normalized database is easier to understand and maintain, which contributes to a well-designed database system.

The set of rules that you should follow to organize your tables are called normal forms. Each normal form builds on the previous ones, with rules becoming stricter as you move to higher normal forms. The First Normal Form (1NF) is the foundational form, with the most basic rules.

A table is in First Normal Form (1NF) if:

- Each cell should contain only one value. For example, if you have a `students` table, you may have a student with multiple phone numbers. Instead of storing them as a comma-separated list in one cell, you should create a separate `phone_numbers` table with a foreign key pointing to the `students` table and only store one value in each cell. This keeps each value atomic and the design normalized.
- Every record (row) must be unique. While primary keys enforce this requirement, 1NF explicitly mandates that no duplicate rows exist in the table.
- The order of the rows and columns should not be relevant. Data should not depend on its physical location.

Essentially, the First Normal Form (1NF) focuses on making values simple and atomic.

The Second Normal Form (2NF) builds on 1NF, requiring that all 1NF requirements are met plus additional constraints.

Understanding 2NF requires familiarity with two key concepts: superkeys and candidate keys. A superkey is any set of attributes that uniquely identifies each row in a table, meaning no two rows can have identical values across all columns in the superkey.

For example, if we have a `customers` table with three columns:

```sql
customer_id | name | email
```

Let's say that `customer_id` and `email` must be unique for each record. Some examples of superkeys for this table would be:

- `customer_id`
- `{ customer_id, name }`, this combination uniquely identifies rows because `customer_id` alone is unique, regardless of `name`'s uniqueness.
- `{ customer_id, name, email }`
- `email`, since we are adding the unique constraint to this column too, each record can be uniquely identified by the email.

Any set of attributes that, together, identify each row can be a superkey.

A candidate key is similar and yet, a bit different. It's a set of one or more columns on the table that can uniquely identify each record. A table can have multiple candidate keys but you'll need to choose one to act as the primary key.

They sound quite similar, right? Their difference is that the superkey can also contain additional attributes that are not necessary to identify each row uniquely, while the candidate key only contains attributes that do identify the row uniquely.

In our `customers` example, we mentioned that `customer_id`, `{ customer_id, name }`, `{ customer_id, name, email }`, and `email` can be superkeys. In this case, only `customer_id` and `email` can be candidate keys because candidate keys can't include attributes that don't identify the row uniquely, like `name`. This illustrates the minimality principle that distinguishes candidate keys from superkeys.

Now that you're familiar with these concepts, let's go back to the Second Normal Form (2NF).

The Second Normal Form (2NF) is based on addressing partial dependencies. A partial dependency occurs in a table when an attribute that is not part of the primary key only depends on part of a composite primary key (a composite key is a primary key made of multiple columns). This can lead to data redundancy and update anomalies.

For example, let's say we have an `orders` table with these columns:

```sql
order_id | item_id | order_date | product | quantity | order_shipping_city
```

In this table, the primary key is the combination of `order_id` and `item_id` because the same item ID can be in different orders, but their combination will be unique. You can see that there is a partial dependency between `order_id` and `order_shipping_city`. `order_id` is part of the primary key. `order_shipping_city` depends on `order_id` because every order with the same ID will have the same shipping city. However, the shipping city does not depend on the `item_id`, but this is also part of the primary key. Therefore, `order_shipping_city` does not depend on the entire primary key.

To fix this, you can split the table into two smaller tables, like `order_header` and `order_items`. In the `order_header` table, you could store the top-level information about the orders: 

```sql
order_id | order_date | order_shipping_city
```

In the `order_items` table, you could store information about the items in the different orders that were submitted:

```sql
order_id | item_id | product | quantity
```

With these changes, both tables will be in Second Normal Form (2NF).

And that leads us to the Third Normal Form (3NF). This normal form builds on the second normal form.

For a table to be in Third Normal Form, it must:

- Be in Second Normal Form.
- Have all non-key attributes depend directly on the primary key, meaning no non-key attribute should depend on another non-key attribute.

To understand the Third Normal Form (3NF), you need to understand transitive dependencies. A transitive dependency occurs when an attribute that is not part of the primary key depends on another attribute that is not part of the primary key, which in turn depends on the primary key.

For example, let's modify our `orders` table to have these columns:

```sql
order_id | customer_id | customer_city | city_postal_code | order_date | product | quantity
```

The primary key in this new table is `order_id` because it uniquely identifies each row.

There is a transitive dependency in this table:

```sql
order_id > customer_id > customer_city > city_postal_code
```

The city's postal code is determined by the customer's city, which is determined by the customer's ID, which is determined by the order's ID. `city_postal_code`, an attribute that is not part of the primary key, is determined by `customer_city`, which is also not part of the primary key, but `customer_city` is determined by `order_id` through `customer_id`. This means that the city's postal code will be repeated for every order placed by customers who live in the same city. This will lead to data redundancy. Additionally, any change to a city's postal code would require updates across multiple records.

To solve the transitive dependency, you would need to split the table into multiple tables. First, an `orders` table:

```sql
order_id | customer_id | order_date | product | quantity
```

Then, a `customers` table:

```sql
customer_id | city_name
```

And a `cities` table:

```sql
city_name | city_postal_code
```

This removes the transitive dependency from the table.

And finally, we have the Boyce-Codd Normal Form (BCNF). This is also known as Normal Form 3.5 because it addresses some anomalies that the Third Normal Form may not address. For a table to be in the Boyce-Codd Normal Form (BCNF), it has to:

- Be in Third Normal Form.
- Have every left-hand side of a functional dependency has to be a superkey.

The goal of this normal form is to ensure that every attribute or set of attributes that determines another attribute is a superkey, which is a candidate key or a superset of them.

Understanding and applying the normal forms is essential for designing robust and efficient relational databases. By eliminating data redundancy and ensuring logical data dependencies, normalization leads to improved data integrity, reduced storage requirements, and simplified database maintenance. You should usually aim to reach the Third Normal Form (3NF).


## What Is SQL Injection, and What Are Some Ways to Prevent It?

### Description

SQL injection is a web security vulnerability in which attackers change or take advantage of the queries that the web application makes to the database. For example, attackers can insert malicious SQL code into the query to run the malicious code on the backend.

This can happen when you give users the option to enter data through login forms, search bars, or URL parameters and then use that user input in string interpolation or concatenation to generate the final SQL command.

Depending on the attacker's goal, the malicious SQL code can cause significant disruptions on your database and web application, like bypassing authentication, stealing data from the database, or modifying or removing database records. Therefore, you should take this threat very seriously.

For example, let's say your web application uses an SQL query like this one to authenticate users, directly embedding the username and password entered by the user:

```sql
'SELECT * FROM users WHERE username = ' + username_input + ' AND password = ' + password_input + ';'
```

If an attacker enters something like this to the `username` field:

```sql
'" " OR "1"="1" --'
```

And anything else in the `password` field, since `"1"="1"` is always `true` and `--` comments out the rest of the query, the `WHERE` clause becomes:

```sql
WHERE username = " " OR TRUE
```

Which is always `true`.

Depending on the database implementation, this may return the data of the first user or any user in the database and allow the attacker to log in without valid credentials.

So how can you prevent this? There two main ways to prevent SQL injection:

- Don't write dynamic queries with string concatenation.
- And prevent malicious SQL input from being included in queries that will be executed in the backend.

In practice, you can use parameterized statements, also known as parameterized queries. They separate the SQL structure from the data entered by the user, which prevents the database from interpreting the input data as executable code.

Another important technique is input validation. This is recommended as a secondary security measure in all cases, but it's specially important for parts of SQL queries related to table names, column names, and sorting order. If possible, it's recommended to assign table names and column names directly within your code, not from user input.

If, despite all the preventive measures, you do get an SQL injection attack, you can minimize its impact on the database by limiting the permissions of each database account. Grant each database user only the permissions needed for their tasks, but nothing more. If an account only needs to read data from the database, grant it read access only. And as a preventive measure, never assign admin permissions to your application accounts. It is very dangerous to do so because an attacker could get complete access and full control over the database.

SQL injection is a very common attack that you, as a developer, should be aware of and prevent in the implementation of your web application. With these techniques, you can protect your database and keep your user's data safe.


## What Is the N+1 Problem?

### Description

The N+1 problem is a common performance bottleneck in database-driven applications. If you've ever experienced a really long load time while using an application, it's very likely related to the N+1 problem. This problem occurs when many small queries are being performed in a sequence to get the data you requested.

But why would you perform many queries in a sequence? You might do this to query a list of records and additional information about those records. You would perform an initial query to get the list of records and then perform an additional query for each one of those records, to get additional information about them.

Even if you intuitively think that performing many small and simple queries will be more efficient than performing just one large and complex query, this is usually not the case. The more queries you perform, the longer the entire process will take because you need to send each query to the server, find the data on the database, and then receive the data sent by the server for that query. This can have a very significant performance impact on your application.

To show you a practical example, let's say you're developing an application for a food delivery service and you run a query to get the first 50 orders in the database. First, you will get a list with these orders from an `orders` table, like this one:

```sql
order_id | product   | quantity | customer_id
1        | pizza     | 2        | 3422
2        | salad     | 1        | 1255
3        | ice cream | 4        | 2344
4        | donuts    | 10       | 3455
.        | .         | .        | .
.        | .         | .        | .
.        | .         | .        | .
```

But what if you also need to get the data of the customers who submitted these orders? This information would be stored in a different `customers` table.

One way to approach this would be to get the list of orders first and then run one query per order to get the customers' information. To get the list of orders, you could run a query like this one, to get the first 50 records from the `orders` table:

```sql
SELECT * FROM orders LIMIT 50;
```

This is where the 1 in N+1 comes from. It's the initial query that gives you the list of records. Then, you will need to perform another query for each one of these records to get the information of the customer who submitted the order. For this, you might write a loop in an asynchronous function to process both orders and customers. The `getCustomerData()` function will perform a SQL query to get the data of the customer who placed a specific order. It will do this in a sequence for each order that was placed:

```js
for (const order of orders) {
  const customerId = order.customer_id;
  const customerData = await getCustomerData(customerId);
  // Process the customer's data.
}
```

That's where the N in N+1 comes from. N represents the number of queries that will be performed to get additional data for each one of the records.

This approach might seem simple and intuitive, but you might be surprised to know that this is exactly what you shouldn't do. You should avoid making queries in a loop because making multiple small queries will take much longer than performing a single, larger query to get all the data.

You should try to use the tools that SQL gives you to reduce the number of queries as much as possible. In this case, we could use a `JOIN` operation to join the `orders` and `customers` table.

```sql
SELECT 
  orders.order_id,
  orders.product,
  orders.quantity,
  customers.customer_id,
  customers.name AS customer_name,
  customers.email AS customer_email,
  customers.address AS customer_address
FROM orders
JOIN customers ON orders.customer_id = customers.customer_id
WHERE orders.order_id IN (SELECT order_id FROM orders LIMIT 50)
```

With the `JOIN` operation, we can retrieve the data of the first 50 orders in the database, including the data of the customers, their names, email, and addresses, with only one query. It might look more complex, but it's actually more efficient this way.

Now you know what the N+1 problem involves, so you can identify it and prevent it, to interact with your database in an efficient way.


## Module: Git


### Lecture Block: Lecture Working With Nano


## What Is Nano?

### Description

When working in the terminal, standard text editors aren't always available, but there are programs designed to edit files directly from within the terminal.

Linux environments typically include a text editor. Vi, or Vim, tend to be the most common. Emacs and Nano may need to be installed manually, but they are readily available for nearly every distribution.

The challenge with Vim is it has a substantial learning curve. If you are not already familiar with it, you may not even know how to close the application! Emacs is arguably a bit more user friendly, but still has its own tome of keyboard shortcuts.

Nano is considerably more streamlined and user-friendly, especially for new learners. It can be much quicker to dive in and edit a file with Nano, and the application even offers on-screen help for the basic keyboard shortcuts.

The tradeoff for this, however, is the lack of extensibility. Unlike Vim or Emacs, which can be extended with plugins to become full development environments, Nano is rather barebones.

Let's take a peek at what Nano can do. To open a file, you can enter `nano <filename>` in the terminal.

Once a file is open, you will see the version of Nano you are running and the name of the file you have open at the top of the screen.

Below that is the content of the file. You can use the arrow keys to navigate your cursor and insert or delete text with your keyboard. The file will scroll as needed to follow.

Then, at the bottom, you will see a list of available keyboard shortcuts, that looks something like this:

```bash
^G Help   ^O Write Out    ^F Where Is   ^K Cut      ^T Execute  ^C Location     M-U Undo    M-A Set Mark    M-] To Bracket    M-B Previous
^X Exit   ^R Read File    ^\ Replace    ^U Paste    ^J Justify  ^/ Go To Line   M-E Redo    M-6 Copy        ^B Where Was      M-F Next
```

Shortcuts which start with the caret (`^`) symbol indicate you need to hold the Ctrl key and press the indicated letter. Shortcuts which start with `M-` require you to hold the "meta key", which in most setups should be the Alt key, and press the letter.

To edit a file in Nano, you only need to know a few of the shortcut commands. After making changes to a file, you can press `Ctrl + O` to "Write Out", or save, the file. After entering the command, you will see the menu at the bottom change to this:

```bash
File Name to write : <filename>
^G Get Help                 ^T  To Files
^C Cancel                   TAB Complete
```

Press enter to save the file and go back to editing the file, or `Ctrl + C` to cancel and go back to editing the file.

While in the editor, you can press `Ctrl + X` to exit Nano and go back to the terminal. If you have unsaved changes when trying to exit, you will see this in the bottom menu:

```bash
Save modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?
                            Y Yes
^C Cancel                   N No
```

Press `Y` to save your unsaved changes, or `N` to discard them.

With this knowledge, you should be better prepared the next time you need to quickly edit a file on a remote server, where you might not have access to a full graphical environment.


## Module: Review Relational Databases


# Chapter: Backend Javascript


## Module: Nodejs Core Libraries


## Module: Node Package Manager


## Module: Http And The Web Standards Model


## Module: Rest Api And Web Services


## Module: Introduction To Express


## Module: Express Middleware


## Module: Error Handling In Express


## Module: Websockets


## Module: Node And Sql


## Module: Security And Privacy


## Module: Authentication


## Module: Tooling And Deployment


# Chapter: Career


## Module: How To Get A Developer Job


## Module: Capstone Project


## Module: Certified Full Stack Developer Exam

